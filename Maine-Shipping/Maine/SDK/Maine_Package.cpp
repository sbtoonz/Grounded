/**
 * Name: Maine
 * Version: Shipping
 */

#include "pch.h"

namespace CG
{
	// --------------------------------------------------
	// # Structs Functions
	// --------------------------------------------------
	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Ability.GetCooldownTimeRemaining
	 * 		Flags  -> ()
	 */
	float UAbility::GetCooldownTimeRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Ability.GetCooldownTimeRemaining");
		
		UAbility_GetCooldownTimeRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAbility.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAbility::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Ability");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AchievementsComponent.ServerRequestAchievementReevaluation
	 * 		Flags  -> ()
	 */
	void UAchievementsComponent::ServerRequestAchievementReevaluation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AchievementsComponent.ServerRequestAchievementReevaluation");
		
		UAchievementsComponent_ServerRequestAchievementReevaluation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AchievementsComponent.OnTotalPartyPlayerStatChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPlayerStatConfig*                           PlayerStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAchievementsComponent::OnTotalPartyPlayerStatChanged(class UPlayerStatConfig* PlayerStat, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AchievementsComponent.OnTotalPartyPlayerStatChanged");
		
		UAchievementsComponent_OnTotalPartyPlayerStatChanged_Params params {};
		params.PlayerStat = PlayerStat;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AchievementsComponent.OnRep_Achievements
	 * 		Flags  -> ()
	 */
	void UAchievementsComponent::OnRep_Achievements()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AchievementsComponent.OnRep_Achievements");
		
		UAchievementsComponent_OnRep_Achievements_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AchievementsComponent.OnPlayerUpgradesChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPlayerUpgradeComponent*                     InPlayerUpgradeComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAchievementsComponent::OnPlayerUpgradesChanged(class UPlayerUpgradeComponent* InPlayerUpgradeComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AchievementsComponent.OnPlayerUpgradesChanged");
		
		UAchievementsComponent_OnPlayerUpgradesChanged_Params params {};
		params.InPlayerUpgradeComponent = InPlayerUpgradeComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AchievementsComponent.OnPlayerStatChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPlayerStatConfig*                           PlayerStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAchievementsComponent::OnPlayerStatChanged(class UPlayerStatConfig* PlayerStat, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AchievementsComponent.OnPlayerStatChanged");
		
		UAchievementsComponent_OnPlayerStatChanged_Params params {};
		params.PlayerStat = PlayerStat;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AchievementsComponent.OnKeyItemObtained
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AcquirerPlayerState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDataTableRowHandle>                 RecipesLearned                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UAchievementsComponent::OnKeyItemObtained(const struct FDataTableRowHandle& ItemRowHandle, class ASurvivalPlayerState* AcquirerPlayerState, TArray<struct FDataTableRowHandle> RecipesLearned)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AchievementsComponent.OnKeyItemObtained");
		
		UAchievementsComponent_OnKeyItemObtained_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.AcquirerPlayerState = AcquirerPlayerState;
		params.RecipesLearned = RecipesLearned;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AchievementsComponent.OnGlobalVariableChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       GlobalVariableID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            VariableValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAchievementsComponent::OnGlobalVariableChanged(const struct FGuid& GlobalVariableID, int32_t VariableValue, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AchievementsComponent.OnGlobalVariableChanged");
		
		UAchievementsComponent_OnGlobalVariableChanged_Params params {};
		params.GlobalVariableID = GlobalVariableID;
		params.VariableValue = VariableValue;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AchievementsComponent.ClientUpdateAchievementProgressOnline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      AchievementUnlockTag                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Progress                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAchievementsComponent::ClientUpdateAchievementProgressOnline(const class FString& AchievementUnlockTag, int32_t Progress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AchievementsComponent.ClientUpdateAchievementProgressOnline");
		
		UAchievementsComponent_ClientUpdateAchievementProgressOnline_Params params {};
		params.AchievementUnlockTag = AchievementUnlockTag;
		params.Progress = Progress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAchievementsComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAchievementsComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AchievementsComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUserWidget.OnUsingGamepadChangedImpl
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsUsingGamepad                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUserWidget::OnUsingGamepadChangedImpl(bool bIsUsingGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUserWidget.OnUsingGamepadChangedImpl");
		
		UGameUserWidget_OnUsingGamepadChangedImpl_Params params {};
		params.bIsUsingGamepad = bIsUsingGamepad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUserWidget.OnUsingGamepadChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOnUsingGamepadChanged                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUserWidget::OnUsingGamepadChanged(bool bOnUsingGamepadChanged)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUserWidget.OnUsingGamepadChanged");
		
		UGameUserWidget_OnUsingGamepadChanged_Params params {};
		params.bOnUsingGamepadChanged = bOnUsingGamepadChanged;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUserWidget.OnPossessedPlayerChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalPlayerCharacter*                    NewPlayerCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUserWidget::OnPossessedPlayerChange(class ASurvivalPlayerCharacter* NewPlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUserWidget.OnPossessedPlayerChange");
		
		UGameUserWidget_OnPossessedPlayerChange_Params params {};
		params.NewPlayerCharacter = NewPlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUserWidget.OnOwnerInventoryChanged
	 * 		Flags  -> ()
	 */
	void UGameUserWidget::OnOwnerInventoryChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUserWidget.OnOwnerInventoryChanged");
		
		UGameUserWidget_OnOwnerInventoryChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUserWidget.OnGlobalColorChangeImpl
	 * 		Flags  -> ()
	 */
	void UGameUserWidget::OnGlobalColorChangeImpl()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUserWidget.OnGlobalColorChangeImpl");
		
		UGameUserWidget_OnGlobalColorChangeImpl_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUserWidget.OnGlobalColorChange
	 * 		Flags  -> ()
	 */
	void UGameUserWidget::OnGlobalColorChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUserWidget.OnGlobalColorChange");
		
		UGameUserWidget_OnGlobalColorChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUserWidget.OnGameInputTypeChangedImpl
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGameInputType                                     NewGameInputType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUserWidget::OnGameInputTypeChangedImpl(EGameInputType NewGameInputType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUserWidget.OnGameInputTypeChangedImpl");
		
		UGameUserWidget_OnGameInputTypeChangedImpl_Params params {};
		params.NewGameInputType = NewGameInputType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUserWidget.OnGameInputTypeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGameInputType                                     NewGameInputType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUserWidget::OnGameInputTypeChanged(EGameInputType NewGameInputType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUserWidget.OnGameInputTypeChanged");
		
		UGameUserWidget_OnGameInputTypeChanged_Params params {};
		params.NewGameInputType = NewGameInputType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUserWidget.HandleKeyEventChord
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputChord                                 InChord                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGameUserWidget::HandleKeyEventChord(const struct FInputChord& InChord)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUserWidget.HandleKeyEventChord");
		
		UGameUserWidget_HandleKeyEventChord_Params params {};
		params.InChord = InChord;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUserWidget.GetSurvivalPlayerCharacter
	 * 		Flags  -> ()
	 */
	class ASurvivalPlayerCharacter* UGameUserWidget::GetSurvivalPlayerCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUserWidget.GetSurvivalPlayerCharacter");
		
		UGameUserWidget_GetSurvivalPlayerCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUserWidget.GetOwningSurvivalPlayerController
	 * 		Flags  -> ()
	 */
	class ASurvivalPlayerController* UGameUserWidget::GetOwningSurvivalPlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUserWidget.GetOwningSurvivalPlayerController");
		
		UGameUserWidget_GetOwningSurvivalPlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUserWidget.GetGameUI
	 * 		Flags  -> ()
	 */
	class AGameUI* UGameUserWidget::GetGameUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUserWidget.GetGameUI");
		
		UGameUserWidget_GetGameUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameUserWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameUserWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GameUserWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ActionWidget.ShouldShowControl
	 * 		Flags  -> ()
	 */
	bool UActionWidget::ShouldShowControl()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ActionWidget.ShouldShowControl");
		
		UActionWidget_ShouldShowControl_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ActionWidget.SetShowMouseKeyboardControls
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActionWidget::SetShowMouseKeyboardControls(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ActionWidget.SetShowMouseKeyboardControls");
		
		UActionWidget_SetShowMouseKeyboardControls_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ActionWidget.SetShowGamepadControls
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActionWidget::SetShowGamepadControls(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ActionWidget.SetShowGamepadControls");
		
		UActionWidget_SetShowGamepadControls_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ActionWidget.SetAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        InActionName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInAxisPositive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActionWidget::SetAction(const class FName& InActionName, bool bInAxisPositive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ActionWidget.SetAction");
		
		UActionWidget_SetAction_Params params {};
		params.InActionName = InActionName;
		params.bInAxisPositive = bInAxisPositive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ActionWidget.Refresh
	 * 		Flags  -> ()
	 */
	void UActionWidget::Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ActionWidget.Refresh");
		
		UActionWidget_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ActionWidget.NativeOnUsingGamepadChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsUsingGamepad                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActionWidget::NativeOnUsingGamepadChanged(bool bIsUsingGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ActionWidget.NativeOnUsingGamepadChanged");
		
		UActionWidget_NativeOnUsingGamepadChanged_Params params {};
		params.bIsUsingGamepad = bIsUsingGamepad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ActionWidget.HandleCultureChanged
	 * 		Flags  -> ()
	 */
	void UActionWidget::HandleCultureChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ActionWidget.HandleCultureChanged");
		
		UActionWidget_HandleCultureChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ActionWidget.HandleAxisMappingChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputAxisKeyMapping                        Value                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UActionWidget::HandleAxisMappingChanged(const struct FInputAxisKeyMapping& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ActionWidget.HandleAxisMappingChanged");
		
		UActionWidget_HandleAxisMappingChanged_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ActionWidget.HandleActionMappingChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputActionKeyMapping                      Value                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UActionWidget::HandleActionMappingChanged(const struct FInputActionKeyMapping& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ActionWidget.HandleActionMappingChanged");
		
		UActionWidget_HandleActionMappingChanged_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ActionWidget.GetFirstActionKey
	 * 		Flags  -> ()
	 */
	struct FKey UActionWidget::GetFirstActionKey()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ActionWidget.GetFirstActionKey");
		
		UActionWidget_GetFirstActionKey_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActionWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActionWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ActionWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ActorPoolComponent.ReleaseInstance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Instance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActorPoolComponent::ReleaseInstance(class AActor* Instance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ActorPoolComponent.ReleaseInstance");
		
		UActorPoolComponent_ReleaseInstance_Params params {};
		params.Instance = Instance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ActorPoolComponent.GetInstance
	 * 		Flags  -> ()
	 */
	class AActor* UActorPoolComponent::GetInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ActorPoolComponent.GetInstance");
		
		UActorPoolComponent_GetInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActorPoolComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActorPoolComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ActorPoolComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIDataProvider_ClimbingTag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIDataProvider_ClimbingTag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AIDataProvider_ClimbingTag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIDataProvider_FleeRange.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIDataProvider_FleeRange::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AIDataProvider_FleeRange");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIDataProvider_WanderRange.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIDataProvider_WanderRange::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AIDataProvider_WanderRange");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AIDetectionComponent.OnPerceptionUpdate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAIStimulus                                 Stimulus                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UAIDetectionComponent::OnPerceptionUpdate(class AActor* Actor, const struct FAIStimulus& Stimulus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AIDetectionComponent.OnPerceptionUpdate");
		
		UAIDetectionComponent_OnPerceptionUpdate_Params params {};
		params.Actor = Actor;
		params.Stimulus = Stimulus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIDetectionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIDetectionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AIDetectionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIEQSParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIEQSParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AIEQSParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttack_MinAttackDistance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttack_MinAttackDistance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Attack_MinAttackDistance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttack_MaxAttackDistance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttack_MaxAttackDistance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Attack_MaxAttackDistance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttack_PreferredMaxAttackDistance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttack_PreferredMaxAttackDistance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Attack_PreferredMaxAttackDistance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAI_MinimumHeight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAI_MinimumHeight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AI_MinimumHeight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAI_WanderRange.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAI_WanderRange::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AI_WanderRange");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAI_MovementSpeed.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAI_MovementSpeed::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AI_MovementSpeed");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAI_WaveSpawnRange.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAI_WaveSpawnRange::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AI_WaveSpawnRange");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAI_WaveSpawnSeparation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAI_WaveSpawnSeparation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AI_WaveSpawnSeparation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AISense_Shout.ReportShoutEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Shouter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAISense_Shout::ReportShoutEvent(class UObject* WorldContextObject, class AActor* Shouter, class AActor* Target, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AISense_Shout.ReportShoutEvent");
		
		UAISense_Shout_ReportShoutEvent_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Shouter = Shouter;
		params.Target = Target;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAISense_Shout.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAISense_Shout::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AISense_Shout");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AISense_Sound.ReportSoundEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Intensity                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAISense_Sound::ReportSoundEvent(class UObject* WorldContextObject, class AActor* Instigator, const struct FVector& Location, float Intensity, float Range, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AISense_Sound.ReportSoundEvent");
		
		UAISense_Sound_ReportSoundEvent_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Instigator = Instigator;
		params.Location = Location;
		params.Intensity = Intensity;
		params.Range = Range;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAISense_Sound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAISense_Sound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AISense_Sound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAISenseConfig_Shout.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAISenseConfig_Shout::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AISenseConfig_Shout");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAISenseConfig_Sound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAISenseConfig_Sound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AISenseConfig_Sound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AITargettingComponent.ValidateTargets
	 * 		Flags  -> ()
	 */
	void UAITargettingComponent::ValidateTargets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AITargettingComponent.ValidateTargets");
		
		UAITargettingComponent_ValidateTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AITargettingComponent.OnPerceptionUpdate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAIStimulus                                 Stimulus                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UAITargettingComponent::OnPerceptionUpdate(class AActor* Actor, const struct FAIStimulus& Stimulus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AITargettingComponent.OnPerceptionUpdate");
		
		UAITargettingComponent_OnPerceptionUpdate_Params params {};
		params.Actor = Actor;
		params.Stimulus = Stimulus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AITargettingComponent.GetTargetActor
	 * 		Flags  -> ()
	 */
	class AActor* UAITargettingComponent::GetTargetActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AITargettingComponent.GetTargetActor");
		
		UAITargettingComponent_GetTargetActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AITargettingComponent.CacheRandomOverrideTarget
	 * 		Flags  -> ()
	 */
	void UAITargettingComponent::CacheRandomOverrideTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AITargettingComponent.CacheRandomOverrideTarget");
		
		UAITargettingComponent_CacheRandomOverrideTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AITargettingComponent.CacheCurrentTarget
	 * 		Flags  -> ()
	 */
	void UAITargettingComponent::CacheCurrentTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AITargettingComponent.CacheCurrentTarget");
		
		UAITargettingComponent_CacheCurrentTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAITargettingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAITargettingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AITargettingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAITokenManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAITokenManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AITokenManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHourBasedOneShotsData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHourBasedOneShotsData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HourBasedOneShotsData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AmbienceManager.OnUpdateZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         PrevZoneDataTableRowHandle                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         NewZoneDataTableRowHandle                                  (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsSubmerged                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAmbienceManager::OnUpdateZone(const struct FDataTableRowHandle& PrevZoneDataTableRowHandle, const struct FDataTableRowHandle& NewZoneDataTableRowHandle, bool bIsSubmerged)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AmbienceManager.OnUpdateZone");
		
		UAmbienceManager_OnUpdateZone_Params params {};
		params.PrevZoneDataTableRowHandle = PrevZoneDataTableRowHandle;
		params.NewZoneDataTableRowHandle = NewZoneDataTableRowHandle;
		params.bIsSubmerged = bIsSubmerged;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AmbienceManager.OnHourChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewHour                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewDay                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAmbienceManager::OnHourChanged(int32_t NewHour, int32_t NewDay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AmbienceManager.OnHourChanged");
		
		UAmbienceManager_OnHourChanged_Params params {};
		params.NewHour = NewHour;
		params.NewDay = NewDay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AmbienceManager.HandleEnterNewZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ZoneAudioRowHandle                                         (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UAmbienceManager::HandleEnterNewZone(const struct FDataTableRowHandle& ZoneAudioRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AmbienceManager.HandleEnterNewZone");
		
		UAmbienceManager_HandleEnterNewZone_Params params {};
		params.ZoneAudioRowHandle = ZoneAudioRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AmbienceManager.GetLocalZoneAudioDataRowHandle
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UAmbienceManager::GetLocalZoneAudioDataRowHandle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AmbienceManager.GetLocalZoneAudioDataRowHandle");
		
		UAmbienceManager_GetLocalZoneAudioDataRowHandle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AmbienceManager.DestroyAllZoneBuckets
	 * 		Flags  -> ()
	 */
	void UAmbienceManager::DestroyAllZoneBuckets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AmbienceManager.DestroyAllZoneBuckets");
		
		UAmbienceManager_DestroyAllZoneBuckets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AmbienceManager.CreateNewZoneBuckets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UDataTable*                                  OneShotDataTable                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAmbienceManager::CreateNewZoneBuckets(class UDataTable* OneShotDataTable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AmbienceManager.CreateNewZoneBuckets");
		
		UAmbienceManager_CreateNewZoneBuckets_Params params {};
		params.OneShotDataTable = OneShotDataTable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAmbienceManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAmbienceManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AmbienceManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AmbienceZoneBucket.TryPlayOSAndStartTimer
	 * 		Flags  -> ()
	 */
	void UAmbienceZoneBucket::TryPlayOSAndStartTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AmbienceZoneBucket.TryPlayOSAndStartTimer");
		
		UAmbienceZoneBucket_TryPlayOSAndStartTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AmbienceZoneBucket.TryPlayingOneShot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            StartHourOfDay                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            EndHourOfDay                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Probability                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UAmbienceZoneBucket::TryPlayingOneShot(int32_t StartHourOfDay, int32_t EndHourOfDay, float Probability)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AmbienceZoneBucket.TryPlayingOneShot");
		
		UAmbienceZoneBucket_TryPlayingOneShot_Params params {};
		params.StartHourOfDay = StartHourOfDay;
		params.EndHourOfDay = EndHourOfDay;
		params.Probability = Probability;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AmbienceZoneBucket.StartTimer
	 * 		Flags  -> ()
	 */
	void UAmbienceZoneBucket::StartTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AmbienceZoneBucket.StartTimer");
		
		UAmbienceZoneBucket_StartTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AmbienceZoneBucket.IsHourWithingRange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            HourToCheck                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UAmbienceZoneBucket::IsHourWithingRange(int32_t HourToCheck)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AmbienceZoneBucket.IsHourWithingRange");
		
		UAmbienceZoneBucket_IsHourWithingRange_Params params {};
		params.HourToCheck = HourToCheck;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AmbienceZoneBucket.Init
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        InZoneOneShotEntryName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FZoneOneShotEntry                           InZoneOneShotEntry                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UAmbienceZoneBucket::Init(const class FName& InZoneOneShotEntryName, const struct FZoneOneShotEntry& InZoneOneShotEntry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AmbienceZoneBucket.Init");
		
		UAmbienceZoneBucket_Init_Params params {};
		params.InZoneOneShotEntryName = InZoneOneShotEntryName;
		params.InZoneOneShotEntry = InZoneOneShotEntry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AmbienceZoneBucket.Cleanup
	 * 		Flags  -> ()
	 */
	void UAmbienceZoneBucket::Cleanup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AmbienceZoneBucket.Cleanup");
		
		UAmbienceZoneBucket_Cleanup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAmbienceZoneBucket.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAmbienceZoneBucket::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AmbienceZoneBucket");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimationInteractComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimationInteractComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimationInteractComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseAnimEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseAnimEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BaseAnimEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_ConsumeFrame.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_ConsumeFrame::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotify_ConsumeFrame");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_DropItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_DropItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotify_DropItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_Footstep.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_Footstep::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotify_Footstep");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_HitFrame.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_HitFrame::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotify_HitFrame");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_InteractFrame.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_InteractFrame::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotify_InteractFrame");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_InteractShakeDown.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_InteractShakeDown::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotify_InteractShakeDown");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_LadderHandPlant.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_LadderHandPlant::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotify_LadderHandPlant");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_LightFire.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_LightFire::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotify_LightFire");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_PlayBiteEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_PlayBiteEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotify_PlayBiteEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_PlayCharacterSound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_PlayCharacterSound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotify_PlayCharacterSound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_SetMovementMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_SetMovementMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotify_SetMovementMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_ThrowItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_ThrowItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotify_ThrowItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_AttackRootMotion.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_AttackRootMotion::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotifyState_AttackRootMotion");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_DisableGravity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_DisableGravity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotifyState_DisableGravity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_ForceCameraMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_ForceCameraMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotifyState_ForceCameraMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_HideSlot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_HideSlot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotifyState_HideSlot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_HitActive.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_HitActive::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotifyState_HitActive");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_IgnoreFlinch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_IgnoreFlinch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotifyState_IgnoreFlinch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_IgnoreStagger.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_IgnoreStagger::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotifyState_IgnoreStagger");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_LerpToGround.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_LerpToGround::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotifyState_LerpToGround");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_LerpToInteract.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_LerpToInteract::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotifyState_LerpToInteract");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_LockSplineRotation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_LockSplineRotation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotifyState_LockSplineRotation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_MultiHitFrame.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_MultiHitFrame::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotifyState_MultiHitFrame");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_SetFlying.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_SetFlying::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotifyState_SetFlying");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_ShowProp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_ShowProp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AnimNotifyState_ShowProp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseAppearanceData.GetDefaultMesh
	 * 		Flags  -> ()
	 */
	class USkeletalMesh* UBaseAppearanceData::GetDefaultMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseAppearanceData.GetDefaultMesh");
		
		UBaseAppearanceData_GetDefaultMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseAppearanceData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseAppearanceData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BaseAppearanceData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAppearanceData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAppearanceData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AppearanceData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHairAppearanceData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHairAppearanceData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HairAppearanceData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.ValidateItemData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FText>                                ValidationErrors                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool ASpawnedItem::ValidateItemData(TArray<class FText>* ValidationErrors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.ValidateItemData");
		
		ASpawnedItem_ValidateItemData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ValidationErrors != nullptr)
			*ValidationErrors = params.ValidationErrors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.TickZipline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::TickZipline(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.TickZipline");
		
		ASpawnedItem_TickZipline_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.TickThrown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::TickThrown(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.TickThrown");
		
		ASpawnedItem_TickThrown_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.TickBuoyancy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::TickBuoyancy(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.TickBuoyancy");
		
		ASpawnedItem_TickBuoyancy_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.TickAttached
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::TickAttached(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.TickAttached");
		
		ASpawnedItem_TickAttached_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.Throw
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APawn*                                       Thrower                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Impulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     AngularImpulse                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::Throw(class APawn* Thrower, const struct FVector& Impulse, const struct FVector& AngularImpulse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.Throw");
		
		ASpawnedItem_Throw_Params params {};
		params.Thrower = Thrower;
		params.Impulse = Impulse;
		params.AngularImpulse = AngularImpulse;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.StartThrownAttack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Thrower                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::StartThrownAttack(class AActor* Thrower)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.StartThrownAttack");
		
		ASpawnedItem_StartThrownAttack_Params params {};
		params.Thrower = Thrower;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.SetEquippedOwner
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          NewOwner                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::SetEquippedOwner(class ASurvivalCharacter* NewOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.SetEquippedOwner");
		
		ASpawnedItem_SetEquippedOwner_Params params {};
		params.NewOwner = NewOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.ServerUseItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::ServerUseItem(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.ServerUseItem");
		
		ASpawnedItem_ServerUseItem_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.ServerUseAndDestroyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::ServerUseAndDestroyItem(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.ServerUseAndDestroyItem");
		
		ASpawnedItem_ServerUseAndDestroyItem_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.ServerPickupItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::ServerPickupItem(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.ServerPickupItem");
		
		ASpawnedItem_ServerPickupItem_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.ServerHaulItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::ServerHaulItem(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.ServerHaulItem");
		
		ASpawnedItem_ServerHaulItem_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.ServerEquipAndDestroyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::ServerEquipAndDestroyItem(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.ServerEquipAndDestroyItem");
		
		ASpawnedItem_ServerEquipAndDestroyItem_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.RemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       InItem                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ASpawnedItem::RemoveItem(class UItem* InItem, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.RemoveItem");
		
		ASpawnedItem_RemoveItem_Params params {};
		params.InItem = InItem;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.OnThrown
	 * 		Flags  -> ()
	 */
	void ASpawnedItem::OnThrown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.OnThrown");
		
		ASpawnedItem_OnThrown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.OnSelectedAmmoChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        SelectedAmmoType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::OnSelectedAmmoChanged(const class FName& SelectedAmmoType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.OnSelectedAmmoChanged");
		
		ASpawnedItem_OnSelectedAmmoChanged_Params params {};
		params.SelectedAmmoType = SelectedAmmoType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.OnRep_IsAttached
	 * 		Flags  -> ()
	 */
	void ASpawnedItem::OnRep_IsAttached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.OnRep_IsAttached");
		
		ASpawnedItem_OnRep_IsAttached_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.OnRep_AttachedZipline
	 * 		Flags  -> ()
	 */
	void ASpawnedItem::OnRep_AttachedZipline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.OnRep_AttachedZipline");
		
		ASpawnedItem_OnRep_AttachedZipline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.OnPhysicsWake
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         SleepingComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::OnPhysicsWake(class UPrimitiveComponent* SleepingComponent, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.OnPhysicsWake");
		
		ASpawnedItem_OnPhysicsWake_Params params {};
		params.SleepingComponent = SleepingComponent;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.OnPhysicsSleep
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         SleepingComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::OnPhysicsSleep(class UPrimitiveComponent* SleepingComponent, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.OnPhysicsSleep");
		
		ASpawnedItem_OnPhysicsSleep_Params params {};
		params.SleepingComponent = SleepingComponent;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.OnLaunchAttack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAttack*                                     Attack                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::OnLaunchAttack(class UAttack* Attack)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.OnLaunchAttack");
		
		ASpawnedItem_OnLaunchAttack_Params params {};
		params.Attack = Attack;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.OnItemUnequipped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::OnItemUnequipped(class ASurvivalCharacter* Character, EEquipmentSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.OnItemUnequipped");
		
		ASpawnedItem_OnItemUnequipped_Params params {};
		params.Character = Character;
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.OnItemEquipped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::OnItemEquipped(class ASurvivalCharacter* Character, EEquipmentSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.OnItemEquipped");
		
		ASpawnedItem_OnItemEquipped_Params params {};
		params.Character = Character;
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.OnHitWithAttack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::OnHitWithAttack(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.OnHitWithAttack");
		
		ASpawnedItem_OnHitWithAttack_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.NotifySwapped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFromDamage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::NotifySwapped(bool bFromDamage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.NotifySwapped");
		
		ASpawnedItem_NotifySwapped_Params params {};
		params.bFromDamage = bFromDamage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.NotifySpawned
	 * 		Flags  -> ()
	 */
	void ASpawnedItem::NotifySpawned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.NotifySpawned");
		
		ASpawnedItem_NotifySpawned_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.K2_Initialize
	 * 		Flags  -> ()
	 */
	void ASpawnedItem::K2_Initialize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.K2_Initialize");
		
		ASpawnedItem_K2_Initialize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.IsThrownAttackTimerActive
	 * 		Flags  -> ()
	 */
	bool ASpawnedItem::IsThrownAttackTimerActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.IsThrownAttackTimerActive");
		
		ASpawnedItem_IsThrownAttackTimerActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.IsHaulingItem
	 * 		Flags  -> ()
	 */
	bool ASpawnedItem::IsHaulingItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.IsHaulingItem");
		
		ASpawnedItem_IsHaulingItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.IsEmbeddableMaterial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPhysicalMaterial*                           Material                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASpawnedItem::IsEmbeddableMaterial(class UPhysicalMaterial* Material)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.IsEmbeddableMaterial");
		
		ASpawnedItem_IsEmbeddableMaterial_Params params {};
		params.Material = Material;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.HandleTouch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::HandleTouch(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.HandleTouch");
		
		ASpawnedItem_HandleTouch_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.HandlePhysicsVolumeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APhysicsVolume*                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::HandlePhysicsVolumeChanged(class APhysicsVolume* Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.HandlePhysicsVolumeChanged");
		
		ASpawnedItem_HandlePhysicsVolumeChanged_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.GetThrowStraight
	 * 		Flags  -> ()
	 */
	bool ASpawnedItem::GetThrowStraight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.GetThrowStraight");
		
		ASpawnedItem_GetThrowStraight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.GetPickupAudio
	 * 		Flags  -> ()
	 */
	class USoundCue* ASpawnedItem::GetPickupAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.GetPickupAudio");
		
		ASpawnedItem_GetPickupAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.GetItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> ASpawnedItem::GetItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.GetItems");
		
		ASpawnedItem_GetItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.GetItem
	 * 		Flags  -> ()
	 */
	class UItem* ASpawnedItem::GetItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.GetItem");
		
		ASpawnedItem_GetItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.GetEquippedOwner
	 * 		Flags  -> ()
	 */
	class ASurvivalCharacter* ASpawnedItem::GetEquippedOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.GetEquippedOwner");
		
		ASpawnedItem_GetEquippedOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.GetEquipAudio
	 * 		Flags  -> ()
	 */
	class USoundCue* ASpawnedItem::GetEquipAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.GetEquipAudio");
		
		ASpawnedItem_GetEquipAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.GetDroppedBySpawnedActor
	 * 		Flags  -> ()
	 */
	class ASurvivalCharacter* ASpawnedItem::GetDroppedBySpawnedActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.GetDroppedBySpawnedActor");
		
		ASpawnedItem_GetDroppedBySpawnedActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.GetDroppedBy
	 * 		Flags  -> ()
	 */
	class UBaseLODActor* ASpawnedItem::GetDroppedBy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.GetDroppedBy");
		
		ASpawnedItem_GetDroppedBy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.GetDistanceFromThrownLocation
	 * 		Flags  -> ()
	 */
	float ASpawnedItem::GetDistanceFromThrownLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.GetDistanceFromThrownLocation");
		
		ASpawnedItem_GetDistanceFromThrownLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.GetConsumeAudio
	 * 		Flags  -> ()
	 */
	class USoundCue* ASpawnedItem::GetConsumeAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.GetConsumeAudio");
		
		ASpawnedItem_GetConsumeAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.GetAttackOwner
	 * 		Flags  -> ()
	 */
	class AActor* ASpawnedItem::GetAttackOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.GetAttackOwner");
		
		ASpawnedItem_GetAttackOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.DoDetach
	 * 		Flags  -> ()
	 */
	void ASpawnedItem::DoDetach()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.DoDetach");
		
		ASpawnedItem_DoDetach_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.DelayedDestroy
	 * 		Flags  -> ()
	 */
	void ASpawnedItem::DelayedDestroy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.DelayedDestroy");
		
		ASpawnedItem_DelayedDestroy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.ClearThrownAttackTimer
	 * 		Flags  -> ()
	 */
	void ASpawnedItem::ClearThrownAttackTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.ClearThrownAttackTimer");
		
		ASpawnedItem_ClearThrownAttackTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.CanUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASpawnedItem::CanUse(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.CanUse");
		
		ASpawnedItem_CanUse_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.CanEquipTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASpawnedItem::CanEquipTo(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.CanEquipTo");
		
		ASpawnedItem_CanEquipTo_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.CanEquip
	 * 		Flags  -> ()
	 */
	bool ASpawnedItem::CanEquip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.CanEquip");
		
		ASpawnedItem_CanEquip_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.CanAddItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UItem*>                               InItems                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool ASpawnedItem::CanAddItems(TArray<class UItem*> InItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.CanAddItems");
		
		ASpawnedItem_CanAddItems_Params params {};
		params.InItems = InItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.CanAddItemRowHandles
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 ItemRowHandles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool ASpawnedItem::CanAddItemRowHandles(TArray<struct FDataTableRowHandle> ItemRowHandles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.CanAddItemRowHandles");
		
		ASpawnedItem_CanAddItemRowHandles_Params params {};
		params.ItemRowHandles = ItemRowHandles;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.CanAddItemRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool ASpawnedItem::CanAddItemRowHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.CanAddItemRowHandle");
		
		ASpawnedItem_CanAddItemRowHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.CanAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       InItem                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASpawnedItem::CanAddItem(class UItem* InItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.CanAddItem");
		
		ASpawnedItem_CanAddItem_Params params {};
		params.InItem = InItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.AllocateGOAPActions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USurvivalGameInstance*                       GameInstance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InOwner                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UGoapAction*> ASpawnedItem::AllocateGOAPActions(class USurvivalGameInstance* GameInstance, class UObject* InOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.AllocateGOAPActions");
		
		ASpawnedItem_AllocateGOAPActions_Params params {};
		params.GameInstance = GameInstance;
		params.InOwner = InOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItem.AddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       InItem                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNewItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItem::AddItem(class UItem* InItem, bool bIsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItem.AddItem");
		
		ASpawnedItem_AddItem_Params params {};
		params.InItem = InItem;
		params.bIsNewItem = bIsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpawnedItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpawnedItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SpawnedItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AArmorItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AArmorItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ArmorItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttachmentPoint.SetInUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AAttachmentPoint::SetInUse(bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttachmentPoint.SetInUse");
		
		AAttachmentPoint_SetInUse_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttachmentPoint.GetInUse
	 * 		Flags  -> ()
	 */
	bool AAttachmentPoint::GetInUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttachmentPoint.GetInUse");
		
		AAttachmentPoint_GetInUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttachmentPoint.GetArrow
	 * 		Flags  -> ()
	 */
	class UArrowComponent* AAttachmentPoint::GetArrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttachmentPoint.GetArrow");
		
		AAttachmentPoint_GetArrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAttachmentPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAttachmentPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AttachmentPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.SpawnProjectile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                                  SpawnTransform                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UAttack::SpawnProjectile(const struct FTransform& SpawnTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.SpawnProjectile");
		
		UAttack_SpawnProjectile_Params params {};
		params.SpawnTransform = SpawnTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.ShouldLockRotation
	 * 		Flags  -> ()
	 */
	bool UAttack::ShouldLockRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.ShouldLockRotation");
		
		UAttack_ShouldLockRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.ShouldEndOnHit
	 * 		Flags  -> ()
	 */
	bool UAttack::ShouldEndOnHit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.ShouldEndOnHit");
		
		UAttack_ShouldEndOnHit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.ResolveAttackForHitResult
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UAttack::ResolveAttackForHitResult(const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.ResolveAttackForHitResult");
		
		UAttack_ResolveAttackForHitResult_Params params {};
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.ResolveAttack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               UseSecondaryDamageData                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SecondaryDamageDataIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EAttackResolutionType UAttack::ResolveAttack(bool UseSecondaryDamageData, int32_t SecondaryDamageDataIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.ResolveAttack");
		
		UAttack_ResolveAttack_Params params {};
		params.UseSecondaryDamageData = UseSecondaryDamageData;
		params.SecondaryDamageDataIndex = SecondaryDamageDataIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.RequiresFacing
	 * 		Flags  -> ()
	 */
	bool UAttack::RequiresFacing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.RequiresFacing");
		
		UAttack_RequiresFacing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.IsSummonAttack
	 * 		Flags  -> ()
	 */
	bool UAttack::IsSummonAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.IsSummonAttack");
		
		UAttack_IsSummonAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.IsSelfDestruct
	 * 		Flags  -> ()
	 */
	bool UAttack::IsSelfDestruct()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.IsSelfDestruct");
		
		UAttack_IsSelfDestruct_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.IsSelfAttack
	 * 		Flags  -> ()
	 */
	bool UAttack::IsSelfAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.IsSelfAttack");
		
		UAttack_IsSelfAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.IsRangedAttack
	 * 		Flags  -> ()
	 */
	bool UAttack::IsRangedAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.IsRangedAttack");
		
		UAttack_IsRangedAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.IsLoopingAttack
	 * 		Flags  -> ()
	 */
	bool UAttack::IsLoopingAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.IsLoopingAttack");
		
		UAttack_IsLoopingAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.IsHostile
	 * 		Flags  -> ()
	 */
	bool UAttack::IsHostile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.IsHostile");
		
		UAttack_IsHostile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.IsHazardAttack
	 * 		Flags  -> ()
	 */
	bool UAttack::IsHazardAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.IsHazardAttack");
		
		UAttack_IsHazardAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.IsCharged
	 * 		Flags  -> ()
	 */
	bool UAttack::IsCharged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.IsCharged");
		
		UAttack_IsCharged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.IsAOE
	 * 		Flags  -> ()
	 */
	bool UAttack::IsAOE()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.IsAOE");
		
		UAttack_IsAOE_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.HasToSummonBossMobPhase
	 * 		Flags  -> ()
	 */
	bool UAttack::HasToSummonBossMobPhase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.HasToSummonBossMobPhase");
		
		UAttack_HasToSummonBossMobPhase_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetWeaponAnimMontage
	 * 		Flags  -> ()
	 */
	class UAnimMontage* UAttack::GetWeaponAnimMontage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetWeaponAnimMontage");
		
		UAttack_GetWeaponAnimMontage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetTier
	 * 		Flags  -> ()
	 */
	int32_t UAttack::GetTier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetTier");
		
		UAttack_GetTier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetStaminaCost
	 * 		Flags  -> ()
	 */
	int32_t UAttack::GetStaminaCost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetStaminaCost");
		
		UAttack_GetStaminaCost_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetSoundRange
	 * 		Flags  -> ()
	 */
	float UAttack::GetSoundRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetSoundRange");
		
		UAttack_GetSoundRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetSoundIntensity
	 * 		Flags  -> ()
	 */
	float UAttack::GetSoundIntensity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetSoundIntensity");
		
		UAttack_GetSoundIntensity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetPreferredMaxDistance
	 * 		Flags  -> ()
	 */
	float UAttack::GetPreferredMaxDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetPreferredMaxDistance");
		
		UAttack_GetPreferredMaxDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetPreferredHeight
	 * 		Flags  -> ()
	 */
	float UAttack::GetPreferredHeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetPreferredHeight");
		
		UAttack_GetPreferredHeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetPreferredDistancePostLunge
	 * 		Flags  -> ()
	 */
	float UAttack::GetPreferredDistancePostLunge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetPreferredDistancePostLunge");
		
		UAttack_GetPreferredDistancePostLunge_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetOwner
	 * 		Flags  -> ()
	 */
	class AActor* UAttack::GetOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetOwner");
		
		UAttack_GetOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetOverrideDeflectAnim
	 * 		Flags  -> ()
	 */
	class UAnimMontage* UAttack::GetOverrideDeflectAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetOverrideDeflectAnim");
		
		UAttack_GetOverrideDeflectAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetMinDistance
	 * 		Flags  -> ()
	 */
	float UAttack::GetMinDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetMinDistance");
		
		UAttack_GetMinDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetMaxDuration
	 * 		Flags  -> ()
	 */
	float UAttack::GetMaxDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetMaxDuration");
		
		UAttack_GetMaxDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetMaxDistance
	 * 		Flags  -> ()
	 */
	float UAttack::GetMaxDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetMaxDistance");
		
		UAttack_GetMaxDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetItemOwner
	 * 		Flags  -> ()
	 */
	class UItem* UAttack::GetItemOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetItemOwner");
		
		UAttack_GetItemOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetInstigator
	 * 		Flags  -> ()
	 */
	class AActor* UAttack::GetInstigator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetInstigator");
		
		UAttack_GetInstigator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetHitResolutionType
	 * 		Flags  -> ()
	 */
	EAttackHitType UAttack::GetHitResolutionType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetHitResolutionType");
		
		UAttack_GetHitResolutionType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetDeathNotification
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UAttack::GetDeathNotification()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetDeathNotification");
		
		UAttack_GetDeathNotification_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetDamageTypeFlags
	 * 		Flags  -> ()
	 */
	unsigned char UAttack::GetDamageTypeFlags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetDamageTypeFlags");
		
		UAttack_GetDamageTypeFlags_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetDamageType
	 * 		Flags  -> ()
	 */
	class UClass* UAttack::GetDamageType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetDamageType");
		
		UAttack_GetDamageType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetChargeTimer
	 * 		Flags  -> ()
	 */
	float UAttack::GetChargeTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetChargeTimer");
		
		UAttack_GetChargeTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetChargeRatio
	 * 		Flags  -> ()
	 */
	float UAttack::GetChargeRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetChargeRatio");
		
		UAttack_GetChargeRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetChargedStaminaCost
	 * 		Flags  -> ()
	 */
	int32_t UAttack::GetChargedStaminaCost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetChargedStaminaCost");
		
		UAttack_GetChargedStaminaCost_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetAttackRange
	 * 		Flags  -> ()
	 */
	float UAttack::GetAttackRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetAttackRange");
		
		UAttack_GetAttackRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.GetAnimMontage
	 * 		Flags  -> ()
	 */
	class UAnimMontage* UAttack::GetAnimMontage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.GetAnimMontage");
		
		UAttack_GetAnimMontage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.FireAttackOnFullCharge
	 * 		Flags  -> ()
	 */
	bool UAttack::FireAttackOnFullCharge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.FireAttackOnFullCharge");
		
		UAttack_FireAttackOnFullCharge_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Attack.CanCharge
	 * 		Flags  -> ()
	 */
	bool UAttack::CanCharge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Attack.CanCharge");
		
		UAttack_CanCharge_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttack.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttack::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Attack");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttackCombo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttackCombo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AttackCombo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttackAnimEffect.GetAttackSpeedTag
	 * 		Flags  -> ()
	 */
	struct FGameplayTag UAttackAnimEffect::GetAttackSpeedTag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttackAnimEffect.GetAttackSpeedTag");
		
		UAttackAnimEffect_GetAttackSpeedTag_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttackAnimEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttackAnimEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AttackAnimEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttackCapsuleComponent.OnEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAttackCapsuleComponent::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttackCapsuleComponent.OnEndOverlap");
		
		UAttackCapsuleComponent_OnEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttackCapsuleComponent.OnDeath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UAttackCapsuleComponent::OnDeath(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttackCapsuleComponent.OnDeath");
		
		UAttackCapsuleComponent_OnDeath_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttackCapsuleComponent.OnBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UAttackCapsuleComponent::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttackCapsuleComponent.OnBeginOverlap");
		
		UAttackCapsuleComponent_OnBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttackCapsuleComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttackCapsuleComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AttackCapsuleComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttackHandlerComponent.MulticastHandleEnvironmentHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         AttackDataRowHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UAttackHandlerComponent::MulticastHandleEnvironmentHit(const struct FDataTableRowHandle& AttackDataRowHandle, const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttackHandlerComponent.MulticastHandleEnvironmentHit");
		
		UAttackHandlerComponent_MulticastHandleEnvironmentHit_Params params {};
		params.AttackDataRowHandle = AttackDataRowHandle;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttackHandlerComponent.MulticastHandleAttackEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         AttackDataRowHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAttackHandlerComponent::MulticastHandleAttackEffects(const struct FDataTableRowHandle& AttackDataRowHandle, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttackHandlerComponent.MulticastHandleAttackEffects");
		
		UAttackHandlerComponent_MulticastHandleAttackEffects_Params params {};
		params.AttackDataRowHandle = AttackDataRowHandle;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttackHandlerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttackHandlerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AttackHandlerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttractionComponent.GetRestrictedToColonyId
	 * 		Flags  -> ()
	 */
	struct FColonyIdentifier UAttractionComponent::GetRestrictedToColonyId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttractionComponent.GetRestrictedToColonyId");
		
		UAttractionComponent_GetRestrictedToColonyId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttractionComponent.GetLODComponentClass
	 * 		Flags  -> ()
	 */
	class UClass* UAttractionComponent::GetLODComponentClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttractionComponent.GetLODComponentClass");
		
		UAttractionComponent_GetLODComponentClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttractionComponent.GetAdvertisedActions
	 * 		Flags  -> ()
	 */
	TArray<class UGoapAction*> UAttractionComponent::GetAdvertisedActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttractionComponent.GetAdvertisedActions");
		
		UAttractionComponent_GetAdvertisedActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttractionComponent.CanColonyUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FColonyIdentifier                           ColonyIdentifier                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UAttractionComponent::CanColonyUse(const struct FColonyIdentifier& ColonyIdentifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttractionComponent.CanColonyUse");
		
		UAttractionComponent_CanColonyUse_Params params {};
		params.ColonyIdentifier = ColonyIdentifier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttractionComponent.CanCharacterUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCharacterLODActor*                          Character                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UAttractionComponent::CanCharacterUse(class UCharacterLODActor* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttractionComponent.CanCharacterUse");
		
		UAttractionComponent_CanCharacterUse_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttractionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttractionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AttractionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxySceneComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxySceneComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxySceneComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyAttractionComponent.CanColonyUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FColonyIdentifier                           ColonyIdentifier                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UProxyAttractionComponent::CanColonyUse(const struct FColonyIdentifier& ColonyIdentifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyAttractionComponent.CanColonyUse");
		
		UProxyAttractionComponent_CanColonyUse_Params params {};
		params.ColonyIdentifier = ColonyIdentifier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyAttractionComponent.CanCharacterUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCharacterLODActor*                          Character                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UProxyAttractionComponent::CanCharacterUse(class UCharacterLODActor* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyAttractionComponent.CanCharacterUse");
		
		UProxyAttractionComponent_CanCharacterUse_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyAttractionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyAttractionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyAttractionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseLODComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseLODComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BaseLODComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USceneLODComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USceneLODComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SceneLODComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttractionLODComponent.GetSlotCount
	 * 		Flags  -> ()
	 */
	int32_t UAttractionLODComponent::GetSlotCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttractionLODComponent.GetSlotCount");
		
		UAttractionLODComponent_GetSlotCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttractionLODComponent.GetProjectToGround
	 * 		Flags  -> ()
	 */
	bool UAttractionLODComponent::GetProjectToGround()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttractionLODComponent.GetProjectToGround");
		
		UAttractionLODComponent_GetProjectToGround_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttractionLODComponent.GetGeneratedLocationType
	 * 		Flags  -> ()
	 */
	EGeneratedLocationType UAttractionLODComponent::GetGeneratedLocationType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttractionLODComponent.GetGeneratedLocationType");
		
		UAttractionLODComponent_GetGeneratedLocationType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttractionLODComponent.GetAdvertisedActions
	 * 		Flags  -> ()
	 */
	TArray<class UGoapAction*> UAttractionLODComponent::GetAdvertisedActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttractionLODComponent.GetAdvertisedActions");
		
		UAttractionLODComponent_GetAdvertisedActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttractionLODComponent.CanColonyUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FColonyIdentifier                           ColonyIdentifier                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UAttractionLODComponent::CanColonyUse(const struct FColonyIdentifier& ColonyIdentifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttractionLODComponent.CanColonyUse");
		
		UAttractionLODComponent_CanColonyUse_Params params {};
		params.ColonyIdentifier = ColonyIdentifier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AttractionLODComponent.CanCharacterUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCharacterLODActor*                          Character                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UAttractionLODComponent::CanCharacterUse(class UCharacterLODActor* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AttractionLODComponent.CanCharacterUse");
		
		UAttractionLODComponent_CanCharacterUse_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttractionLODComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttractionLODComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AttractionLODComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttractionManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttractionManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AttractionManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AuraEmitterComponent.OnEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAuraEmitterComponent::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AuraEmitterComponent.OnEndOverlap");
		
		UAuraEmitterComponent_OnEndOverlap_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.AuraEmitterComponent.OnBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAuraEmitterComponent::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.AuraEmitterComponent.OnBeginOverlap");
		
		UAuraEmitterComponent_OnBeginOverlap_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAuraEmitterComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAuraEmitterComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AuraEmitterComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAuraReceiverComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAuraReceiverComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.AuraReceiverComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BanterStarterComponent.StartBanter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalPlayerController*                   Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBanterStarterComponent::StartBanter(class ASurvivalPlayerController* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BanterStarterComponent.StartBanter");
		
		UBanterStarterComponent_StartBanter_Params params {};
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BanterStarterComponent.OnLookTriggered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ULookTriggerComponent*                       Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLookTriggeredParams                        Params                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UBanterStarterComponent::OnLookTriggered(class ULookTriggerComponent* Sender, const struct FLookTriggeredParams& Params)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BanterStarterComponent.OnLookTriggered");
		
		UBanterStarterComponent_OnLookTriggered_Params params {};
		params.Sender = Sender;
		params.Params = Params;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBanterStarterComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBanterStarterComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BanterStarterComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseCreditsTextWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseCreditsTextWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BaseCreditsTextWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseGoapRegionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseGoapRegionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BaseGoapRegionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseLODActor.SetLifeSpan
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InLifespan                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseLODActor::SetLifeSpan(float InLifespan)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseLODActor.SetLifeSpan");
		
		UBaseLODActor_SetLifeSpan_Params params {};
		params.InLifespan = InLifespan;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseLODActor.OnFullActorPostInitializeComponents
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Sender                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseLODActor::OnFullActorPostInitializeComponents(class AActor* Sender)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseLODActor.OnFullActorPostInitializeComponents");
		
		UBaseLODActor_OnFullActorPostInitializeComponents_Params params {};
		params.Sender = Sender;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseLODActor.K2_GetFullActor
	 * 		Flags  -> ()
	 */
	class AActor* UBaseLODActor::K2_GetFullActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseLODActor.K2_GetFullActor");
		
		UBaseLODActor_K2_GetFullActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseLODActor.HandleLifetimeExpired
	 * 		Flags  -> ()
	 */
	void UBaseLODActor::HandleLifetimeExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseLODActor.HandleLifetimeExpired");
		
		UBaseLODActor_HandleLifetimeExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseLODActor.HandleFullActorDestroyed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseLODActor::HandleFullActorDestroyed(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseLODActor.HandleFullActorDestroyed");
		
		UBaseLODActor_HandleFullActorDestroyed_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseLODActor.GetLifeSpan
	 * 		Flags  -> ()
	 */
	float UBaseLODActor::GetLifeSpan()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseLODActor.GetLifeSpan");
		
		UBaseLODActor_GetLifeSpan_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseLODActor.GetComponentByClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      InClass                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseLODComponent* UBaseLODActor::GetComponentByClass(class UClass* InClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseLODActor.GetComponentByClass");
		
		UBaseLODActor_GetComponentByClass_Params params {};
		params.InClass = InClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseLODActor.GetActorTransform
	 * 		Flags  -> ()
	 */
	struct FTransform UBaseLODActor::GetActorTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseLODActor.GetActorTransform");
		
		UBaseLODActor_GetActorTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseLODActor.GetActorRotation
	 * 		Flags  -> ()
	 */
	struct FQuat UBaseLODActor::GetActorRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseLODActor.GetActorRotation");
		
		UBaseLODActor_GetActorRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseLODActor.GetActorLocation
	 * 		Flags  -> ()
	 */
	struct FVector UBaseLODActor::GetActorLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseLODActor.GetActorLocation");
		
		UBaseLODActor_GetActorLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseLODActor.GetActorClass
	 * 		Flags  -> ()
	 */
	class UClass* UBaseLODActor::GetActorClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseLODActor.GetActorClass");
		
		UBaseLODActor_GetActorClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseLODActor.ContainsActorTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBaseLODActor::ContainsActorTag(const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseLODActor.ContainsActorTag");
		
		UBaseLODActor_ContainsActorTag_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseLODActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseLODActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BaseLODActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseManagerComponent.IsWithinRangeOfBase
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBaseManagerComponent::IsWithinRangeOfBase(const struct FVector& Location, float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseManagerComponent.IsWithinRangeOfBase");
		
		UBaseManagerComponent_IsWithinRangeOfBase_Params params {};
		params.Location = Location;
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseManagerComponent.IsAnyTargetWithinRangeOfBase
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              Targets                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBaseManagerComponent::IsAnyTargetWithinRangeOfBase(TArray<class AActor*> Targets, float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseManagerComponent.IsAnyTargetWithinRangeOfBase");
		
		UBaseManagerComponent_IsAnyTargetWithinRangeOfBase_Params params {};
		params.Targets = Targets;
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseManagerComponent.HasBase
	 * 		Flags  -> ()
	 */
	bool UBaseManagerComponent::HasBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseManagerComponent.HasBase");
		
		UBaseManagerComponent_HasBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseManagerComponent.GetTotalHeat
	 * 		Flags  -> ()
	 */
	int32_t UBaseManagerComponent::GetTotalHeat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseManagerComponent.GetTotalHeat");
		
		UBaseManagerComponent_GetTotalHeat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseManagerComponent.GetRandomBaseLocation
	 * 		Flags  -> ()
	 */
	struct FVector UBaseManagerComponent::GetRandomBaseLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseManagerComponent.GetRandomBaseLocation");
		
		UBaseManagerComponent_GetRandomBaseLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseManagerComponent.GetLargestBaseIndexWithinRangeOfTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              Targets                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UBaseManagerComponent::GetLargestBaseIndexWithinRangeOfTarget(TArray<class AActor*> Targets, float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseManagerComponent.GetLargestBaseIndexWithinRangeOfTarget");
		
		UBaseManagerComponent_GetLargestBaseIndexWithinRangeOfTarget_Params params {};
		params.Targets = Targets;
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseManagerComponent.GetClosestBaseIndexToTargets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              Targets                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	int32_t UBaseManagerComponent::GetClosestBaseIndexToTargets(TArray<class AActor*> Targets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseManagerComponent.GetClosestBaseIndexToTargets");
		
		UBaseManagerComponent_GetClosestBaseIndexToTargets_Params params {};
		params.Targets = Targets;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseManagerComponent.GetClosestBaseIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UBaseManagerComponent::GetClosestBaseIndex(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseManagerComponent.GetClosestBaseIndex");
		
		UBaseManagerComponent_GetClosestBaseIndex_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseManagerComponent.GetBaseRadius
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            BaseIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UBaseManagerComponent::GetBaseRadius(int32_t BaseIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseManagerComponent.GetBaseRadius");
		
		UBaseManagerComponent_GetBaseRadius_Params params {};
		params.BaseIndex = BaseIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseManagerComponent.GetBaseLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            BaseIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UBaseManagerComponent::GetBaseLocation(int32_t BaseIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseManagerComponent.GetBaseLocation");
		
		UBaseManagerComponent_GetBaseLocation_Params params {};
		params.BaseIndex = BaseIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BaseManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseMapEntryWidget.RefreshVisuals
	 * 		Flags  -> ()
	 */
	void UBaseMapEntryWidget::RefreshVisuals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseMapEntryWidget.RefreshVisuals");
		
		UBaseMapEntryWidget_RefreshVisuals_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseMapEntryWidget.HasWorldPosition
	 * 		Flags  -> ()
	 */
	bool UBaseMapEntryWidget::HasWorldPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseMapEntryWidget.HasWorldPosition");
		
		UBaseMapEntryWidget_HasWorldPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseMapEntryWidget.GetWorldPosition2D
	 * 		Flags  -> ()
	 */
	struct FVector2D UBaseMapEntryWidget::GetWorldPosition2D()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseMapEntryWidget.GetWorldPosition2D");
		
		UBaseMapEntryWidget_GetWorldPosition2D_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseMapEntryWidget.GetMapEntryType
	 * 		Flags  -> ()
	 */
	EMapEntryType UBaseMapEntryWidget::GetMapEntryType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseMapEntryWidget.GetMapEntryType");
		
		UBaseMapEntryWidget_GetMapEntryType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseMapEntryWidget.GetEntryName
	 * 		Flags  -> ()
	 */
	class FString UBaseMapEntryWidget::GetEntryName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseMapEntryWidget.GetEntryName");
		
		UBaseMapEntryWidget_GetEntryName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseMapEntryWidget.GetDescriptionWindowIcon
	 * 		Flags  -> ()
	 */
	struct FSlateBrush UBaseMapEntryWidget::GetDescriptionWindowIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseMapEntryWidget.GetDescriptionWindowIcon");
		
		UBaseMapEntryWidget_GetDescriptionWindowIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseMapEntryWidget.CanToggleVisibility
	 * 		Flags  -> ()
	 */
	bool UBaseMapEntryWidget::CanToggleVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseMapEntryWidget.CanToggleVisibility");
		
		UBaseMapEntryWidget_CanToggleVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseMapEntryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseMapEntryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BaseMapEntryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseObjective.IsCompleted
	 * 		Flags  -> ()
	 */
	bool UBaseObjective::IsCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseObjective.IsCompleted");
		
		UBaseObjective_IsCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseObjective.IsActive
	 * 		Flags  -> ()
	 */
	bool UBaseObjective::IsActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseObjective.IsActive");
		
		UBaseObjective_IsActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseObjective.GetDisplayName
	 * 		Flags  -> ()
	 */
	class FString UBaseObjective::GetDisplayName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseObjective.GetDisplayName");
		
		UBaseObjective_GetDisplayName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseObjective.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseObjective::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BaseObjective");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseQuest.IsCompleted
	 * 		Flags  -> ()
	 */
	bool UBaseQuest::IsCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseQuest.IsCompleted");
		
		UBaseQuest_IsCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseQuest.GetObjectives
	 * 		Flags  -> ()
	 */
	TArray<class UBaseObjective*> UBaseQuest::GetObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseQuest.GetObjectives");
		
		UBaseQuest_GetObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseQuest.GetDisplayName
	 * 		Flags  -> ()
	 */
	class FString UBaseQuest::GetDisplayName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseQuest.GetDisplayName");
		
		UBaseQuest_GetDisplayName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseQuest.GetDisplayDescription
	 * 		Flags  -> ()
	 */
	class FString UBaseQuest::GetDisplayDescription()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseQuest.GetDisplayDescription");
		
		UBaseQuest_GetDisplayDescription_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseQuest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseQuest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BaseQuest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseSettingsWidget.SetLocalizedInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLocString                                  InDisplayString                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLocString                                  InDescString                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseSettingsWidget::SetLocalizedInfo(const struct FLocString& InDisplayString, const struct FLocString& InDescString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseSettingsWidget.SetLocalizedInfo");
		
		UBaseSettingsWidget_SetLocalizedInfo_Params params {};
		params.InDisplayString = InDisplayString;
		params.InDescString = InDescString;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseSettingsWidget.SetCacheAndConfirm
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseSettingsWidget::SetCacheAndConfirm(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseSettingsWidget.SetCacheAndConfirm");
		
		UBaseSettingsWidget_SetCacheAndConfirm_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseSettingsWidget.SetApplyImmediately
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseSettingsWidget::SetApplyImmediately(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseSettingsWidget.SetApplyImmediately");
		
		UBaseSettingsWidget_SetApplyImmediately_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseSettingsWidget.NotifyHovered
	 * 		Flags  -> ()
	 */
	void UBaseSettingsWidget::NotifyHovered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseSettingsWidget.NotifyHovered");
		
		UBaseSettingsWidget_NotifyHovered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseSettingsWidget.NotifyFocused
	 * 		Flags  -> ()
	 */
	void UBaseSettingsWidget::NotifyFocused()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseSettingsWidget.NotifyFocused");
		
		UBaseSettingsWidget_NotifyFocused_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseSettingsWidget.IsCacheAndConfirmSetting
	 * 		Flags  -> ()
	 */
	bool UBaseSettingsWidget::IsCacheAndConfirmSetting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseSettingsWidget.IsCacheAndConfirmSetting");
		
		UBaseSettingsWidget_IsCacheAndConfirmSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseSettingsWidget.GetShowKeybindingControls
	 * 		Flags  -> ()
	 */
	bool UBaseSettingsWidget::GetShowKeybindingControls()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseSettingsWidget.GetShowKeybindingControls");
		
		UBaseSettingsWidget_GetShowKeybindingControls_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseSettingsWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseSettingsWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BaseSettingsWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseSlotWidget.OnItemRefChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseSlotWidget::OnItemRefChanged(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseSlotWidget.OnItemRefChanged");
		
		UBaseSlotWidget_OnItemRefChanged_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseSlotWidget.OnIsItemNew
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsNewItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseSlotWidget::OnIsItemNew(bool bIsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseSlotWidget.OnIsItemNew");
		
		UBaseSlotWidget_OnIsItemNew_Params params {};
		params.bIsNewItem = bIsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseSlotWidget.GetIsSelected
	 * 		Flags  -> ()
	 */
	bool UBaseSlotWidget::GetIsSelected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseSlotWidget.GetIsSelected");
		
		UBaseSlotWidget_GetIsSelected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseSlotWidget.EvaluateSlotOnChange
	 * 		Flags  -> ()
	 */
	void UBaseSlotWidget::EvaluateSlotOnChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseSlotWidget.EvaluateSlotOnChange");
		
		UBaseSlotWidget_EvaluateSlotOnChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseSlotWidget.EvaluateItemIsNewVisuals
	 * 		Flags  -> ()
	 */
	void UBaseSlotWidget::EvaluateItemIsNewVisuals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseSlotWidget.EvaluateItemIsNewVisuals");
		
		UBaseSlotWidget_EvaluateItemIsNewVisuals_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BaseSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BestiaryComponent.OnPlayerStatChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPlayerStatConfig*                           PlayerStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBestiaryComponent::OnPlayerStatChanged(class UPlayerStatConfig* PlayerStat, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BestiaryComponent.OnPlayerStatChanged");
		
		UBestiaryComponent_OnPlayerStatChanged_Params params {};
		params.PlayerStat = PlayerStat;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BestiaryComponent.IsTierUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         BestiaryRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            UnlockTier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBestiaryComponent::IsTierUnlocked(const struct FDataTableRowHandle& BestiaryRowHandle, int32_t UnlockTier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BestiaryComponent.IsTierUnlocked");
		
		UBestiaryComponent_IsTierUnlocked_Params params {};
		params.BestiaryRowHandle = BestiaryRowHandle;
		params.UnlockTier = UnlockTier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BestiaryComponent.GetStatValueForUnlockTier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         BestiaryRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            UnlockTier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UBestiaryComponent::GetStatValueForUnlockTier(const struct FDataTableRowHandle& BestiaryRowHandle, int32_t UnlockTier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BestiaryComponent.GetStatValueForUnlockTier");
		
		UBestiaryComponent_GetStatValueForUnlockTier_Params params {};
		params.BestiaryRowHandle = BestiaryRowHandle;
		params.UnlockTier = UnlockTier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BestiaryComponent.GetStatValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPlayerStatConfig*                           Stat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UBestiaryComponent::GetStatValue(class UPlayerStatConfig* Stat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BestiaryComponent.GetStatValue");
		
		UBestiaryComponent_GetStatValue_Params params {};
		params.Stat = Stat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBestiaryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBestiaryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BestiaryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WindowWidget.SetFramerateLimitOnWidgetStackChanged
	 * 		Flags  -> ()
	 */
	void UWindowWidget::SetFramerateLimitOnWidgetStackChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WindowWidget.SetFramerateLimitOnWidgetStackChanged");
		
		UWindowWidget_SetFramerateLimitOnWidgetStackChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WindowWidget.SetDefaultUserFocus
	 * 		Flags  -> ()
	 */
	void UWindowWidget::SetDefaultUserFocus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WindowWidget.SetDefaultUserFocus");
		
		UWindowWidget_SetDefaultUserFocus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WindowWidget.ResetWidget
	 * 		Flags  -> ()
	 */
	void UWindowWidget::ResetWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WindowWidget.ResetWidget");
		
		UWindowWidget_ResetWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WindowWidget.RefreshWidget
	 * 		Flags  -> ()
	 */
	void UWindowWidget::RefreshWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WindowWidget.RefreshWidget");
		
		UWindowWidget_RefreshWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WindowWidget.HandleWindowClosed
	 * 		Flags  -> ()
	 */
	void UWindowWidget::HandleWindowClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WindowWidget.HandleWindowClosed");
		
		UWindowWidget_HandleWindowClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WindowWidget.GetDefaultUserFocus
	 * 		Flags  -> ()
	 */
	class UWidget* UWindowWidget::GetDefaultUserFocus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WindowWidget.GetDefaultUserFocus");
		
		UWindowWidget_GetDefaultUserFocus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WindowWidget.CloseWindow
	 * 		Flags  -> ()
	 */
	void UWindowWidget::CloseWindow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WindowWidget.CloseWindow");
		
		UWindowWidget_CloseWindow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWindowWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWindowWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WindowWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BindKeyPopUp.SelectControl
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputChord                                 Chord                                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBindKeyPopUp::SelectControl(const struct FInputChord& Chord)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BindKeyPopUp.SelectControl");
		
		UBindKeyPopUp_SelectControl_Params params {};
		params.Chord = Chord;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BindKeyPopUp.InitControlMapping
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAnyControlMapping                          Control                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bInIsGamepad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBindKeyPopUp::InitControlMapping(const struct FAnyControlMapping& Control, bool bInIsGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BindKeyPopUp.InitControlMapping");
		
		UBindKeyPopUp_InitControlMapping_Params params {};
		params.Control = Control;
		params.bInIsGamepad = bInIsGamepad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BindKeyPopUp.GetIsMapped
	 * 		Flags  -> ()
	 */
	bool UBindKeyPopUp::GetIsMapped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BindKeyPopUp.GetIsMapped");
		
		UBindKeyPopUp_GetIsMapped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BindKeyPopUp.GetInstructionsText
	 * 		Flags  -> ()
	 */
	class FText UBindKeyPopUp::GetInstructionsText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BindKeyPopUp.GetInstructionsText");
		
		UBindKeyPopUp_GetInstructionsText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BindKeyPopUp.GetCurrentMappingKey
	 * 		Flags  -> ()
	 */
	struct FAnyControlMappingKey UBindKeyPopUp::GetCurrentMappingKey()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BindKeyPopUp.GetCurrentMappingKey");
		
		UBindKeyPopUp_GetCurrentMappingKey_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BindKeyPopUp.GetCurrentInputChord
	 * 		Flags  -> ()
	 */
	struct FInputChord UBindKeyPopUp::GetCurrentInputChord()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BindKeyPopUp.GetCurrentInputChord");
		
		UBindKeyPopUp_GetCurrentInputChord_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction Maine.BindKeyPopUp.ControlBound__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAnyControlMapping                          NewValue                                                   (Parm, NativeAccessSpecifierPublic)
	 */
	void UBindKeyPopUp::ControlBound__DelegateSignature(const struct FAnyControlMapping& NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Maine.BindKeyPopUp.ControlBound__DelegateSignature");
		
		UBindKeyPopUp_ControlBound__DelegateSignature_Params params {};
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBindKeyPopUp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBindKeyPopUp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BindKeyPopUp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Bird.OnRep_CurrentState
	 * 		Flags  -> ()
	 */
	void ABird::OnRep_CurrentState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Bird.OnRep_CurrentState");
		
		ABird_OnRep_CurrentState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Bird.HandleSpawn
	 * 		Flags  -> ()
	 */
	void ABird::HandleSpawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Bird.HandleSpawn");
		
		ABird_HandleSpawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Bird.HandleDespawn
	 * 		Flags  -> ()
	 */
	void ABird::HandleDespawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Bird.HandleDespawn");
		
		ABird_HandleDespawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Bird.GetState
	 * 		Flags  -> ()
	 */
	EBirdState ABird::GetState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Bird.GetState");
		
		ABird_GetState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Bird.GetCurrentLandSpot
	 * 		Flags  -> ()
	 */
	class ABirdLandSpot* ABird::GetCurrentLandSpot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Bird.GetCurrentLandSpot");
		
		ABird_GetCurrentLandSpot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABird.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABird::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Bird");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBirdAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBirdAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BirdAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BirdLandSpot.GetSpotType
	 * 		Flags  -> ()
	 */
	EBirdSpotType ABirdLandSpot::GetSpotType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BirdLandSpot.GetSpotType");
		
		ABirdLandSpot_GetSpotType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BirdLandSpot.GetExitSpline
	 * 		Flags  -> ()
	 */
	class USplineComponent* ABirdLandSpot::GetExitSpline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BirdLandSpot.GetExitSpline");
		
		ABirdLandSpot_GetExitSpline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BirdLandSpot.GetEnterSpline
	 * 		Flags  -> ()
	 */
	class USplineComponent* ABirdLandSpot::GetEnterSpline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BirdLandSpot.GetEnterSpline");
		
		ABirdLandSpot_GetEnterSpline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABirdLandSpot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABirdLandSpot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BirdLandSpot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlackboardKeyType_FoliageKey.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlackboardKeyType_FoliageKey::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BlackboardKeyType_FoliageKey");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BlockComponent.OnStatusEffectsChanged
	 * 		Flags  -> ()
	 */
	void UBlockComponent::OnStatusEffectsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BlockComponent.OnStatusEffectsChanged");
		
		UBlockComponent_OnStatusEffectsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BlockComponent.OnRep_IsBlocking
	 * 		Flags  -> ()
	 */
	void UBlockComponent::OnRep_IsBlocking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BlockComponent.OnRep_IsBlocking");
		
		UBlockComponent_OnRep_IsBlocking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BlockComponent.MulticastPlayBlockEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EBlockType                                         BlockType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBlockComponent::MulticastPlayBlockEffects(EBlockType BlockType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BlockComponent.MulticastPlayBlockEffects");
		
		UBlockComponent_MulticastPlayBlockEffects_Params params {};
		params.BlockType = BlockType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BlockComponent.IsBlocking
	 * 		Flags  -> ()
	 */
	bool UBlockComponent::IsBlocking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BlockComponent.IsBlocking");
		
		UBlockComponent_IsBlocking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BlockComponent.GetMaxBlockMeter
	 * 		Flags  -> ()
	 */
	float UBlockComponent::GetMaxBlockMeter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BlockComponent.GetMaxBlockMeter");
		
		UBlockComponent_GetMaxBlockMeter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BlockComponent.GetBlockMeter
	 * 		Flags  -> ()
	 */
	float UBlockComponent::GetBlockMeter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BlockComponent.GetBlockMeter");
		
		UBlockComponent_GetBlockMeter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BlockComponent.GetBlockItem
	 * 		Flags  -> ()
	 */
	class UItem* UBlockComponent::GetBlockItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BlockComponent.GetBlockItem");
		
		UBlockComponent_GetBlockItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlockComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlockComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BlockComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossComponent.SpawnMobsEncountersPhase
	 * 		Flags  -> ()
	 */
	void UBossComponent::SpawnMobsEncountersPhase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossComponent.SpawnMobsEncountersPhase");
		
		UBossComponent_SpawnMobsEncountersPhase_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossComponent.SetBossManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABossManager*                                NewBossManager                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBossComponent::SetBossManager(class ABossManager* NewBossManager)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossComponent.SetBossManager");
		
		UBossComponent_SetBossManager_Params params {};
		params.NewBossManager = NewBossManager;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossComponent.OnHealthChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHealthComponent*                            SourceHealthComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OldHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBossComponent::OnHealthChanged(class UHealthComponent* SourceHealthComponent, float NewHealth, float OldHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossComponent.OnHealthChanged");
		
		UBossComponent_OnHealthChanged_Params params {};
		params.SourceHealthComponent = SourceHealthComponent;
		params.NewHealth = NewHealth;
		params.OldHealth = OldHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossComponent.AllMobsEncounterKilled
	 * 		Flags  -> ()
	 */
	void UBossComponent::AllMobsEncounterKilled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossComponent.AllMobsEncounterKilled");
		
		UBossComponent_AllMobsEncounterKilled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBossComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBossComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BossComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.SpawnPhaseEncounter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PhaseIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABossManager::SpawnPhaseEncounter(int32_t PhaseIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.SpawnPhaseEncounter");
		
		ABossManager_SpawnPhaseEncounter_Params params {};
		params.PhaseIndex = PhaseIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.SpawnActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Transform                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ABossManager::SpawnActor(class UClass* Class, const struct FTransform& Transform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.SpawnActor");
		
		ABossManager_SpawnActor_Params params {};
		params.Class = Class;
		params.Transform = Transform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.OnVolumeEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABossManager::OnVolumeEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.OnVolumeEndOverlap");
		
		ABossManager_OnVolumeEndOverlap_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.OnVolumeBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABossManager::OnVolumeBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.OnVolumeBeginOverlap");
		
		ABossManager_OnVolumeBeginOverlap_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.OnRep_BossActive
	 * 		Flags  -> ()
	 */
	void ABossManager::OnRep_BossActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.OnRep_BossActive");
		
		ABossManager_OnRep_BossActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.OnPhotoModePreEntered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABossManager::OnPhotoModePreEntered(class APlayerController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.OnPhotoModePreEntered");
		
		ABossManager_OnPhotoModePreEntered_Params params {};
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.OnPhotoModeExited
	 * 		Flags  -> ()
	 */
	void ABossManager::OnPhotoModeExited()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.OnPhotoModeExited");
		
		ABossManager_OnPhotoModeExited_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.OnPhaseChangeBP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewPhase                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABossManager::OnPhaseChangeBP(int32_t NewPhase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.OnPhaseChangeBP");
		
		ABossManager_OnPhaseChangeBP_Params params {};
		params.NewPhase = NewPhase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.OnPhaseChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewPhase                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABossManager::OnPhaseChange(int32_t NewPhase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.OnPhaseChange");
		
		ABossManager_OnPhaseChange_Params params {};
		params.NewPhase = NewPhase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.OnEncounterSpawnKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ActorDamageSource                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABossManager::OnEncounterSpawnKilled(class AActor* ActorDamageSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.OnEncounterSpawnKilled");
		
		ABossManager_OnEncounterSpawnKilled_Params params {};
		params.ActorDamageSource = ActorDamageSource;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.OnEncounterComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      DamageSource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABossManager::OnEncounterComplete(class AActor* DamageSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.OnEncounterComplete");
		
		ABossManager_OnEncounterComplete_Params params {};
		params.DamageSource = DamageSource;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.OnDeactivated
	 * 		Flags  -> ()
	 */
	void ABossManager::OnDeactivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.OnDeactivated");
		
		ABossManager_OnDeactivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.OnActivated
	 * 		Flags  -> ()
	 */
	void ABossManager::OnActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.OnActivated");
		
		ABossManager_OnActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.IsPlayerInside
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalPlayerCharacter*                    PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ABossManager::IsPlayerInside(class ASurvivalPlayerCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.IsPlayerInside");
		
		ABossManager_IsPlayerInside_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.IsActive
	 * 		Flags  -> ()
	 */
	bool ABossManager::IsActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.IsActive");
		
		ABossManager_IsActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.GetEncounterMobs
	 * 		Flags  -> ()
	 */
	int32_t ABossManager::GetEncounterMobs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.GetEncounterMobs");
		
		ABossManager_GetEncounterMobs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.DeactivateBossEncounter
	 * 		Flags  -> ()
	 */
	void ABossManager::DeactivateBossEncounter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.DeactivateBossEncounter");
		
		ABossManager_DeactivateBossEncounter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BossManager.ActivateBossEncounter
	 * 		Flags  -> ()
	 */
	void ABossManager::ActivateBossEncounter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BossManager.ActivateBossEncounter");
		
		ABossManager_ActivateBossEncounter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABossManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABossManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BossManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameButtonWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameButtonWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GameButtonWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BottomButtonWidget.SetIsValid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBottomButtonWidget::SetIsValid(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BottomButtonWidget.SetIsValid");
		
		UBottomButtonWidget_SetIsValid_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BottomButtonWidget.OnSetIsValid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBottomButtonWidget::OnSetIsValid(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BottomButtonWidget.OnSetIsValid");
		
		UBottomButtonWidget_OnSetIsValid_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBottomButtonWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBottomButtonWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BottomButtonWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BreadcrumbManagerComponent.GetCurrentTimestamp
	 * 		Flags  -> ()
	 */
	float UBreadcrumbManagerComponent::GetCurrentTimestamp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BreadcrumbManagerComponent.GetCurrentTimestamp");
		
		UBreadcrumbManagerComponent_GetCurrentTimestamp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBreadcrumbManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBreadcrumbManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BreadcrumbManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBreathePointComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBreathePointComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BreathePointComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_AttackRequiresFacing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_AttackRequiresFacing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_AttackRequiresFacing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_CanFly.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_CanFly::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_CanFly");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_InAttackRange.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_InAttackRange::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_InAttackRange");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_IsActivePet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_IsActivePet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_IsActivePet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_IsBaited.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_IsBaited::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_IsBaited");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_IsClimbable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_IsClimbable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_IsClimbable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_IsClimbingFoliage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_IsClimbingFoliage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_IsClimbingFoliage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_IsMovementMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_IsMovementMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_IsMovementMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_IsPetHappiness.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_IsPetHappiness::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_IsPetHappiness");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_IsSoundDetectState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_IsSoundDetectState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_IsSoundDetectState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_IsStaticObstacle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_IsStaticObstacle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_IsStaticObstacle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_IsStationary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_IsStationary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_IsStationary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_IsSwimmingCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_IsSwimmingCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_IsSwimmingCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_IsTameState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_IsTameState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_IsTameState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_IsVitalValue.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_IsVitalValue::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_IsVitalValue");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_Random.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_Random::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_Random");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_ShouldCombatStrafe.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_ShouldCombatStrafe::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_ShouldCombatStrafe");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_ShouldPlayFidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_ShouldPlayFidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_ShouldPlayFidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_UsesPathFollower.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_UsesPathFollower::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_UsesPathFollower");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_UsesSwimSteeringBehavior.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_UsesSwimSteeringBehavior::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_UsesSwimSteeringBehavior");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_WaitOnWander.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_WaitOnWander::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTDecorator_WaitOnWander");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTService_GameplayFocus.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTService_GameplayFocus::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTService_GameplayFocus");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTService_PerceptionMultiplier.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTService_PerceptionMultiplier::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTService_PerceptionMultiplier");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTService_UpdateCombatState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTService_UpdateCombatState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTService_UpdateCombatState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_ActivePetWait.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_ActivePetWait::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_ActivePetWait");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_AdvanceWave.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_AdvanceWave::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_AdvanceWave");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_Attack.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_Attack::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_Attack");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_Burrow.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_Burrow::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_Burrow");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_ClearNewPetState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_ClearNewPetState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_ClearNewPetState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_ClimbSpline.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_ClimbSpline::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_ClimbSpline");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_MaineMoveTo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_MaineMoveTo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_MaineMoveTo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_CombatMoveTo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_CombatMoveTo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_CombatMoveTo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_Disabled.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_Disabled::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_Disabled");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_Emerge.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_Emerge::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_Emerge");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_FindTransitionLocation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_FindTransitionLocation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_FindTransitionLocation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_GetFoliageKeyLocation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_GetFoliageKeyLocation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_GetFoliageKeyLocation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_MaineRunEQSQuery.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_MaineRunEQSQuery::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_MaineRunEQSQuery");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_MarkInterestUnreachable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_MarkInterestUnreachable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_MarkInterestUnreachable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_NoOp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_NoOp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_NoOp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_PlayEmote.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_PlayEmote::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_PlayEmote");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_PlayFidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_PlayFidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_PlayFidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_Rest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_Rest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_Rest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_RotateToAlignBBEntry.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_RotateToAlignBBEntry::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_RotateToAlignBBEntry");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_RunPreActionCombatAnim.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_RunPreActionCombatAnim::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_RunPreActionCombatAnim");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_SelectCombatAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_SelectCombatAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_SelectCombatAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_SetAttachmentPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_SetAttachmentPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_SetAttachmentPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_SetBlackboardFloat.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_SetBlackboardFloat::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_SetBlackboardFloat");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_SetInvestigateLocation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_SetInvestigateLocation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_SetInvestigateLocation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_SetRandomDestination.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_SetRandomDestination::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_SetRandomDestination");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_SetSoundDetectState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_SetSoundDetectState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_SetSoundDetectState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_SetTargetActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_SetTargetActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_SetTargetActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_SetTargetInteractable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_SetTargetInteractable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_SetTargetInteractable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_SetTargetToPetMaster.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_SetTargetToPetMaster::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_SetTargetToPetMaster");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_SetWaveDestination.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_SetWaveDestination::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_SetWaveDestination");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_StartClimbing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_StartClimbing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_StartClimbing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_SteeringTargeted.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_SteeringTargeted::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_SteeringTargeted");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_SteeringWander.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_SteeringWander::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_SteeringWander");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_StopClimbing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_StopClimbing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_StopClimbing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_StopPhysMovement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_StopPhysMovement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_StopPhysMovement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_ToggleFlying.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_ToggleFlying::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_ToggleFlying");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_ToggleResting.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_ToggleResting::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_ToggleResting");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_UseInteractable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_UseInteractable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_UseInteractable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_UseWaypoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_UseWaypoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_UseWaypoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_WanderToTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_WanderToTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BTTask_WanderToTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.UsesCrenellation
	 * 		Flags  -> ()
	 */
	bool ABuilding::UsesCrenellation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.UsesCrenellation");
		
		ABuilding_UsesCrenellation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.Use
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::Use(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.Use");
		
		ABuilding_Use_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.UpdateCollisionStateChange
	 * 		Flags  -> ()
	 */
	void ABuilding::UpdateCollisionStateChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.UpdateCollisionStateChange");
		
		ABuilding_UpdateCollisionStateChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.UpdateAllMaterials
	 * 		Flags  -> ()
	 */
	void ABuilding::UpdateAllMaterials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.UpdateAllMaterials");
		
		ABuilding_UpdateAllMaterials_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.UnsetPlacedThisFrame
	 * 		Flags  -> ()
	 */
	void ABuilding::UnsetPlacedThisFrame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.UnsetPlacedThisFrame");
		
		ABuilding_UnsetPlacedThisFrame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.TransformSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBuildingGridComponent*                      Grid                                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridKey                            Slot                                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FBuildingGridKey ABuilding::TransformSlot(class UBuildingGridComponent* Grid, const struct FBuildingGridKey& Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.TransformSlot");
		
		ABuilding_TransformSlot_Params params {};
		params.Grid = Grid;
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.TickDebugDraw
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::TickDebugDraw(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.TickDebugDraw");
		
		ABuilding_TickDebugDraw_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.TickCancelled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::TickCancelled(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.TickCancelled");
		
		ABuilding_TickCancelled_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.StartPlacementMode
	 * 		Flags  -> ()
	 */
	void ABuilding::StartPlacementMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.StartPlacementMode");
		
		ABuilding_StartPlacementMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.SetUnderConstruction
	 * 		Flags  -> ()
	 */
	void ABuilding::SetUnderConstruction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.SetUnderConstruction");
		
		ABuilding_SetUnderConstruction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.SetStencilOnBuildingStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InInstigator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBuildingState                                     NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::SetStencilOnBuildingStateChanged(class AActor* InInstigator, EBuildingState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.SetStencilOnBuildingStateChanged");
		
		ABuilding_SetStencilOnBuildingStateChanged_Params params {};
		params.InInstigator = InInstigator;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.SetHUDMarkerVariant
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Variant                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::SetHUDMarkerVariant(int32_t Variant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.SetHUDMarkerVariant");
		
		ABuilding_SetHUDMarkerVariant_Params params {};
		params.Variant = Variant;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.SetHUDMarkerColorVariant
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Variant                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::SetHUDMarkerColorVariant(int32_t Variant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.SetHUDMarkerColorVariant");
		
		ABuilding_SetHUDMarkerColorVariant_Params params {};
		params.Variant = Variant;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.ServerStartPlacementMode
	 * 		Flags  -> ()
	 */
	void ABuilding::ServerStartPlacementMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.ServerStartPlacementMode");
		
		ABuilding_ServerStartPlacementMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.ServerLightFireInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::ServerLightFireInteract(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.ServerLightFireInteract");
		
		ABuilding_ServerLightFireInteract_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.ServerInteractHold
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::ServerInteractHold(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.ServerInteractHold");
		
		ABuilding_ServerInteractHold_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.ServerInteractCancel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::ServerInteractCancel(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.ServerInteractCancel");
		
		ABuilding_ServerInteractCancel_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.ServerInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::ServerInteract(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.ServerInteract");
		
		ABuilding_ServerInteract_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.ServerDropInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::ServerDropInteract(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.ServerDropInteract");
		
		ABuilding_ServerDropInteract_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.ServerDemolish
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::ServerDemolish(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.ServerDemolish");
		
		ABuilding_ServerDemolish_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.ServerBeginRelocate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::ServerBeginRelocate(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.ServerBeginRelocate");
		
		ABuilding_ServerBeginRelocate_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.SelfComponentEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::SelfComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.SelfComponentEndOverlap");
		
		ABuilding_SelfComponentEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.SelfComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ABuilding::SelfComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.SelfComponentBeginOverlap");
		
		ABuilding_SelfComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.RegisterBuildingChangedCallbacks
	 * 		Flags  -> ()
	 */
	void ABuilding::RegisterBuildingChangedCallbacks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.RegisterBuildingChangedCallbacks");
		
		ABuilding_RegisterBuildingChangedCallbacks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.RegisterBuildingChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            Key                                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::RegisterBuildingChangedCallback(const struct FBuildingGridKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.RegisterBuildingChangedCallback");
		
		ABuilding_RegisterBuildingChangedCallback_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.PostRestoredFromInstance
	 * 		Flags  -> ()
	 */
	void ABuilding::PostRestoredFromInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.PostRestoredFromInstance");
		
		ABuilding_PostRestoredFromInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.PostRegisteredToGrid
	 * 		Flags  -> ()
	 */
	void ABuilding::PostRegisteredToGrid()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.PostRegisteredToGrid");
		
		ABuilding_PostRegisteredToGrid_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnWaveStarted
	 * 		Flags  -> ()
	 */
	void ABuilding::OnWaveStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnWaveStarted");
		
		ABuilding_OnWaveStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnWaveComplete
	 * 		Flags  -> ()
	 */
	void ABuilding::OnWaveComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnWaveComplete");
		
		ABuilding_OnWaveComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnRep_ReplicatedData
	 * 		Flags  -> ()
	 */
	void ABuilding::OnRep_ReplicatedData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnRep_ReplicatedData");
		
		ABuilding_OnRep_ReplicatedData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnRep_NetworkPower
	 * 		Flags  -> ()
	 */
	void ABuilding::OnRep_NetworkPower()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnRep_NetworkPower");
		
		ABuilding_OnRep_NetworkPower_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnRep_Items
	 * 		Flags  -> ()
	 */
	void ABuilding::OnRep_Items()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnRep_Items");
		
		ABuilding_OnRep_Items_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnRep_IsLitWithFireChanged
	 * 		Flags  -> ()
	 */
	void ABuilding::OnRep_IsLitWithFireChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnRep_IsLitWithFireChanged");
		
		ABuilding_OnRep_IsLitWithFireChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnRep_BuildingStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EBuildingState                                     OldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::OnRep_BuildingStateChanged(EBuildingState OldState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnRep_BuildingStateChanged");
		
		ABuilding_OnRep_BuildingStateChanged_Params params {};
		params.OldState = OldState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnPowerSwitchOpenCloseStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsOpen                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InInstigator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::OnPowerSwitchOpenCloseStateChanged(bool bIsOpen, class AActor* InInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnPowerSwitchOpenCloseStateChanged");
		
		ABuilding_OnPowerSwitchOpenCloseStateChanged_Params params {};
		params.bIsOpen = bIsOpen;
		params.InInstigator = InInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnPlayerPossessed
	 * 		Flags  -> ()
	 */
	void ABuilding::OnPlayerPossessed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnPlayerPossessed");
		
		ABuilding_OnPlayerPossessed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnPlayerEquipmentChanged
	 * 		Flags  -> ()
	 */
	void ABuilding::OnPlayerEquipmentChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnPlayerEquipmentChanged");
		
		ABuilding_OnPlayerEquipmentChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnNetworkPowerChangedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Power                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::OnNetworkPowerChangedEvent(float Power)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnNetworkPowerChangedEvent");
		
		ABuilding_OnNetworkPowerChangedEvent_Params params {};
		params.Power = Power;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnNetworkPowerChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NetworkId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Power                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::OnNetworkPowerChanged(int32_t NetworkId, float Power)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnNetworkPowerChanged");
		
		ABuilding_OnNetworkPowerChanged_Params params {};
		params.NetworkId = NetworkId;
		params.Power = Power;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnFragilityLevelChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            CurrentFragilityLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::OnFragilityLevelChanged(int32_t CurrentFragilityLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnFragilityLevelChanged");
		
		ABuilding_OnFragilityLevelChanged_Params params {};
		params.CurrentFragilityLevel = CurrentFragilityLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnBuildingIsFragileChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHealthComponent*                            Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsFragile                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::OnBuildingIsFragileChanged(class UHealthComponent* Sender, bool bIsFragile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnBuildingIsFragileChanged");
		
		ABuilding_OnBuildingIsFragileChanged_Params params {};
		params.Sender = Sender;
		params.bIsFragile = bIsFragile;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnBuildingHealthChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHealthComponent*                            SourceHealthComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OldHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::OnBuildingHealthChanged(class UHealthComponent* SourceHealthComponent, float NewHealth, float OldHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnBuildingHealthChanged");
		
		ABuilding_OnBuildingHealthChanged_Params params {};
		params.SourceHealthComponent = SourceHealthComponent;
		params.NewHealth = NewHealth;
		params.OldHealth = OldHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnBuildingDestroyed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ABuilding::OnBuildingDestroyed(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnBuildingDestroyed");
		
		ABuilding_OnBuildingDestroyed_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.OnBuildingDamaged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsKillingBlow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::OnBuildingDamaged(float Damage, const struct FDamageInfo& DamageInfo, class AController* InstigatedBy, class UBaseLODActor* DamageCauser, bool IsKillingBlow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.OnBuildingDamaged");
		
		ABuilding_OnBuildingDamaged_Params params {};
		params.Damage = Damage;
		params.DamageInfo = DamageInfo;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		params.IsKillingBlow = IsKillingBlow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.NotifyPendingBuildingMoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridLocation                       NewLocation                                                (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::NotifyPendingBuildingMoved(const struct FBuildingGridLocation& NewLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.NotifyPendingBuildingMoved");
		
		ABuilding_NotifyPendingBuildingMoved_Params params {};
		params.NewLocation = NewLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.NotifyBuildingChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridLocation                       Location                                                   (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::NotifyBuildingChanged(const struct FBuildingGridLocation& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.NotifyBuildingChanged");
		
		ABuilding_NotifyBuildingChanged_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.MulticastHandleDestroyed
	 * 		Flags  -> ()
	 */
	void ABuilding::MulticastHandleDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.MulticastHandleDestroyed");
		
		ABuilding_MulticastHandleDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.MulticastHandleDemolish
	 * 		Flags  -> ()
	 */
	void ABuilding::MulticastHandleDemolish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.MulticastHandleDemolish");
		
		ABuilding_MulticastHandleDemolish_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.MulticastHandleDeconstruction
	 * 		Flags  -> ()
	 */
	void ABuilding::MulticastHandleDeconstruction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.MulticastHandleDeconstruction");
		
		ABuilding_MulticastHandleDeconstruction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.MulticastHandleDamaged
	 * 		Flags  -> ()
	 */
	void ABuilding::MulticastHandleDamaged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.MulticastHandleDamaged");
		
		ABuilding_MulticastHandleDamaged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.MulticastHandleBuildingPlacement
	 * 		Flags  -> ()
	 */
	void ABuilding::MulticastHandleBuildingPlacement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.MulticastHandleBuildingPlacement");
		
		ABuilding_MulticastHandleBuildingPlacement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.MulticastHandleBuildingCompletedSFX
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::MulticastHandleBuildingCompletedSFX(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.MulticastHandleBuildingCompletedSFX");
		
		ABuilding_MulticastHandleBuildingCompletedSFX_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.MulticastBuildingMoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             AttachParent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  RelativeTransform                                          (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ABuilding::MulticastBuildingMoved(class USceneComponent* AttachParent, const struct FTransform& RelativeTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.MulticastBuildingMoved");
		
		ABuilding_MulticastBuildingMoved_Params params {};
		params.AttachParent = AttachParent;
		params.RelativeTransform = RelativeTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.K2_DrawDebugCells
	 * 		Flags  -> ()
	 */
	void ABuilding::K2_DrawDebugCells()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.K2_DrawDebugCells");
		
		ABuilding_K2_DrawDebugCells_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.IsUnderConstruction
	 * 		Flags  -> ()
	 */
	bool ABuilding::IsUnderConstruction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.IsUnderConstruction");
		
		ABuilding_IsUnderConstruction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.IsReplacementBuilding
	 * 		Flags  -> ()
	 */
	bool ABuilding::IsReplacementBuilding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.IsReplacementBuilding");
		
		ABuilding_IsReplacementBuilding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.IsPlaced
	 * 		Flags  -> ()
	 */
	bool ABuilding::IsPlaced()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.IsPlaced");
		
		ABuilding_IsPlaced_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.IsOverloaded
	 * 		Flags  -> ()
	 */
	bool ABuilding::IsOverloaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.IsOverloaded");
		
		ABuilding_IsOverloaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.IsBuilt
	 * 		Flags  -> ()
	 */
	bool ABuilding::IsBuilt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.IsBuilt");
		
		ABuilding_IsBuilt_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.IsBeingReplaced
	 * 		Flags  -> ()
	 */
	bool ABuilding::IsBeingReplaced()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.IsBeingReplaced");
		
		ABuilding_IsBeingReplaced_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.IsBeingPlacedLocal
	 * 		Flags  -> ()
	 */
	bool ABuilding::IsBeingPlacedLocal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.IsBeingPlacedLocal");
		
		ABuilding_IsBeingPlacedLocal_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.IsBeingPlaced
	 * 		Flags  -> ()
	 */
	bool ABuilding::IsBeingPlaced()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.IsBeingPlaced");
		
		ABuilding_IsBeingPlaced_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.InverseTransformSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBuildingGridComponent*                      Grid                                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridKey                            Slot                                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FBuildingGridKey ABuilding::InverseTransformSlot(class UBuildingGridComponent* Grid, const struct FBuildingGridKey& Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.InverseTransformSlot");
		
		ABuilding_InverseTransformSlot_Params params {};
		params.Grid = Grid;
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.HasTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                InTag                                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ABuilding::HasTag(const struct FGameplayTag& InTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.HasTag");
		
		ABuilding_HasTag_Params params {};
		params.InTag = InTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.HasParentGrid
	 * 		Flags  -> ()
	 */
	bool ABuilding::HasParentGrid()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.HasParentGrid");
		
		ABuilding_HasParentGrid_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.HasAnyTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTagContainer                       InTags                                                     (Parm, NativeAccessSpecifierPublic)
	 */
	bool ABuilding::HasAnyTag(const struct FGameplayTagContainer& InTags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.HasAnyTag");
		
		ABuilding_HasAnyTag_Params params {};
		params.InTags = InTags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.HandleFinishCollapseDestroy
	 * 		Flags  -> ()
	 */
	void ABuilding::HandleFinishCollapseDestroy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.HandleFinishCollapseDestroy");
		
		ABuilding_HandleFinishCollapseDestroy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetWeight
	 * 		Flags  -> ()
	 */
	float ABuilding::GetWeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetWeight");
		
		ABuilding_GetWeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetUseText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText ABuilding::GetUseText(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetUseText");
		
		ABuilding_GetUseText_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetUseInteractionType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EInteractionType ABuilding::GetUseInteractionType(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetUseInteractionType");
		
		ABuilding_GetUseInteractionType_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetUseFacingHelper
	 * 		Flags  -> ()
	 */
	bool ABuilding::GetUseFacingHelper()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetUseFacingHelper");
		
		ABuilding_GetUseFacingHelper_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetUseAnimType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EInteractAnimType ABuilding::GetUseAnimType(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetUseAnimType");
		
		ABuilding_GetUseAnimType_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetTotalBurnTimeHours
	 * 		Flags  -> ()
	 */
	float ABuilding::GetTotalBurnTimeHours()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetTotalBurnTimeHours");
		
		ABuilding_GetTotalBurnTimeHours_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetTeamComponent
	 * 		Flags  -> ()
	 */
	class UTeamComponent* ABuilding::GetTeamComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetTeamComponent");
		
		ABuilding_GetTeamComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetSupportedByCells
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridLocation                       At                                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> ABuilding::GetSupportedByCells(const struct FBuildingGridLocation& At)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetSupportedByCells");
		
		ABuilding_GetSupportedByCells_Params params {};
		params.At = At;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetSturdiness
	 * 		Flags  -> ()
	 */
	float ABuilding::GetSturdiness()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetSturdiness");
		
		ABuilding_GetSturdiness_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetSoftCells
	 * 		Flags  -> ()
	 */
	TArray<struct FBuildingGridKey> ABuilding::GetSoftCells()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetSoftCells");
		
		ABuilding_GetSoftCells_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetShouldShowHUDMarker
	 * 		Flags  -> ()
	 */
	bool ABuilding::GetShouldShowHUDMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetShouldShowHUDMarker");
		
		ABuilding_GetShouldShowHUDMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetReplacementBuilding
	 * 		Flags  -> ()
	 */
	class ABuilding* ABuilding::GetReplacementBuilding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetReplacementBuilding");
		
		ABuilding_GetReplacementBuilding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetRemainingRequirements
	 * 		Flags  -> ()
	 */
	TArray<struct FRecipeRequirements> ABuilding::GetRemainingRequirements()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetRemainingRequirements");
		
		ABuilding_GetRemainingRequirements_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetRecipeIngredientCountRequired
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         Ingredient                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t ABuilding::GetRecipeIngredientCountRequired(const struct FDataTableRowHandle& Ingredient)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetRecipeIngredientCountRequired");
		
		ABuilding_GetRecipeIngredientCountRequired_Params params {};
		params.Ingredient = Ingredient;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetRecipeIngredientCountRemaining
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         Ingredient                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t ABuilding::GetRecipeIngredientCountRemaining(const struct FDataTableRowHandle& Ingredient)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetRecipeIngredientCountRemaining");
		
		ABuilding_GetRecipeIngredientCountRemaining_Params params {};
		params.Ingredient = Ingredient;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetRecipeIngredientCountAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         Ingredient                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t ABuilding::GetRecipeIngredientCountAdded(const struct FDataTableRowHandle& Ingredient)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetRecipeIngredientCountAdded");
		
		ABuilding_GetRecipeIngredientCountAdded_Params params {};
		params.Ingredient = Ingredient;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetProvidesSupport
	 * 		Flags  -> ()
	 */
	bool ABuilding::GetProvidesSupport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetProvidesSupport");
		
		ABuilding_GetProvidesSupport_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetPlacementValid
	 * 		Flags  -> ()
	 */
	bool ABuilding::GetPlacementValid()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetPlacementValid");
		
		ABuilding_GetPlacementValid_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetParentGrid
	 * 		Flags  -> ()
	 */
	class UBuildingGridComponent* ABuilding::GetParentGrid()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetParentGrid");
		
		ABuilding_GetParentGrid_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetOverrideSnaps
	 * 		Flags  -> ()
	 */
	TArray<struct FIntVector> ABuilding::GetOverrideSnaps()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetOverrideSnaps");
		
		ABuilding_GetOverrideSnaps_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetObsidianIDComponent
	 * 		Flags  -> ()
	 */
	class UObsidianIDComponent* ABuilding::GetObsidianIDComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetObsidianIDComponent");
		
		ABuilding_GetObsidianIDComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetName
	 * 		Flags  -> ()
	 */
	class FString ABuilding::GetName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetName");
		
		ABuilding_GetName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetIsFoundation
	 * 		Flags  -> ()
	 */
	bool ABuilding::GetIsFoundation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetIsFoundation");
		
		ABuilding_GetIsFoundation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetIsAnchoredCompleteTransitive
	 * 		Flags  -> ()
	 */
	bool ABuilding::GetIsAnchoredCompleteTransitive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetIsAnchoredCompleteTransitive");
		
		ABuilding_GetIsAnchoredCompleteTransitive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetIsAnchor
	 * 		Flags  -> ()
	 */
	bool ABuilding::GetIsAnchor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetIsAnchor");
		
		ABuilding_GetIsAnchor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetHUDMarkerVariant
	 * 		Flags  -> ()
	 */
	int32_t ABuilding::GetHUDMarkerVariant()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetHUDMarkerVariant");
		
		ABuilding_GetHUDMarkerVariant_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetHUDMarkerType
	 * 		Flags  -> ()
	 */
	EHUDMarkerType ABuilding::GetHUDMarkerType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetHUDMarkerType");
		
		ABuilding_GetHUDMarkerType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetHUDMarkerColorVariant
	 * 		Flags  -> ()
	 */
	int32_t ABuilding::GetHUDMarkerColorVariant()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetHUDMarkerColorVariant");
		
		ABuilding_GetHUDMarkerColorVariant_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetHealthComponent
	 * 		Flags  -> ()
	 */
	class UHealthComponent* ABuilding::GetHealthComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetHealthComponent");
		
		ABuilding_GetHealthComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetGridShape
	 * 		Flags  -> ()
	 */
	class UBuildingShape* ABuilding::GetGridShape()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetGridShape");
		
		ABuilding_GetGridShape_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetGridOriginTransform
	 * 		Flags  -> ()
	 */
	struct FTransform ABuilding::GetGridOriginTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetGridOriginTransform");
		
		ABuilding_GetGridOriginTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetGridOriginOffset
	 * 		Flags  -> ()
	 */
	struct FVector ABuilding::GetGridOriginOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetGridOriginOffset");
		
		ABuilding_GetGridOriginOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetGridLocation
	 * 		Flags  -> ()
	 */
	struct FBuildingGridLocation ABuilding::GetGridLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetGridLocation");
		
		ABuilding_GetGridLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetGridKey
	 * 		Flags  -> ()
	 */
	struct FBuildingGridKey ABuilding::GetGridKey()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetGridKey");
		
		ABuilding_GetGridKey_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetGridBuildingId
	 * 		Flags  -> ()
	 */
	struct FBuildingGridBuildingId ABuilding::GetGridBuildingId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetGridBuildingId");
		
		ABuilding_GetGridBuildingId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetGeometricOriginOffset
	 * 		Flags  -> ()
	 */
	struct FVector ABuilding::GetGeometricOriginOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetGeometricOriginOffset");
		
		ABuilding_GetGeometricOriginOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetFlatFootprintAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridLocation                       At                                                         (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InActualWorldRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> ABuilding::GetFlatFootprintAt(const struct FBuildingGridLocation& At, float InActualWorldRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetFlatFootprintAt");
		
		ABuilding_GetFlatFootprintAt_Params params {};
		params.At = At;
		params.InActualWorldRotation = InActualWorldRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetFlatFootprint
	 * 		Flags  -> ()
	 */
	TArray<struct FBuildingGridKey> ABuilding::GetFlatFootprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetFlatFootprint");
		
		ABuilding_GetFlatFootprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetComboFootprintAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridLocation                       At                                                         (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InActualWorldRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> ABuilding::GetComboFootprintAt(const struct FBuildingGridLocation& At, float InActualWorldRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetComboFootprintAt");
		
		ABuilding_GetComboFootprintAt_Params params {};
		params.At = At;
		params.InActualWorldRotation = InActualWorldRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetComboFootprint
	 * 		Flags  -> ()
	 */
	TArray<struct FBuildingGridKey> ABuilding::GetComboFootprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetComboFootprint");
		
		ABuilding_GetComboFootprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetCollapseCount
	 * 		Flags  -> ()
	 */
	int32_t ABuilding::GetCollapseCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetCollapseCount");
		
		ABuilding_GetCollapseCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetCells
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              AngleZ                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EGetCellFlags                                      Flags                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> ABuilding::GetCells(float AngleZ, EGetCellFlags Flags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetCells");
		
		ABuilding_GetCells_Params params {};
		params.AngleZ = AngleZ;
		params.Flags = Flags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetCeilingFootprintAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridLocation                       At                                                         (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InActualWorldRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> ABuilding::GetCeilingFootprintAt(const struct FBuildingGridLocation& At, float InActualWorldRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetCeilingFootprintAt");
		
		ABuilding_GetCeilingFootprintAt_Params params {};
		params.At = At;
		params.InActualWorldRotation = InActualWorldRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetCeilingFootprint
	 * 		Flags  -> ()
	 */
	TArray<struct FBuildingGridKey> ABuilding::GetCeilingFootprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetCeilingFootprint");
		
		ABuilding_GetCeilingFootprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetBaseFootprintAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridLocation                       At                                                         (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InActualWorldRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> ABuilding::GetBaseFootprintAt(const struct FBuildingGridLocation& At, float InActualWorldRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetBaseFootprintAt");
		
		ABuilding_GetBaseFootprintAt_Params params {};
		params.At = At;
		params.InActualWorldRotation = InActualWorldRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetBaseFootprint
	 * 		Flags  -> ()
	 */
	TArray<struct FBuildingGridKey> ABuilding::GetBaseFootprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetBaseFootprint");
		
		ABuilding_GetBaseFootprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetAnchoredSurface
	 * 		Flags  -> ()
	 */
	EBuildingGridSurfaceType ABuilding::GetAnchoredSurface()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetAnchoredSurface");
		
		ABuilding_GetAnchoredSurface_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetAdjacentCells
	 * 		Flags  -> ()
	 */
	TArray<struct FBuildingGridKey> ABuilding::GetAdjacentCells()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetAdjacentCells");
		
		ABuilding_GetAdjacentCells_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.GetActualWorldRotation
	 * 		Flags  -> ()
	 */
	float ABuilding::GetActualWorldRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.GetActualWorldRotation");
		
		ABuilding_GetActualWorldRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.DropNewItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  AtTransform                                                (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               ThisActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::DropNewItem(const struct FDataTableRowHandle& ItemData, const struct FTransform& AtTransform, class UBaseLODActor* ThisActor, class UBaseLODActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.DropNewItem");
		
		ABuilding_DropNewItem_Params params {};
		params.ItemData = ItemData;
		params.AtTransform = AtTransform;
		params.ThisActor = ThisActor;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.DropItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  AtTransform                                                (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               ThisActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::DropItem(class UItem* Item, const struct FTransform& AtTransform, class UBaseLODActor* ThisActor, class UBaseLODActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.DropItem");
		
		ABuilding_DropItem_Params params {};
		params.Item = Item;
		params.AtTransform = AtTransform;
		params.ThisActor = ThisActor;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.DoesCompletionCauseOverload
	 * 		Flags  -> ()
	 */
	bool ABuilding::DoesCompletionCauseOverload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.DoesCompletionCauseOverload");
		
		ABuilding_DoesCompletionCauseOverload_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.CheckAdditionalPlacementRequirements
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridLocation                       At                                                         (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ABuilding::CheckAdditionalPlacementRequirements(const struct FBuildingGridLocation& At)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.CheckAdditionalPlacementRequirements");
		
		ABuilding_CheckAdditionalPlacementRequirements_Params params {};
		params.At = At;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.CanUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EInteractionState ABuilding::CanUse(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.CanUse");
		
		ABuilding_CanUse_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.CancelBuild
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::CancelBuild(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.CancelBuild");
		
		ABuilding_CancelBuild_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.CanBeRelocated
	 * 		Flags  -> ()
	 */
	EInteractionState ABuilding::CanBeRelocated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.CanBeRelocated");
		
		ABuilding_CanBeRelocated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.CanAddIngredients
	 * 		Flags  -> ()
	 */
	bool ABuilding::CanAddIngredients()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.CanAddIngredients");
		
		ABuilding_CanAddIngredients_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.CalculateRequiredItemCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRecipeRequirements                         Requirement                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t ABuilding::CalculateRequiredItemCount(const struct FRecipeRequirements& Requirement)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.CalculateRequiredItemCount");
		
		ABuilding_CalculateRequiredItemCount_Params params {};
		params.Requirement = Requirement;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.BuildingCreateDynamicMaterialInstance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMeshComponent*                              Target                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ElementIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMaterialInterface*                          SourceMaterial                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        OptionalName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UMaterialInstanceDynamic* ABuilding::BuildingCreateDynamicMaterialInstance(class UMeshComponent* Target, int32_t ElementIndex, class UMaterialInterface* SourceMaterial, const class FName& OptionalName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.BuildingCreateDynamicMaterialInstance");
		
		ABuilding_BuildingCreateDynamicMaterialInstance_Params params {};
		params.Target = Target;
		params.ElementIndex = ElementIndex;
		params.SourceMaterial = SourceMaterial;
		params.OptionalName = OptionalName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Building.BlueprintDropItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuilding::BlueprintDropItems(class UBaseLODActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Building.BlueprintDropItems");
		
		ABuilding_BlueprintDropItems_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Building");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingFunctionLibrary.GetBuildingDataFilterMatches
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBaseBuildingData                           BuildingData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      FilterText                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBuildingFunctionLibrary::GetBuildingDataFilterMatches(const struct FBaseBuildingData& BuildingData, const class FString& FilterText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingFunctionLibrary.GetBuildingDataFilterMatches");
		
		UBuildingFunctionLibrary_GetBuildingDataFilterMatches_Params params {};
		params.BuildingData = BuildingData;
		params.FilterText = FilterText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingFunctionLibrary.CoalesceSoftBuildingClass
	 * 		Flags  -> ()
	 */
	void UBuildingFunctionLibrary::CoalesceSoftBuildingClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingFunctionLibrary.CoalesceSoftBuildingClass");
		
		UBuildingFunctionLibrary_CoalesceSoftBuildingClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBuildingFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBuildingFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BuildingFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridBuildingIdLibrary.IsBuildingIdValid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridBuildingId                     ID                                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBuildingGridBuildingIdLibrary::IsBuildingIdValid(const struct FBuildingGridBuildingId& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridBuildingIdLibrary.IsBuildingIdValid");
		
		UBuildingGridBuildingIdLibrary_IsBuildingIdValid_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridBuildingIdLibrary.GetInvalidBuildingId
	 * 		Flags  -> ()
	 */
	struct FBuildingGridBuildingId UBuildingGridBuildingIdLibrary::GetInvalidBuildingId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridBuildingIdLibrary.GetInvalidBuildingId");
		
		UBuildingGridBuildingIdLibrary_GetInvalidBuildingId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridBuildingIdLibrary.GetGridForBuildingGridBuildingId
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridBuildingId                     BuildingGridBuildingId                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBuildingGridComponent* UBuildingGridBuildingIdLibrary::GetGridForBuildingGridBuildingId(const struct FBuildingGridBuildingId& BuildingGridBuildingId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridBuildingIdLibrary.GetGridForBuildingGridBuildingId");
		
		UBuildingGridBuildingIdLibrary_GetGridForBuildingGridBuildingId_Params params {};
		params.BuildingGridBuildingId = BuildingGridBuildingId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridBuildingIdLibrary.GetBuildingGridFromId
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridBuildingId                     ID                                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBuildingGridComponent* UBuildingGridBuildingIdLibrary::GetBuildingGridFromId(const struct FBuildingGridBuildingId& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridBuildingIdLibrary.GetBuildingGridFromId");
		
		UBuildingGridBuildingIdLibrary_GetBuildingGridFromId_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBuildingGridBuildingIdLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBuildingGridBuildingIdLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BuildingGridBuildingIdLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.WorldToGrid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EBuildingPlacementMode                             PlacementMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     WorldPosition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FIntVector UBuildingGridComponent::WorldToGrid(EBuildingPlacementMode PlacementMode, const struct FVector& WorldPosition, const struct FVector2D& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.WorldToGrid");
		
		UBuildingGridComponent_WorldToGrid_Params params {};
		params.PlacementMode = PlacementMode;
		params.WorldPosition = WorldPosition;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.SnapToBuildGrid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EBuildingPlacementMode                             PlacementMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     WorldPosition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform UBuildingGridComponent::SnapToBuildGrid(EBuildingPlacementMode PlacementMode, const struct FVector& WorldPosition, const struct FVector2D& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.SnapToBuildGrid");
		
		UBuildingGridComponent_SnapToBuildGrid_Params params {};
		params.PlacementMode = PlacementMode;
		params.WorldPosition = WorldPosition;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.RegisterChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            GridLocation                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABuilding*                                   Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBuildingGridComponent::RegisterChangedCallback(const struct FBuildingGridKey& GridLocation, class ABuilding* Building)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.RegisterChangedCallback");
		
		UBuildingGridComponent_RegisterChangedCallback_Params params {};
		params.GridLocation = GridLocation;
		params.Building = Building;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.OnRep_TimeSinceCreation
	 * 		Flags  -> ()
	 */
	void UBuildingGridComponent::OnRep_TimeSinceCreation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.OnRep_TimeSinceCreation");
		
		UBuildingGridComponent_OnRep_TimeSinceCreation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.OnRep_SurfaceType
	 * 		Flags  -> ()
	 */
	void UBuildingGridComponent::OnRep_SurfaceType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.OnRep_SurfaceType");
		
		UBuildingGridComponent_OnRep_SurfaceType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.OnRep_InstancedBuildings
	 * 		Flags  -> ()
	 */
	void UBuildingGridComponent::OnRep_InstancedBuildings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.OnRep_InstancedBuildings");
		
		UBuildingGridComponent_OnRep_InstancedBuildings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.LocalToWorld
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     LocalLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UBuildingGridComponent::LocalToWorld(const struct FVector& LocalLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.LocalToWorld");
		
		UBuildingGridComponent_LocalToWorld_Params params {};
		params.LocalLocation = LocalLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.LocalToGrid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EBuildingPlacementMode                             PlacementMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     LocalPosition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FIntVector UBuildingGridComponent::LocalToGrid(EBuildingPlacementMode PlacementMode, const struct FVector& LocalPosition, const struct FVector2D& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.LocalToGrid");
		
		UBuildingGridComponent_LocalToGrid_Params params {};
		params.PlacementMode = PlacementMode;
		params.LocalPosition = LocalPosition;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.KeyToWorldLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UBuildingGridComponent::KeyToWorldLocation(const struct FBuildingGridKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.KeyToWorldLocation");
		
		UBuildingGridComponent_KeyToWorldLocation_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.IsSnapOccupied
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FIntVector                                  Snap                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBuildingGridComponent::IsSnapOccupied(const struct FIntVector& Snap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.IsSnapOccupied");
		
		UBuildingGridComponent_IsSnapOccupied_Params params {};
		params.Snap = Snap;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.IsBlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            GridLocation                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBuildingGridComponent::IsBlocked(const struct FBuildingGridKey& GridLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.IsBlocked");
		
		UBuildingGridComponent_IsBlocked_Params params {};
		params.GridLocation = GridLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.HasOverlappingBuilding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            GridLocation                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABuilding*                                   Building                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BuildingWorldRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBuildingGridComponent::HasOverlappingBuilding(const struct FBuildingGridKey& GridLocation, class ABuilding* Building, float BuildingWorldRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.HasOverlappingBuilding");
		
		UBuildingGridComponent_HasOverlappingBuilding_Params params {};
		params.GridLocation = GridLocation;
		params.Building = Building;
		params.BuildingWorldRotation = BuildingWorldRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.HasBuildingPrecise
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            GridLocation                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBuildingGridComponent::HasBuildingPrecise(const struct FBuildingGridKey& GridLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.HasBuildingPrecise");
		
		UBuildingGridComponent_HasBuildingPrecise_Params params {};
		params.GridLocation = GridLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.HasBuildingAdjacent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            GridLocation                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABuilding*                                   Building                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BuildingWorldRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBuildingGridComponent::HasBuildingAdjacent(const struct FBuildingGridKey& GridLocation, class ABuilding* Building, float BuildingWorldRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.HasBuildingAdjacent");
		
		UBuildingGridComponent_HasBuildingAdjacent_Params params {};
		params.GridLocation = GridLocation;
		params.Building = Building;
		params.BuildingWorldRotation = BuildingWorldRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.HasBuilding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            GridLocation                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBuildingGridComponent::HasBuilding(const struct FBuildingGridKey& GridLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.HasBuilding");
		
		UBuildingGridComponent_HasBuilding_Params params {};
		params.GridLocation = GridLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GridToWorld
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FIntVector                                  Position                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     LocalOffset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform UBuildingGridComponent::GridToWorld(const struct FIntVector& Position, const struct FVector& LocalOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GridToWorld");
		
		UBuildingGridComponent_GridToWorld_Params params {};
		params.Position = Position;
		params.LocalOffset = LocalOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GridToLocal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FIntVector                                  Position                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UBuildingGridComponent::GridToLocal(const struct FIntVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GridToLocal");
		
		UBuildingGridComponent_GridToLocal_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetWallSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              WorldRotation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAllowDiagonal                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EBuildingGridSlot UBuildingGridComponent::GetWallSlot(float WorldRotation, bool bAllowDiagonal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetWallSlot");
		
		UBuildingGridComponent_GetWallSlot_Params params {};
		params.WorldRotation = WorldRotation;
		params.bAllowDiagonal = bAllowDiagonal;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetUseBuildingIntegrity
	 * 		Flags  -> ()
	 */
	bool UBuildingGridComponent::GetUseBuildingIntegrity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetUseBuildingIntegrity");
		
		UBuildingGridComponent_GetUseBuildingIntegrity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetSurfaceType
	 * 		Flags  -> ()
	 */
	EBuildingGridSurfaceType UBuildingGridComponent::GetSurfaceType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetSurfaceType");
		
		UBuildingGridComponent_GetSurfaceType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetSupportsSlots
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                                  RelativeTo                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridKey                            OriginSlot                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABuilding*                                   Building                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BuildingWorldRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> UBuildingGridComponent::GetSupportsSlots(const struct FTransform& RelativeTo, const struct FBuildingGridKey& OriginSlot, class ABuilding* Building, float BuildingWorldRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetSupportsSlots");
		
		UBuildingGridComponent_GetSupportsSlots_Params params {};
		params.RelativeTo = RelativeTo;
		params.OriginSlot = OriginSlot;
		params.Building = Building;
		params.BuildingWorldRotation = BuildingWorldRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetSupportedBySlots
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                                  RelativeTo                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridKey                            OriginSlot                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABuilding*                                   Building                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BuildingWorldRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> UBuildingGridComponent::GetSupportedBySlots(const struct FTransform& RelativeTo, const struct FBuildingGridKey& OriginSlot, class ABuilding* Building, float BuildingWorldRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetSupportedBySlots");
		
		UBuildingGridComponent_GetSupportedBySlots_Params params {};
		params.RelativeTo = RelativeTo;
		params.OriginSlot = OriginSlot;
		params.Building = Building;
		params.BuildingWorldRotation = BuildingWorldRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetSubdivisionOffset
	 * 		Flags  -> ()
	 */
	struct FVector UBuildingGridComponent::GetSubdivisionOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetSubdivisionOffset");
		
		UBuildingGridComponent_GetSubdivisionOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetSubdivisionCountZ
	 * 		Flags  -> ()
	 */
	int32_t UBuildingGridComponent::GetSubdivisionCountZ()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetSubdivisionCountZ");
		
		UBuildingGridComponent_GetSubdivisionCountZ_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetSubdivisionCountY
	 * 		Flags  -> ()
	 */
	int32_t UBuildingGridComponent::GetSubdivisionCountY()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetSubdivisionCountY");
		
		UBuildingGridComponent_GetSubdivisionCountY_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetSubdivisionCountX
	 * 		Flags  -> ()
	 */
	int32_t UBuildingGridComponent::GetSubdivisionCountX()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetSubdivisionCountX");
		
		UBuildingGridComponent_GetSubdivisionCountX_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetSubdivisionCount
	 * 		Flags  -> ()
	 */
	struct FIntVector UBuildingGridComponent::GetSubdivisionCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetSubdivisionCount");
		
		UBuildingGridComponent_GetSubdivisionCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetSubdividedBaseFootprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            OriginSlot                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABuilding*                                   Building                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BuildingWorldRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> UBuildingGridComponent::GetSubdividedBaseFootprint(const struct FBuildingGridKey& OriginSlot, class ABuilding* Building, float BuildingWorldRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetSubdividedBaseFootprint");
		
		UBuildingGridComponent_GetSubdividedBaseFootprint_Params params {};
		params.OriginSlot = OriginSlot;
		params.Building = Building;
		params.BuildingWorldRotation = BuildingWorldRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetSoftSlots
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                                  RelativeTo                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridKey                            OriginSlot                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABuilding*                                   Building                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BuildingWorldRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> UBuildingGridComponent::GetSoftSlots(const struct FTransform& RelativeTo, const struct FBuildingGridKey& OriginSlot, class ABuilding* Building, float BuildingWorldRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetSoftSlots");
		
		UBuildingGridComponent_GetSoftSlots_Params params {};
		params.RelativeTo = RelativeTo;
		params.OriginSlot = OriginSlot;
		params.Building = Building;
		params.BuildingWorldRotation = BuildingWorldRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetSnapOffset
	 * 		Flags  -> ()
	 */
	struct FVector UBuildingGridComponent::GetSnapOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetSnapOffset");
		
		UBuildingGridComponent_GetSnapOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetRawSubdivisions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            OriginSlot                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EGetCellFlags                                      Flags                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> UBuildingGridComponent::GetRawSubdivisions(const struct FBuildingGridKey& OriginSlot, EGetCellFlags Flags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetRawSubdivisions");
		
		UBuildingGridComponent_GetRawSubdivisions_Params params {};
		params.OriginSlot = OriginSlot;
		params.Flags = Flags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetMinCell
	 * 		Flags  -> ()
	 */
	struct FIntVector UBuildingGridComponent::GetMinCell()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetMinCell");
		
		UBuildingGridComponent_GetMinCell_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetMaxCell
	 * 		Flags  -> ()
	 */
	struct FIntVector UBuildingGridComponent::GetMaxCell()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetMaxCell");
		
		UBuildingGridComponent_GetMaxCell_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetFlatFootprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            OriginSlot                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABuilding*                                   Building                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BuildingWorldRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> UBuildingGridComponent::GetFlatFootprint(const struct FBuildingGridKey& OriginSlot, class ABuilding* Building, float BuildingWorldRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetFlatFootprint");
		
		UBuildingGridComponent_GetFlatFootprint_Params params {};
		params.OriginSlot = OriginSlot;
		params.Building = Building;
		params.BuildingWorldRotation = BuildingWorldRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetCollapseCountMulti
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bAllowDesignated                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UBuildingGridComponent::GetCollapseCountMulti(bool bAllowDesignated)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetCollapseCountMulti");
		
		UBuildingGridComponent_GetCollapseCountMulti_Params params {};
		params.bAllowDesignated = bAllowDesignated;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetCollapseCountAsync
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridBuildingId                     BuildingId                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UBuildingGridComponent::GetCollapseCountAsync(const struct FBuildingGridBuildingId& BuildingId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetCollapseCountAsync");
		
		UBuildingGridComponent_GetCollapseCountAsync_Params params {};
		params.BuildingId = BuildingId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetCollapseCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABuilding*                                   Building                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UBuildingGridComponent::GetCollapseCount(class ABuilding* Building)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetCollapseCount");
		
		UBuildingGridComponent_GetCollapseCount_Params params {};
		params.Building = Building;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetCellSize
	 * 		Flags  -> ()
	 */
	struct FVector UBuildingGridComponent::GetCellSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetCellSize");
		
		UBuildingGridComponent_GetCellSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetCellExtents
	 * 		Flags  -> ()
	 */
	struct FVector UBuildingGridComponent::GetCellExtents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetCellExtents");
		
		UBuildingGridComponent_GetCellExtents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.GetBaseCellSize
	 * 		Flags  -> ()
	 */
	struct FVector UBuildingGridComponent::GetBaseCellSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.GetBaseCellSize");
		
		UBuildingGridComponent_GetBaseCellSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridComponent.CheckDetachedDestroy
	 * 		Flags  -> ()
	 */
	void UBuildingGridComponent::CheckDetachedDestroy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridComponent.CheckDetachedDestroy");
		
		UBuildingGridComponent_CheckDetachedDestroy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBuildingGridComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBuildingGridComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BuildingGridComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridKeyLibrary.Subtract_BuildingGridKeyIntVector
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            A                                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FIntVector                                  B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FBuildingGridKey UBuildingGridKeyLibrary::Subtract_BuildingGridKeyIntVector(const struct FBuildingGridKey& A, const struct FIntVector& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridKeyLibrary.Subtract_BuildingGridKeyIntVector");
		
		UBuildingGridKeyLibrary_Subtract_BuildingGridKeyIntVector_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridKeyLibrary.Add_BuildingGridKeyIntVector
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            A                                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FIntVector                                  B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FBuildingGridKey UBuildingGridKeyLibrary::Add_BuildingGridKeyIntVector(const struct FBuildingGridKey& A, const struct FIntVector& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridKeyLibrary.Add_BuildingGridKeyIntVector");
		
		UBuildingGridKeyLibrary_Add_BuildingGridKeyIntVector_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBuildingGridKeyLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBuildingGridKeyLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BuildingGridKeyLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridLocationLibrary.Subtract_BuildingGridLocationIntVector
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridLocation                       A                                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FIntVector                                  B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FBuildingGridLocation UBuildingGridLocationLibrary::Subtract_BuildingGridLocationIntVector(const struct FBuildingGridLocation& A, const struct FIntVector& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridLocationLibrary.Subtract_BuildingGridLocationIntVector");
		
		UBuildingGridLocationLibrary_Subtract_BuildingGridLocationIntVector_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridLocationLibrary.IsEaveBlockedAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABuilding*                                   Building                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridLocation                       Location                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ByTag                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBuildingGridLocationLibrary::IsEaveBlockedAt(class ABuilding* Building, const struct FBuildingGridLocation& Location, const struct FGameplayTag& ByTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridLocationLibrary.IsEaveBlockedAt");
		
		UBuildingGridLocationLibrary_IsEaveBlockedAt_Params params {};
		params.Building = Building;
		params.Location = Location;
		params.ByTag = ByTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridLocationLibrary.IsCrenellationBlockedAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABuilding*                                   Building                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridLocation                       Location                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ActualWorldRotation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBuildingGridLocationLibrary::IsCrenellationBlockedAt(class ABuilding* Building, const struct FBuildingGridLocation& Location, float ActualWorldRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridLocationLibrary.IsCrenellationBlockedAt");
		
		UBuildingGridLocationLibrary_IsCrenellationBlockedAt_Params params {};
		params.Building = Building;
		params.Location = Location;
		params.ActualWorldRotation = ActualWorldRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridLocationLibrary.IsBuildingGridLocationValid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridLocation                       Location                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBuildingGridLocationLibrary::IsBuildingGridLocationValid(const struct FBuildingGridLocation& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridLocationLibrary.IsBuildingGridLocationValid");
		
		UBuildingGridLocationLibrary_IsBuildingGridLocationValid_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingGridLocationLibrary.Add_BuildingGridLocationIntVector
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridLocation                       A                                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FIntVector                                  B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FBuildingGridLocation UBuildingGridLocationLibrary::Add_BuildingGridLocationIntVector(const struct FBuildingGridLocation& A, const struct FIntVector& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingGridLocationLibrary.Add_BuildingGridLocationIntVector");
		
		UBuildingGridLocationLibrary_Add_BuildingGridLocationIntVector_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBuildingGridLocationLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBuildingGridLocationLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BuildingGridLocationLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingHealthWidget.ShowBar
	 * 		Flags  -> ()
	 */
	void UBuildingHealthWidget::ShowBar()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingHealthWidget.ShowBar");
		
		UBuildingHealthWidget_ShowBar_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingHealthWidget.HideBar
	 * 		Flags  -> ()
	 */
	void UBuildingHealthWidget::HideBar()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingHealthWidget.HideBar");
		
		UBuildingHealthWidget_HideBar_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingHealthWidget.GetHealthBarColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              HealthRatio                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLinearColor UBuildingHealthWidget::GetHealthBarColor(float HealthRatio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingHealthWidget.GetHealthBarColor");
		
		UBuildingHealthWidget_GetHealthBarColor_Params params {};
		params.HealthRatio = HealthRatio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingHealthWidget.GetFragileBarColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              FragileRatio                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLinearColor UBuildingHealthWidget::GetFragileBarColor(float FragileRatio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingHealthWidget.GetFragileBarColor");
		
		UBuildingHealthWidget_GetFragileBarColor_Params params {};
		params.FragileRatio = FragileRatio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBuildingHealthWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBuildingHealthWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BuildingHealthWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBuildingManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBuildingManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BuildingManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBuildingMaterialAssetUserData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBuildingMaterialAssetUserData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BuildingMaterialAssetUserData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.ServerSetRepeatPlacementMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bRepeatMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBuildingPlacementComponent::ServerSetRepeatPlacementMode(bool bRepeatMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.ServerSetRepeatPlacementMode");
		
		UBuildingPlacementComponent_ServerSetRepeatPlacementMode_Params params {};
		params.bRepeatMode = bRepeatMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.ServerSetPlacementRotation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InPendingRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InActualWorldRotationRadZ                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBuildingPlacementComponent::ServerSetPlacementRotation(float InPendingRotation, float InActualWorldRotationRadZ)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.ServerSetPlacementRotation");
		
		UBuildingPlacementComponent_ServerSetPlacementRotation_Params params {};
		params.InPendingRotation = InPendingRotation;
		params.InActualWorldRotationRadZ = InActualWorldRotationRadZ;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.ServerSetFlipPlacementMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFlipMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBuildingPlacementComponent::ServerSetFlipPlacementMode(bool bFlipMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.ServerSetFlipPlacementMode");
		
		UBuildingPlacementComponent_ServerSetFlipPlacementMode_Params params {};
		params.bFlipMode = bFlipMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.ServerSetAlternatePlacementMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bAlternateMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBuildingPlacementComponent::ServerSetAlternatePlacementMode(bool bAlternateMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.ServerSetAlternatePlacementMode");
		
		UBuildingPlacementComponent_ServerSetAlternatePlacementMode_Params params {};
		params.bAlternateMode = bAlternateMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.ServerHandleAcceptPlacement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InPendingRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InActualWorldRotationRadZ                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBuildingPlacementComponent::ServerHandleAcceptPlacement(float InPendingRotation, float InActualWorldRotationRadZ)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.ServerHandleAcceptPlacement");
		
		UBuildingPlacementComponent_ServerHandleAcceptPlacement_Params params {};
		params.InPendingRotation = InPendingRotation;
		params.InActualWorldRotationRadZ = InActualWorldRotationRadZ;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.ServerExitBuildingPlacement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBuildingPlacementComponent::ServerExitBuildingPlacement(bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.ServerExitBuildingPlacement");
		
		UBuildingPlacementComponent_ServerExitBuildingPlacement_Params params {};
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.ServerEnterPlaceBuildingMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         BuildingData                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EBuildingPlacementFlags                            Flags                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBuildingPlacementComponent::ServerEnterPlaceBuildingMode(const struct FDataTableRowHandle& BuildingData, EBuildingPlacementFlags Flags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.ServerEnterPlaceBuildingMode");
		
		UBuildingPlacementComponent_ServerEnterPlaceBuildingMode_Params params {};
		params.BuildingData = BuildingData;
		params.Flags = Flags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.OnRep_PendingRelocate
	 * 		Flags  -> ()
	 */
	void UBuildingPlacementComponent::OnRep_PendingRelocate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.OnRep_PendingRelocate");
		
		UBuildingPlacementComponent_OnRep_PendingRelocate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.OnRep_PendingBuilding
	 * 		Flags  -> ()
	 */
	void UBuildingPlacementComponent::OnRep_PendingBuilding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.OnRep_PendingBuilding");
		
		UBuildingPlacementComponent_OnRep_PendingBuilding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.OnRep_IsPlacingBuilding
	 * 		Flags  -> ()
	 */
	void UBuildingPlacementComponent::OnRep_IsPlacingBuilding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.OnRep_IsPlacingBuilding");
		
		UBuildingPlacementComponent_OnRep_IsPlacingBuilding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.MulticastHandleBuildingPlacementSuccessEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBuildingPlacementComponent::MulticastHandleBuildingPlacementSuccessEffects(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.MulticastHandleBuildingPlacementSuccessEffects");
		
		UBuildingPlacementComponent_MulticastHandleBuildingPlacementSuccessEffects_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.IsRelocatingBuilding
	 * 		Flags  -> ()
	 */
	bool UBuildingPlacementComponent::IsRelocatingBuilding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.IsRelocatingBuilding");
		
		UBuildingPlacementComponent_IsRelocatingBuilding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.IsPlacementModeValid
	 * 		Flags  -> ()
	 */
	bool UBuildingPlacementComponent::IsPlacementModeValid()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.IsPlacementModeValid");
		
		UBuildingPlacementComponent_IsPlacementModeValid_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.GetRepeatPlacementMode
	 * 		Flags  -> ()
	 */
	bool UBuildingPlacementComponent::GetRepeatPlacementMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.GetRepeatPlacementMode");
		
		UBuildingPlacementComponent_GetRepeatPlacementMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.GetPendingBuildingRowHandle
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UBuildingPlacementComponent::GetPendingBuildingRowHandle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.GetPendingBuildingRowHandle");
		
		UBuildingPlacementComponent_GetPendingBuildingRowHandle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.GetPendingBuildingHasUnlockedVariants
	 * 		Flags  -> ()
	 */
	bool UBuildingPlacementComponent::GetPendingBuildingHasUnlockedVariants()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.GetPendingBuildingHasUnlockedVariants");
		
		UBuildingPlacementComponent_GetPendingBuildingHasUnlockedVariants_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.GetPendingBuilding
	 * 		Flags  -> ()
	 */
	class ABuilding* UBuildingPlacementComponent::GetPendingBuilding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.GetPendingBuilding");
		
		UBuildingPlacementComponent_GetPendingBuilding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.GetIsPlacingBuilding
	 * 		Flags  -> ()
	 */
	bool UBuildingPlacementComponent::GetIsPlacingBuilding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.GetIsPlacingBuilding");
		
		UBuildingPlacementComponent_GetIsPlacingBuilding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.GetFlipPlacementMode
	 * 		Flags  -> ()
	 */
	bool UBuildingPlacementComponent::GetFlipPlacementMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.GetFlipPlacementMode");
		
		UBuildingPlacementComponent_GetFlipPlacementMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.GetCurrentPlacementHasFlipMode
	 * 		Flags  -> ()
	 */
	bool UBuildingPlacementComponent::GetCurrentPlacementHasFlipMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.GetCurrentPlacementHasFlipMode");
		
		UBuildingPlacementComponent_GetCurrentPlacementHasFlipMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.GetCurrentPlacementHasAlternativeMode
	 * 		Flags  -> ()
	 */
	bool UBuildingPlacementComponent::GetCurrentPlacementHasAlternativeMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.GetCurrentPlacementHasAlternativeMode");
		
		UBuildingPlacementComponent_GetCurrentPlacementHasAlternativeMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.GetCurrentPlacementErrorString
	 * 		Flags  -> ()
	 */
	class FString UBuildingPlacementComponent::GetCurrentPlacementErrorString()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.GetCurrentPlacementErrorString");
		
		UBuildingPlacementComponent_GetCurrentPlacementErrorString_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.GetCurrentPlacementError
	 * 		Flags  -> ()
	 */
	int32_t UBuildingPlacementComponent::GetCurrentPlacementError()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.GetCurrentPlacementError");
		
		UBuildingPlacementComponent_GetCurrentPlacementError_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.GetAlternatePlacementMode
	 * 		Flags  -> ()
	 */
	bool UBuildingPlacementComponent::GetAlternatePlacementMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.GetAlternatePlacementMode");
		
		UBuildingPlacementComponent_GetAlternatePlacementMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.ExitPlaceBuildingMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBuildingPlacementComponent::ExitPlaceBuildingMode(bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.ExitPlaceBuildingMode");
		
		UBuildingPlacementComponent_ExitPlaceBuildingMode_Params params {};
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.EnterRelocateMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABuilding*                                   Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBuildingPlacementComponent::EnterRelocateMode(class ABuilding* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.EnterRelocateMode");
		
		UBuildingPlacementComponent_EnterRelocateMode_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.EnterPlaceBuildingMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         BuildingData                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bAutoAddIngredients                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDeployable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBuildingPlacementComponent::EnterPlaceBuildingMode(const struct FDataTableRowHandle& BuildingData, bool bAutoAddIngredients, bool bDeployable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.EnterPlaceBuildingMode");
		
		UBuildingPlacementComponent_EnterPlaceBuildingMode_Params params {};
		params.BuildingData = BuildingData;
		params.bAutoAddIngredients = bAutoAddIngredients;
		params.bDeployable = bDeployable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.ClientWarnRelocateCancelled
	 * 		Flags  -> ()
	 */
	void UBuildingPlacementComponent::ClientWarnRelocateCancelled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.ClientWarnRelocateCancelled");
		
		UBuildingPlacementComponent_ClientWarnRelocateCancelled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPlacementComponent.ClientEnterRelocateMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABuilding*                                   Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBuildingPlacementComponent::ClientEnterRelocateMode(class ABuilding* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPlacementComponent.ClientEnterRelocateMode");
		
		UBuildingPlacementComponent_ClientEnterRelocateMode_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBuildingPlacementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBuildingPlacementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BuildingPlacementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPowerCable.OnRep_StartEnd
	 * 		Flags  -> ()
	 */
	void ABuildingPowerCable::OnRep_StartEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPowerCable.OnRep_StartEnd");
		
		ABuildingPowerCable_OnRep_StartEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPowerCable.OnPoweredNetworksCoalesced
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            DestinationNetwork                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            RemovedNetwork                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuildingPowerCable::OnPoweredNetworksCoalesced(int32_t DestinationNetwork, int32_t RemovedNetwork)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPowerCable.OnPoweredNetworksCoalesced");
		
		ABuildingPowerCable_OnPoweredNetworksCoalesced_Params params {};
		params.DestinationNetwork = DestinationNetwork;
		params.RemovedNetwork = RemovedNetwork;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPowerCable.OnPoweredBuildingConnectionRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InNodeA                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InNodeB                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuildingPowerCable::OnPoweredBuildingConnectionRemoved(int32_t InNodeA, int32_t InNodeB)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPowerCable.OnPoweredBuildingConnectionRemoved");
		
		ABuildingPowerCable_OnPoweredBuildingConnectionRemoved_Params params {};
		params.InNodeA = InNodeA;
		params.InNodeB = InNodeB;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPowerCable.OnNodeRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NodeId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuildingPowerCable::OnNodeRemoved(int32_t NodeId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPowerCable.OnNodeRemoved");
		
		ABuildingPowerCable_OnNodeRemoved_Params params {};
		params.NodeId = NodeId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPowerCable.OnNodeChangedNetwork
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NodeId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewNetworkId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuildingPowerCable::OnNodeChangedNetwork(int32_t NodeId, int32_t NewNetworkId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPowerCable.OnNodeChangedNetwork");
		
		ABuildingPowerCable_OnNodeChangedNetwork_Params params {};
		params.NodeId = NodeId;
		params.NewNetworkId = NewNetworkId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingPowerCable.OnBuildingMoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingPowerId                            ID                                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ABuildingPowerCable::OnBuildingMoved(const struct FBuildingPowerId& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingPowerCable.OnBuildingMoved");
		
		ABuildingPowerCable_OnBuildingMoved_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABuildingPowerCable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABuildingPowerCable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BuildingPowerCable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingRecipeDataLibrary.GetBuildingRecipePrimaryMaterial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingRecipeData                         Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle UBuildingRecipeDataLibrary::GetBuildingRecipePrimaryMaterial(const struct FBuildingRecipeData& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingRecipeDataLibrary.GetBuildingRecipePrimaryMaterial");
		
		UBuildingRecipeDataLibrary_GetBuildingRecipePrimaryMaterial_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBuildingRecipeDataLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBuildingRecipeDataLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BuildingRecipeDataLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingShape.IsCell
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            Key                                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EGetCellFlags                                      Flags                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBuildingShape::IsCell(const struct FBuildingGridKey& Key, EGetCellFlags Flags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingShape.IsCell");
		
		UBuildingShape_IsCell_Params params {};
		params.Key = Key;
		params.Flags = Flags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingShape.GetSupportsOrSupportedByCells
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              AngleZ                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> UBuildingShape::GetSupportsOrSupportedByCells(float AngleZ)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingShape.GetSupportsOrSupportedByCells");
		
		UBuildingShape_GetSupportsOrSupportedByCells_Params params {};
		params.AngleZ = AngleZ;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingShape.GetSupportsCells
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              AngleZ                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> UBuildingShape::GetSupportsCells(float AngleZ)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingShape.GetSupportsCells");
		
		UBuildingShape_GetSupportsCells_Params params {};
		params.AngleZ = AngleZ;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingShape.GetSupportedByCells
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              AngleZ                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> UBuildingShape::GetSupportedByCells(float AngleZ)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingShape.GetSupportedByCells");
		
		UBuildingShape_GetSupportedByCells_Params params {};
		params.AngleZ = AngleZ;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingShape.GetSizeCellsGeometric
	 * 		Flags  -> ()
	 */
	struct FIntVector UBuildingShape::GetSizeCellsGeometric()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingShape.GetSizeCellsGeometric");
		
		UBuildingShape_GetSizeCellsGeometric_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingShape.GetSizeCells
	 * 		Flags  -> ()
	 */
	struct FIntVector UBuildingShape::GetSizeCells()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingShape.GetSizeCells");
		
		UBuildingShape_GetSizeCells_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingShape.GetCells
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              AngleZ                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EGetCellFlags                                      Flags                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FBuildingGridKey> UBuildingShape::GetCells(float AngleZ, EGetCellFlags Flags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingShape.GetCells");
		
		UBuildingShape_GetCells_Params params {};
		params.AngleZ = AngleZ;
		params.Flags = Flags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BuildingShape.GetAdjacentCells
	 * 		Flags  -> ()
	 */
	TArray<struct FBuildingGridKey> UBuildingShape::GetAdjacentCells()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BuildingShape.GetAdjacentCells");
		
		UBuildingShape_GetAdjacentCells_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBuildingShape.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBuildingShape::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BuildingShape");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABuoyantProp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABuoyantProp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BuoyantProp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestOptionActor.ReleaseByQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        Quest                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABurgleQuestOptionActor::ReleaseByQuest(class UBurgleQuestInstance* Quest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestOptionActor.ReleaseByQuest");
		
		ABurgleQuestOptionActor_ReleaseByQuest_Params params {};
		params.Quest = Quest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestOptionActor.OnStartQuest
	 * 		Flags  -> ()
	 */
	void ABurgleQuestOptionActor::OnStartQuest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestOptionActor.OnStartQuest");
		
		ABurgleQuestOptionActor_OnStartQuest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestOptionActor.OnEndQuest
	 * 		Flags  -> ()
	 */
	void ABurgleQuestOptionActor::OnEndQuest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestOptionActor.OnEndQuest");
		
		ABurgleQuestOptionActor_OnEndQuest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestOptionActor.NotifyStartQuest
	 * 		Flags  -> ()
	 */
	void ABurgleQuestOptionActor::NotifyStartQuest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestOptionActor.NotifyStartQuest");
		
		ABurgleQuestOptionActor_NotifyStartQuest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestOptionActor.NotifyEndQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bCompleted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABurgleQuestOptionActor::NotifyEndQuest(bool bCompleted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestOptionActor.NotifyEndQuest");
		
		ABurgleQuestOptionActor_NotifyEndQuest_Params params {};
		params.bCompleted = bCompleted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestOptionActor.IsAvailable
	 * 		Flags  -> ()
	 */
	bool ABurgleQuestOptionActor::IsAvailable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestOptionActor.IsAvailable");
		
		ABurgleQuestOptionActor_IsAvailable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestOptionActor.GetObsidianID
	 * 		Flags  -> ()
	 */
	class UObsidianIDComponent* ABurgleQuestOptionActor::GetObsidianID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestOptionActor.GetObsidianID");
		
		ABurgleQuestOptionActor_GetObsidianID_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestOptionActor.GetGuid
	 * 		Flags  -> ()
	 */
	struct FGuid ABurgleQuestOptionActor::GetGuid()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestOptionActor.GetGuid");
		
		ABurgleQuestOptionActor_GetGuid_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestOptionActor.ClaimByQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        Quest                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABurgleQuestOptionActor::ClaimByQuest(class UBurgleQuestInstance* Quest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestOptionActor.ClaimByQuest");
		
		ABurgleQuestOptionActor_ClaimByQuest_Params params {};
		params.Quest = Quest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABurgleQuestOptionActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABurgleQuestOptionActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestOptionActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestChipOptionActor.IsComplete
	 * 		Flags  -> ()
	 */
	bool ABurgleQuestChipOptionActor::IsComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestChipOptionActor.IsComplete");
		
		ABurgleQuestChipOptionActor_IsComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestChipOptionActor.GetChipItemType
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle ABurgleQuestChipOptionActor::GetChipItemType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestChipOptionActor.GetChipItemType");
		
		ABurgleQuestChipOptionActor_GetChipItemType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABurgleQuestChipOptionActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABurgleQuestChipOptionActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestChipOptionActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleQuestTemplate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleQuestTemplate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestTemplate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleQuestTemplateCoziness.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleQuestTemplateCoziness::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestTemplateCoziness");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.SetComplete
	 * 		Flags  -> ()
	 */
	void UBurgleQuestInstance::SetComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.SetComplete");
		
		UBurgleQuestInstance_SetComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.RemoveObjectiveMarkers
	 * 		Flags  -> ()
	 */
	void UBurgleQuestInstance::RemoveObjectiveMarkers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.RemoveObjectiveMarkers");
		
		UBurgleQuestInstance_RemoveObjectiveMarkers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.PerformComplete
	 * 		Flags  -> ()
	 */
	void UBurgleQuestInstance::PerformComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.PerformComplete");
		
		UBurgleQuestInstance_PerformComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.OnRep_Objectives
	 * 		Flags  -> ()
	 */
	void UBurgleQuestInstance::OnRep_Objectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.OnRep_Objectives");
		
		UBurgleQuestInstance_OnRep_Objectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.NotifyQuestStart
	 * 		Flags  -> ()
	 */
	void UBurgleQuestInstance::NotifyQuestStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.NotifyQuestStart");
		
		UBurgleQuestInstance_NotifyQuestStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.NotifyQuestComplete
	 * 		Flags  -> ()
	 */
	void UBurgleQuestInstance::NotifyQuestComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.NotifyQuestComplete");
		
		UBurgleQuestInstance_NotifyQuestComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.NotifyAbandonQuest
	 * 		Flags  -> ()
	 */
	void UBurgleQuestInstance::NotifyAbandonQuest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.NotifyAbandonQuest");
		
		UBurgleQuestInstance_NotifyAbandonQuest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.InitializeStarted
	 * 		Flags  -> ()
	 */
	void UBurgleQuestInstance::InitializeStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.InitializeStarted");
		
		UBurgleQuestInstance_InitializeStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.HasPerformedComplete
	 * 		Flags  -> ()
	 */
	bool UBurgleQuestInstance::HasPerformedComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.HasPerformedComplete");
		
		UBurgleQuestInstance_HasPerformedComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.GetTitle
	 * 		Flags  -> ()
	 */
	class FString UBurgleQuestInstance::GetTitle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.GetTitle");
		
		UBurgleQuestInstance_GetTitle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.GetTemplate
	 * 		Flags  -> ()
	 */
	class UBurgleQuestTemplate* UBurgleQuestInstance::GetTemplate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.GetTemplate");
		
		UBurgleQuestInstance_GetTemplate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.GetScienceReward
	 * 		Flags  -> ()
	 */
	int32_t UBurgleQuestInstance::GetScienceReward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.GetScienceReward");
		
		UBurgleQuestInstance_GetScienceReward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.GetObjectiveText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ObjectiveIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UBurgleQuestInstance::GetObjectiveText(int32_t ObjectiveIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.GetObjectiveText");
		
		UBurgleQuestInstance_GetObjectiveText_Params params {};
		params.ObjectiveIndex = ObjectiveIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.GetObjectiveAsSimple
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBurgleObjectiveSimple* UBurgleQuestInstance::GetObjectiveAsSimple(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.GetObjectiveAsSimple");
		
		UBurgleQuestInstance_GetObjectiveAsSimple_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.GetObjectiveAsProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBurgleObjectiveProgress* UBurgleQuestInstance::GetObjectiveAsProgress(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.GetObjectiveAsProgress");
		
		UBurgleQuestInstance_GetObjectiveAsProgress_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.GetObjective
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseBurgleObjective* UBurgleQuestInstance::GetObjective(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.GetObjective");
		
		UBurgleQuestInstance_GetObjective_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.GetGenerationFailed
	 * 		Flags  -> ()
	 */
	bool UBurgleQuestInstance::GetGenerationFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.GetGenerationFailed");
		
		UBurgleQuestInstance_GetGenerationFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.GetExternalScienceReward
	 * 		Flags  -> ()
	 */
	int32_t UBurgleQuestInstance::GetExternalScienceReward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.GetExternalScienceReward");
		
		UBurgleQuestInstance_GetExternalScienceReward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.GetDescriptionText
	 * 		Flags  -> ()
	 */
	class FString UBurgleQuestInstance::GetDescriptionText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.GetDescriptionText");
		
		UBurgleQuestInstance_GetDescriptionText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.GetCurrentObjective
	 * 		Flags  -> ()
	 */
	class UBaseBurgleObjective* UBurgleQuestInstance::GetCurrentObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.GetCurrentObjective");
		
		UBurgleQuestInstance_GetCurrentObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.GenerateParameters
	 * 		Flags  -> ()
	 */
	void UBurgleQuestInstance::GenerateParameters()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.GenerateParameters");
		
		UBurgleQuestInstance_GenerateParameters_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.FailGeneration
	 * 		Flags  -> ()
	 */
	void UBurgleQuestInstance::FailGeneration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.FailGeneration");
		
		UBurgleQuestInstance_FailGeneration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.CreateObjectiveMarkers
	 * 		Flags  -> ()
	 */
	void UBurgleQuestInstance::CreateObjectiveMarkers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.CreateObjectiveMarkers");
		
		UBurgleQuestInstance_CreateObjectiveMarkers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.CleanUpQuest
	 * 		Flags  -> ()
	 */
	void UBurgleQuestInstance::CleanUpQuest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.CleanUpQuest");
		
		UBurgleQuestInstance_CleanUpQuest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstance.AddObjective
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseBurgleObjective*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleQuestInstance::AddObjective(class UBaseBurgleObjective* Objective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstance.AddObjective");
		
		UBurgleQuestInstance_AddObjective_Params params {};
		params.Objective = Objective;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleQuestInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleQuestInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstanceCoziness.OnCozinessLevelAchieved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPartyComponent*                             Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewLevel                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleQuestInstanceCoziness::OnCozinessLevelAchieved(class UPartyComponent* Sender, int32_t NewLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstanceCoziness.OnCozinessLevelAchieved");
		
		UBurgleQuestInstanceCoziness_OnCozinessLevelAchieved_Params params {};
		params.Sender = Sender;
		params.NewLevel = NewLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleQuestInstanceCoziness.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleQuestInstanceCoziness::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestInstanceCoziness");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestFunctionLibrary.LogBurgleQuestWarning
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleQuestFunctionLibrary::LogBurgleQuestWarning(const class FString& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestFunctionLibrary.LogBurgleQuestWarning");
		
		UBurgleQuestFunctionLibrary_LogBurgleQuestWarning_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestFunctionLibrary.LogBurgleQuestLog
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleQuestFunctionLibrary::LogBurgleQuestLog(const class FString& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestFunctionLibrary.LogBurgleQuestLog");
		
		UBurgleQuestFunctionLibrary_LogBurgleQuestLog_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestFunctionLibrary.LogBurgleQuestError
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleQuestFunctionLibrary::LogBurgleQuestError(const class FString& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestFunctionLibrary.LogBurgleQuestError");
		
		UBurgleQuestFunctionLibrary_LogBurgleQuestError_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestFunctionLibrary.IsBurgleQuestProgressAtLeast
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Progress                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBurgleQuestFunctionLibrary::IsBurgleQuestProgressAtLeast(class UObject* WorldContextObject, float Progress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestFunctionLibrary.IsBurgleQuestProgressAtLeast");
		
		UBurgleQuestFunctionLibrary_IsBurgleQuestProgressAtLeast_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Progress = Progress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestFunctionLibrary.GetRandomQuestOption
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                Tag                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ABurgleQuestOptionActor* UBurgleQuestFunctionLibrary::GetRandomQuestOption(class UObject* WorldContextObject, const struct FGameplayTag& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestFunctionLibrary.GetRandomQuestOption");
		
		UBurgleQuestFunctionLibrary_GetRandomQuestOption_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestFunctionLibrary.CreateBurgleQuestSimpleObjective
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        ParentQuest                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ObjectiveIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBurgleObjectiveSimple* UBurgleQuestFunctionLibrary::CreateBurgleQuestSimpleObjective(class UBurgleQuestInstance* ParentQuest, int32_t ObjectiveIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestFunctionLibrary.CreateBurgleQuestSimpleObjective");
		
		UBurgleQuestFunctionLibrary_CreateBurgleQuestSimpleObjective_Params params {};
		params.ParentQuest = ParentQuest;
		params.ObjectiveIndex = ObjectiveIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestFunctionLibrary.CreateBurgleQuestProgressObjective
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        ParentQuest                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ObjectiveIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxProgress                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBurgleObjectiveProgress* UBurgleQuestFunctionLibrary::CreateBurgleQuestProgressObjective(class UBurgleQuestInstance* ParentQuest, int32_t ObjectiveIndex, int32_t MaxProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestFunctionLibrary.CreateBurgleQuestProgressObjective");
		
		UBurgleQuestFunctionLibrary_CreateBurgleQuestProgressObjective_Params params {};
		params.ParentQuest = ParentQuest;
		params.ObjectiveIndex = ObjectiveIndex;
		params.MaxProgress = MaxProgress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestFunctionLibrary.CalculateBurgleQuestTargetCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FFloatRange                                 AvailableProgressRange                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MinCount                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxCount                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxCountAt                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UBurgleQuestFunctionLibrary::CalculateBurgleQuestTargetCount(class UObject* WorldContextObject, const struct FFloatRange& AvailableProgressRange, int32_t MinCount, int32_t MaxCount, float MaxCountAt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestFunctionLibrary.CalculateBurgleQuestTargetCount");
		
		UBurgleQuestFunctionLibrary_CalculateBurgleQuestTargetCount_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.AvailableProgressRange = AvailableProgressRange;
		params.MinCount = MinCount;
		params.MaxCount = MaxCount;
		params.MaxCountAt = MaxCountAt;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleQuestFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleQuestFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleQuestInstanceSingleOptAct.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleQuestInstanceSingleOptAct::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestInstanceSingleOptAct");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleQuestInstanceBurgleChip.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleQuestInstanceBurgleChip::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestInstanceBurgleChip");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleQuestInstanceMarkPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleQuestInstanceMarkPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestInstanceMarkPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleQuestInstanceSingleRow.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleQuestInstanceSingleRow::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestInstanceSingleRow");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestTemplateKillGroup.GetSciencePerKill
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                CreatureTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UBurgleQuestTemplateKillGroup::GetSciencePerKill(const struct FGameplayTag& CreatureTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestTemplateKillGroup.GetSciencePerKill");
		
		UBurgleQuestTemplateKillGroup_GetSciencePerKill_Params params {};
		params.CreatureTag = CreatureTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleQuestTemplateKillGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleQuestTemplateKillGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestTemplateKillGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestInstanceKillGroup.OnPartyCreatureKill
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Creature                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleQuestInstanceKillGroup::OnPartyCreatureKill(class ASurvivalCharacter* Creature, class ASurvivalPlayerState* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestInstanceKillGroup.OnPartyCreatureKill");
		
		UBurgleQuestInstanceKillGroup_OnPartyCreatureKill_Params params {};
		params.Creature = Creature;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleQuestInstanceKillGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleQuestInstanceKillGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestInstanceKillGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestKillUniqueOptionActor.IsComplete
	 * 		Flags  -> ()
	 */
	bool ABurgleQuestKillUniqueOptionActor::IsComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestKillUniqueOptionActor.IsComplete");
		
		ABurgleQuestKillUniqueOptionActor_IsComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestKillUniqueOptionActor.EncounterCompletedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InInstigator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABurgleQuestKillUniqueOptionActor::EncounterCompletedCallback(class AActor* InInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestKillUniqueOptionActor.EncounterCompletedCallback");
		
		ABurgleQuestKillUniqueOptionActor_EncounterCompletedCallback_Params params {};
		params.InInstigator = InInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABurgleQuestKillUniqueOptionActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABurgleQuestKillUniqueOptionActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestKillUniqueOptionActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.TryRequestRefillQuests
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalPlayerController*                   Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBurgleQuestManagerComponent::TryRequestRefillQuests(class ASurvivalPlayerController* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.TryRequestRefillQuests");
		
		UBurgleQuestManagerComponent_TryRequestRefillQuests_Params params {};
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.RejectQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        Quest                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleQuestManagerComponent::RejectQuest(class UBurgleQuestInstance* Quest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.RejectQuest");
		
		UBurgleQuestManagerComponent_RejectQuest_Params params {};
		params.Quest = Quest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.OnRep_AvailableQuests
	 * 		Flags  -> ()
	 */
	void UBurgleQuestManagerComponent::OnRep_AvailableQuests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.OnRep_AvailableQuests");
		
		UBurgleQuestManagerComponent_OnRep_AvailableQuests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.OnRep_ActiveQuests
	 * 		Flags  -> ()
	 */
	void UBurgleQuestManagerComponent::OnRep_ActiveQuests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.OnRep_ActiveQuests");
		
		UBurgleQuestManagerComponent_OnRep_ActiveQuests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.MulticastStartQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        Quest                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleQuestManagerComponent::MulticastStartQuest(class UBurgleQuestInstance* Quest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.MulticastStartQuest");
		
		UBurgleQuestManagerComponent_MulticastStartQuest_Params params {};
		params.Quest = Quest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.MulticastQuestsRefilled
	 * 		Flags  -> ()
	 */
	void UBurgleQuestManagerComponent::MulticastQuestsRefilled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.MulticastQuestsRefilled");
		
		UBurgleQuestManagerComponent_MulticastQuestsRefilled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.MulticastObjectiveUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        Quest                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseObjective*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleQuestManagerComponent::MulticastObjectiveUpdated(class UBurgleQuestInstance* Quest, class UBaseObjective* Objective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.MulticastObjectiveUpdated");
		
		UBurgleQuestManagerComponent_MulticastObjectiveUpdated_Params params {};
		params.Quest = Quest;
		params.Objective = Objective;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.MulticastCompleteQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        Quest                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleQuestManagerComponent::MulticastCompleteQuest(class UBurgleQuestInstance* Quest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.MulticastCompleteQuest");
		
		UBurgleQuestManagerComponent_MulticastCompleteQuest_Params params {};
		params.Quest = Quest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.GetProgressRating
	 * 		Flags  -> ()
	 */
	float UBurgleQuestManagerComponent::GetProgressRating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.GetProgressRating");
		
		UBurgleQuestManagerComponent_GetProgressRating_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.GetCompletedQuestCount
	 * 		Flags  -> ()
	 */
	int32_t UBurgleQuestManagerComponent::GetCompletedQuestCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.GetCompletedQuestCount");
		
		UBurgleQuestManagerComponent_GetCompletedQuestCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.GetAvailableQuests
	 * 		Flags  -> ()
	 */
	TArray<class UBurgleQuestInstance*> UBurgleQuestManagerComponent::GetAvailableQuests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.GetAvailableQuests");
		
		UBurgleQuestManagerComponent_GetAvailableQuests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.GetAllQuests
	 * 		Flags  -> ()
	 */
	TArray<class UBurgleQuestInstance*> UBurgleQuestManagerComponent::GetAllQuests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.GetAllQuests");
		
		UBurgleQuestManagerComponent_GetAllQuests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.GetActiveQuests
	 * 		Flags  -> ()
	 */
	TArray<class UBurgleQuestInstance*> UBurgleQuestManagerComponent::GetActiveQuests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.GetActiveQuests");
		
		UBurgleQuestManagerComponent_GetActiveQuests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.ForceRegenerateQuests
	 * 		Flags  -> ()
	 */
	void UBurgleQuestManagerComponent::ForceRegenerateQuests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.ForceRegenerateQuests");
		
		UBurgleQuestManagerComponent_ForceRegenerateQuests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.DebugSetCompletedQuestCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleQuestManagerComponent::DebugSetCompletedQuestCount(int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.DebugSetCompletedQuestCount");
		
		UBurgleQuestManagerComponent_DebugSetCompletedQuestCount_Params params {};
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.AcceptQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        Quest                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleQuestManagerComponent::AcceptQuest(class UBurgleQuestInstance* Quest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.AcceptQuest");
		
		UBurgleQuestManagerComponent_AcceptQuest_Params params {};
		params.Quest = Quest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleQuestManagerComponent.AbandonQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        Quest                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleQuestManagerComponent::AbandonQuest(class UBurgleQuestInstance* Quest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleQuestManagerComponent.AbandonQuest");
		
		UBurgleQuestManagerComponent_AbandonQuest_Params params {};
		params.Quest = Quest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleQuestManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleQuestManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseBurgleObjective.Initialize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        InParentQuest                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InObjectiveIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseBurgleObjective::Initialize(class UBurgleQuestInstance* InParentQuest, int32_t InObjectiveIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseBurgleObjective.Initialize");
		
		UBaseBurgleObjective_Initialize_Params params {};
		params.InParentQuest = InParentQuest;
		params.InObjectiveIndex = InObjectiveIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseBurgleObjective.GetObjectiveIndex
	 * 		Flags  -> ()
	 */
	int32_t UBaseBurgleObjective::GetObjectiveIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseBurgleObjective.GetObjectiveIndex");
		
		UBaseBurgleObjective_GetObjectiveIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BaseBurgleObjective.ActivateObjective
	 * 		Flags  -> ()
	 */
	void UBaseBurgleObjective::ActivateObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BaseBurgleObjective.ActivateObjective");
		
		UBaseBurgleObjective_ActivateObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseBurgleObjective.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseBurgleObjective::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BaseBurgleObjective");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleObjectiveSimple.CompleteObjective
	 * 		Flags  -> ()
	 */
	void UBurgleObjectiveSimple::CompleteObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleObjectiveSimple.CompleteObjective");
		
		UBurgleObjectiveSimple_CompleteObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleObjectiveSimple.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleObjectiveSimple::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleObjectiveSimple");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleObjectiveProgress.SetMaxProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InTarget                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleObjectiveProgress::SetMaxProgress(int32_t InTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleObjectiveProgress.SetMaxProgress");
		
		UBurgleObjectiveProgress_SetMaxProgress_Params params {};
		params.InTarget = InTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleObjectiveProgress.InitializeProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        InParentQuest                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InObjectiveIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InMaxProgress                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleObjectiveProgress::InitializeProgress(class UBurgleQuestInstance* InParentQuest, int32_t InObjectiveIndex, int32_t InMaxProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleObjectiveProgress.InitializeProgress");
		
		UBurgleObjectiveProgress_InitializeProgress_Params params {};
		params.InParentQuest = InParentQuest;
		params.InObjectiveIndex = InObjectiveIndex;
		params.InMaxProgress = InMaxProgress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleObjectiveProgress.GetProgress
	 * 		Flags  -> ()
	 */
	int32_t UBurgleObjectiveProgress::GetProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleObjectiveProgress.GetProgress");
		
		UBurgleObjectiveProgress_GetProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleObjectiveProgress.GetMaxProgress
	 * 		Flags  -> ()
	 */
	int32_t UBurgleObjectiveProgress::GetMaxProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleObjectiveProgress.GetMaxProgress");
		
		UBurgleObjectiveProgress_GetMaxProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurgleObjectiveProgress.AddProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Progress                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurgleObjectiveProgress::AddProgress(int32_t Progress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurgleObjectiveProgress.AddProgress");
		
		UBurgleObjectiveProgress_AddProgress_Params params {};
		params.Progress = Progress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleObjectiveProgress.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleObjectiveProgress::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleObjectiveProgress");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurgleQuestTemplateSingleOptAct.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurgleQuestTemplateSingleOptAct::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurgleQuestTemplateSingleOptAct");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CharacterAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurrowCharacterAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurrowCharacterAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurrowCharacterAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurrowComponent.UnBurrow
	 * 		Flags  -> ()
	 */
	void UBurrowComponent::UnBurrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurrowComponent.UnBurrow");
		
		UBurrowComponent_UnBurrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurrowComponent.OnRep_BurrowState
	 * 		Flags  -> ()
	 */
	void UBurrowComponent::OnRep_BurrowState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurrowComponent.OnRep_BurrowState");
		
		UBurrowComponent_OnRep_BurrowState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurrowComponent.OnDeath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UBurrowComponent::OnDeath(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurrowComponent.OnDeath");
		
		UBurrowComponent_OnDeath_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurrowComponent.OnDamaged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsKillingBlow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurrowComponent::OnDamaged(float Damage, const struct FDamageInfo& DamageInfo, class AController* InstigatedBy, class UBaseLODActor* DamageCauser, bool IsKillingBlow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurrowComponent.OnDamaged");
		
		UBurrowComponent_OnDamaged_Params params {};
		params.Damage = Damage;
		params.DamageInfo = DamageInfo;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		params.IsKillingBlow = IsKillingBlow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurrowComponent.OnCombatChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               InCombat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBurrowComponent::OnCombatChange(class ASurvivalCharacter* Character, bool InCombat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurrowComponent.OnCombatChange");
		
		UBurrowComponent_OnCombatChange_Params params {};
		params.Character = Character;
		params.InCombat = InCombat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurrowComponent.IsBurrowed
	 * 		Flags  -> ()
	 */
	bool UBurrowComponent::IsBurrowed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurrowComponent.IsBurrowed");
		
		UBurrowComponent_IsBurrowed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurrowComponent.GetBurrowState
	 * 		Flags  -> ()
	 */
	EBurrowState UBurrowComponent::GetBurrowState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurrowComponent.GetBurrowState");
		
		UBurrowComponent_GetBurrowState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurrowComponent.Burrow
	 * 		Flags  -> ()
	 */
	void UBurrowComponent::Burrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurrowComponent.Burrow");
		
		UBurrowComponent_Burrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurrowComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurrowComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurrowComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyBurrowComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyBurrowComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyBurrowComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBurrowLODComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBurrowLODComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurrowLODComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.UpdateCameraDisplayMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InBlendTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::UpdateCameraDisplayMode(float InBlendTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.UpdateCameraDisplayMode");
		
		ASurvivalCharacter_UpdateCameraDisplayMode_Params params {};
		params.InBlendTime = InBlendTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ToggleCrouch
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::ToggleCrouch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ToggleCrouch");
		
		ASurvivalCharacter_ToggleCrouch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.SetOverrideViewTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ViewTarget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FViewTargetTransitionParams                 Transition                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::SetOverrideViewTarget(class AActor* ViewTarget, const struct FViewTargetTransitionParams& Transition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.SetOverrideViewTarget");
		
		ASurvivalCharacter_SetOverrideViewTarget_Params params {};
		params.ViewTarget = ViewTarget;
		params.Transition = Transition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.SetInCutscene
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInCutscene                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::SetInCutscene(bool bInCutscene)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.SetInCutscene");
		
		ASurvivalCharacter_SetInCutscene_Params params {};
		params.bInCutscene = bInCutscene;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.SetCameraDisplayModeLocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Locked                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::SetCameraDisplayModeLocked(bool Locked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.SetCameraDisplayModeLocked");
		
		ASurvivalCharacter_SetCameraDisplayModeLocked_Params params {};
		params.Locked = Locked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.SetCameraDisplayMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECameraDisplayMode                                 DisplayMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InBlendTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::SetCameraDisplayMode(ECameraDisplayMode DisplayMode, float InBlendTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.SetCameraDisplayMode");
		
		ASurvivalCharacter_SetCameraDisplayMode_Params params {};
		params.DisplayMode = DisplayMode;
		params.InBlendTime = InBlendTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerTriggerAnimationInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimationInteractComponent*                 AnimationInteractComponent                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::ServerTriggerAnimationInteract(class UAnimationInteractComponent* AnimationInteractComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerTriggerAnimationInteract");
		
		ASurvivalCharacter_ServerTriggerAnimationInteract_Params params {};
		params.AnimationInteractComponent = AnimationInteractComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerToggleSprint
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::ServerToggleSprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerToggleSprint");
		
		ASurvivalCharacter_ServerToggleSprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerStopZiplining
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bLaunch                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::ServerStopZiplining(bool bLaunch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerStopZiplining");
		
		ASurvivalCharacter_ServerStopZiplining_Params params {};
		params.bLaunch = bLaunch;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerStopAnimMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::ServerStopAnimMontage(class UAnimMontage* AnimMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerStopAnimMontage");
		
		ASurvivalCharacter_ServerStopAnimMontage_Params params {};
		params.AnimMontage = AnimMontage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerStartSprint
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::ServerStartSprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerStartSprint");
		
		ASurvivalCharacter_ServerStartSprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerStartGlide
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::ServerStartGlide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerStartGlide");
		
		ASurvivalCharacter_ServerStartGlide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerStartBlock
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::ServerStartBlock()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerStartBlock");
		
		ASurvivalCharacter_ServerStartBlock_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerStartAttack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EAttackType                                        AttackType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::ServerStartAttack(EAttackType AttackType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerStartAttack");
		
		ASurvivalCharacter_ServerStartAttack_Params params {};
		params.AttackType = AttackType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerStartAbility
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            AbilityIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::ServerStartAbility(int32_t AbilityIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerStartAbility");
		
		ASurvivalCharacter_ServerStartAbility_Params params {};
		params.AbilityIndex = AbilityIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerSetDisplayMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECameraDisplayMode                                 DisplayMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::ServerSetDisplayMode(ECameraDisplayMode DisplayMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerSetDisplayMode");
		
		ASurvivalCharacter_ServerSetDisplayMode_Params params {};
		params.DisplayMode = DisplayMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerSetAutorun
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::ServerSetAutorun(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerSetAutorun");
		
		ASurvivalCharacter_ServerSetAutorun_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerPlayEmoteAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                EmoteTypeTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::ServerPlayEmoteAnim(const struct FGameplayTag& EmoteTypeTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerPlayEmoteAnim");
		
		ASurvivalCharacter_ServerPlayEmoteAnim_Params params {};
		params.EmoteTypeTag = EmoteTypeTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerPlayEmote
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         EmoteDataRowHandle                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::ServerPlayEmote(const struct FDataTableRowHandle& EmoteDataRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerPlayEmote");
		
		ASurvivalCharacter_ServerPlayEmote_Params params {};
		params.EmoteDataRowHandle = EmoteDataRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerPlayChatter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FChatterEventReference                      ChatterEvent                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Param1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Param2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::ServerPlayChatter(const struct FChatterEventReference& ChatterEvent, int32_t Param1, int32_t Param2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerPlayChatter");
		
		ASurvivalCharacter_ServerPlayChatter_Params params {};
		params.ChatterEvent = ChatterEvent;
		params.Param1 = Param1;
		params.Param2 = Param2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerPlayAnimMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLockCharacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECharacterAnimMontageType                          AnimMontageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::ServerPlayAnimMontage(class UAnimMontage* AnimMontage, bool bLockCharacter, ECharacterAnimMontageType AnimMontageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerPlayAnimMontage");
		
		ASurvivalCharacter_ServerPlayAnimMontage_Params params {};
		params.AnimMontage = AnimMontage;
		params.bLockCharacter = bLockCharacter;
		params.AnimMontageType = AnimMontageType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerEndSprint
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::ServerEndSprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerEndSprint");
		
		ASurvivalCharacter_ServerEndSprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerEndGlide
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::ServerEndGlide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerEndGlide");
		
		ASurvivalCharacter_ServerEndGlide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerEndBlock
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               FromInput                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::ServerEndBlock(bool FromInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerEndBlock");
		
		ASurvivalCharacter_ServerEndBlock_Params params {};
		params.FromInput = FromInput;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerEndAttack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOnlyEndBeforeHitFrame                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::ServerEndAttack(bool bOnlyEndBeforeHitFrame)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerEndAttack");
		
		ASurvivalCharacter_ServerEndAttack_Params params {};
		params.bOnlyEndBeforeHitFrame = bOnlyEndBeforeHitFrame;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerDismount
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::ServerDismount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerDismount");
		
		ASurvivalCharacter_ServerDismount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ServerAttemptRaycastPossess
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::ServerAttemptRaycastPossess()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ServerAttemptRaycastPossess");
		
		ASurvivalCharacter_ServerAttemptRaycastPossess_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.PlayDestroyVisuals
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDestroyCharacterVariation                         Variation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::PlayDestroyVisuals(EDestroyCharacterVariation Variation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.PlayDestroyVisuals");
		
		ASurvivalCharacter_PlayDestroyVisuals_Params params {};
		params.Variation = Variation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnUnderwaterChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsUnderwater                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::OnUnderwaterChanged(bool bIsUnderwater)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnUnderwaterChanged");
		
		ASurvivalCharacter_OnUnderwaterChanged_Params params {};
		params.bIsUnderwater = bIsUnderwater;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnUIOpenChatPressed
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::OnUIOpenChatPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnUIOpenChatPressed");
		
		ASurvivalCharacter_OnUIOpenChatPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnStatusEffectChanged
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::OnStatusEffectChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnStatusEffectChanged");
		
		ASurvivalCharacter_OnStatusEffectChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnRevive
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::OnRevive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnRevive");
		
		ASurvivalCharacter_OnRevive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnRep_SplineProgress
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::OnRep_SplineProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnRep_SplineProgress");
		
		ASurvivalCharacter_OnRep_SplineProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnRep_ReplicatedMotionEater
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::OnRep_ReplicatedMotionEater()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnRep_ReplicatedMotionEater");
		
		ASurvivalCharacter_OnRep_ReplicatedMotionEater_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnRep_ReplicatedCurrentPlayingInteractAnim
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::OnRep_ReplicatedCurrentPlayingInteractAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnRep_ReplicatedCurrentPlayingInteractAnim");
		
		ASurvivalCharacter_OnRep_ReplicatedCurrentPlayingInteractAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnRep_NetworkRelevance
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::OnRep_NetworkRelevance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnRep_NetworkRelevance");
		
		ASurvivalCharacter_OnRep_NetworkRelevance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnRep_IsAttacking
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::OnRep_IsAttacking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnRep_IsAttacking");
		
		ASurvivalCharacter_OnRep_IsAttacking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnRep_InCombat
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::OnRep_InCombat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnRep_InCombat");
		
		ASurvivalCharacter_OnRep_InCombat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnRep_CurrentMount
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::OnRep_CurrentMount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnRep_CurrentMount");
		
		ASurvivalCharacter_OnRep_CurrentMount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnRep_bReplicatedIsSprinting
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::OnRep_bReplicatedIsSprinting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnRep_bReplicatedIsSprinting");
		
		ASurvivalCharacter_OnRep_bReplicatedIsSprinting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnRep_bReplicatedAutorun
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::OnRep_bReplicatedAutorun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnRep_bReplicatedAutorun");
		
		ASurvivalCharacter_OnRep_bReplicatedAutorun_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnPlayerRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerState*                                RemovedPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::OnPlayerRemoved(class APlayerState* RemovedPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnPlayerRemoved");
		
		ASurvivalCharacter_OnPlayerRemoved_Params params {};
		params.RemovedPlayer = RemovedPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnOpenChatMenuPressed
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::OnOpenChatMenuPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnOpenChatMenuPressed");
		
		ASurvivalCharacter_OnOpenChatMenuPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnIncapacitate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::OnIncapacitate(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnIncapacitate");
		
		ASurvivalCharacter_OnIncapacitate_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnHitReact
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UReactionComponent*                          Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EHitReactionType                                   ReactType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::OnHitReact(class UReactionComponent* Sender, EHitReactionType ReactType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnHitReact");
		
		ASurvivalCharacter_OnHitReact_Params params {};
		params.Sender = Sender;
		params.ReactType = ReactType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnHealthStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHealthState                                       HealthState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::OnHealthStateChanged(EHealthState HealthState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnHealthStateChanged");
		
		ASurvivalCharacter_OnHealthStateChanged_Params params {};
		params.HealthState = HealthState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.OnDeath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::OnDeath(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.OnDeath");
		
		ASurvivalCharacter_OnDeath_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastStopCaptureReaction
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::MulticastStopCaptureReaction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastStopCaptureReaction");
		
		ASurvivalCharacter_MulticastStopCaptureReaction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastStopAnimMontageType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECharacterAnimMontageType                          AnimMontageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::MulticastStopAnimMontageType(ECharacterAnimMontageType AnimMontageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastStopAnimMontageType");
		
		ASurvivalCharacter_MulticastStopAnimMontageType_Params params {};
		params.AnimMontageType = AnimMontageType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastStopAnimMontageSoft
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::MulticastStopAnimMontageSoft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastStopAnimMontageSoft");
		
		ASurvivalCharacter_MulticastStopAnimMontageSoft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastStopAnimMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::MulticastStopAnimMontage(class UAnimMontage* AnimMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastStopAnimMontage");
		
		ASurvivalCharacter_MulticastStopAnimMontage_Params params {};
		params.AnimMontage = AnimMontage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastStartCaptureReaction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLockCharacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::MulticastStartCaptureReaction(class UAnimMontage* AnimMontage, bool bLockCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastStartCaptureReaction");
		
		ASurvivalCharacter_MulticastStartCaptureReaction_Params params {};
		params.AnimMontage = AnimMontage;
		params.bLockCharacter = bLockCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastSetPawnCollision
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECollisionResponse                                 CollisionResponse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::MulticastSetPawnCollision(ECollisionResponse CollisionResponse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastSetPawnCollision");
		
		ASurvivalCharacter_MulticastSetPawnCollision_Params params {};
		params.CollisionResponse = CollisionResponse;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastSetAnimMontageNextSection
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SectionToSet                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        NextSection                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               JumpIfNotInSection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::MulticastSetAnimMontageNextSection(class UAnimMontage* AnimMontage, const class FName& SectionToSet, const class FName& NextSection, bool JumpIfNotInSection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastSetAnimMontageNextSection");
		
		ASurvivalCharacter_MulticastSetAnimMontageNextSection_Params params {};
		params.AnimMontage = AnimMontage;
		params.SectionToSet = SectionToSet;
		params.NextSection = NextSection;
		params.JumpIfNotInSection = JumpIfNotInSection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastPlayPropAnimSoftProp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLockCharacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECharacterAnimMontageType                          AnimMontageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::MulticastPlayPropAnimSoftProp(class UAnimMontage* AnimMontage, bool bLockCharacter, ECharacterAnimMontageType AnimMontageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastPlayPropAnimSoftProp");
		
		ASurvivalCharacter_MulticastPlayPropAnimSoftProp_Params params {};
		params.AnimMontage = AnimMontage;
		params.bLockCharacter = bLockCharacter;
		params.AnimMontageType = AnimMontageType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastPlayPropAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Prop                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLockCharacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECharacterAnimMontageType                          AnimMontageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::MulticastPlayPropAnim(class UAnimMontage* AnimMontage, class UClass* Prop, bool bLockCharacter, ECharacterAnimMontageType AnimMontageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastPlayPropAnim");
		
		ASurvivalCharacter_MulticastPlayPropAnim_Params params {};
		params.AnimMontage = AnimMontage;
		params.Prop = Prop;
		params.bLockCharacter = bLockCharacter;
		params.AnimMontageType = AnimMontageType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastPlayDestroyVisuals
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDestroyCharacterVariation                         Variation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::MulticastPlayDestroyVisuals(EDestroyCharacterVariation Variation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastPlayDestroyVisuals");
		
		ASurvivalCharacter_MulticastPlayDestroyVisuals_Params params {};
		params.Variation = Variation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastPlayConsumedEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemType                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     AtLocation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::MulticastPlayConsumedEffect(const struct FDataTableRowHandle& ItemType, const struct FVector& AtLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastPlayConsumedEffect");
		
		ASurvivalCharacter_MulticastPlayConsumedEffect_Params params {};
		params.ItemType = ItemType;
		params.AtLocation = AtLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastPlayAnimMontageSoft
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bLockCharacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECharacterAnimMontageType                          AnimMontageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::MulticastPlayAnimMontageSoft(bool bLockCharacter, ECharacterAnimMontageType AnimMontageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastPlayAnimMontageSoft");
		
		ASurvivalCharacter_MulticastPlayAnimMontageSoft_Params params {};
		params.bLockCharacter = bLockCharacter;
		params.AnimMontageType = AnimMontageType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastPlayAnimMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLockCharacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECharacterAnimMontageType                          AnimMontageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::MulticastPlayAnimMontage(class UAnimMontage* AnimMontage, bool bLockCharacter, ECharacterAnimMontageType AnimMontageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastPlayAnimMontage");
		
		ASurvivalCharacter_MulticastPlayAnimMontage_Params params {};
		params.AnimMontage = AnimMontage;
		params.bLockCharacter = bLockCharacter;
		params.AnimMontageType = AnimMontageType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastJumpAnimMontageSection
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SectionToSet                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        NextSection                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::MulticastJumpAnimMontageSection(class UAnimMontage* AnimMontage, const class FName& SectionToSet, const class FName& NextSection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastJumpAnimMontageSection");
		
		ASurvivalCharacter_MulticastJumpAnimMontageSection_Params params {};
		params.AnimMontage = AnimMontage;
		params.SectionToSet = SectionToSet;
		params.NextSection = NextSection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastHandleDetachFromControllerPendingDestroy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AController*                                 OldController                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::MulticastHandleDetachFromControllerPendingDestroy(class AController* OldController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastHandleDetachFromControllerPendingDestroy");
		
		ASurvivalCharacter_MulticastHandleDetachFromControllerPendingDestroy_Params params {};
		params.OldController = OldController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.MulticastAttackDestroyCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bDestroy                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::MulticastAttackDestroyCharacter(bool bDestroy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.MulticastAttackDestroyCharacter");
		
		ASurvivalCharacter_MulticastAttackDestroyCharacter_Params params {};
		params.bDestroy = bDestroy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.IsLockedByAnimation
	 * 		Flags  -> ()
	 */
	bool ASurvivalCharacter::IsLockedByAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.IsLockedByAnimation");
		
		ASurvivalCharacter_IsLockedByAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.IsInCombat
	 * 		Flags  -> ()
	 */
	bool ASurvivalCharacter::IsInCombat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.IsInCombat");
		
		ASurvivalCharacter_IsInCombat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.IsFemale
	 * 		Flags  -> ()
	 */
	bool ASurvivalCharacter::IsFemale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.IsFemale");
		
		ASurvivalCharacter_IsFemale_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.IsCameraDisplayModeLocked
	 * 		Flags  -> ()
	 */
	bool ASurvivalCharacter::IsCameraDisplayModeLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.IsCameraDisplayModeLocked");
		
		ASurvivalCharacter_IsCameraDisplayModeLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.InputToggleCameraModePressed
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::InputToggleCameraModePressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.InputToggleCameraModePressed");
		
		ASurvivalCharacter_InputToggleCameraModePressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.HasTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                InTag                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalCharacter::HasTag(const struct FGameplayTag& InTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.HasTag");
		
		ASurvivalCharacter_HasTag_Params params {};
		params.InTag = InTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.HasAnyTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTagContainer                       InTags                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalCharacter::HasAnyTag(const struct FGameplayTagContainer& InTags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.HasAnyTag");
		
		ASurvivalCharacter_HasAnyTag_Params params {};
		params.InTags = InTags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.HandleCameraDisplayModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECameraDisplayMode                                 DisplayMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::HandleCameraDisplayModeChanged(ECameraDisplayMode DisplayMode, float BlendTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.HandleCameraDisplayModeChanged");
		
		ASurvivalCharacter_HandleCameraDisplayModeChanged_Params params {};
		params.DisplayMode = DisplayMode;
		params.BlendTime = BlendTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.HandleBaseBuildingRelocated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABuilding*                                   Sender                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::HandleBaseBuildingRelocated(class ABuilding* Sender)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.HandleBaseBuildingRelocated");
		
		ASurvivalCharacter_HandleBaseBuildingRelocated_Params params {};
		params.Sender = Sender;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetViewCharacter
	 * 		Flags  -> ()
	 */
	class ASurvivalCharacter* ASurvivalCharacter::GetViewCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetViewCharacter");
		
		ASurvivalCharacter_GetViewCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetSpeaker
	 * 		Flags  -> ()
	 */
	struct FSpeakerReference ASurvivalCharacter::GetSpeaker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetSpeaker");
		
		ASurvivalCharacter_GetSpeaker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetMovementForwardVector
	 * 		Flags  -> ()
	 */
	struct FVector ASurvivalCharacter::GetMovementForwardVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetMovementForwardVector");
		
		ASurvivalCharacter_GetMovementForwardVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetLookWorldOrigin
	 * 		Flags  -> ()
	 */
	struct FVector ASurvivalCharacter::GetLookWorldOrigin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetLookWorldOrigin");
		
		ASurvivalCharacter_GetLookWorldOrigin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetLookForwardVector
	 * 		Flags  -> ()
	 */
	struct FVector ASurvivalCharacter::GetLookForwardVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetLookForwardVector");
		
		ASurvivalCharacter_GetLookForwardVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetIsFirstPerson
	 * 		Flags  -> ()
	 */
	bool ASurvivalCharacter::GetIsFirstPerson()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetIsFirstPerson");
		
		ASurvivalCharacter_GetIsFirstPerson_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetID
	 * 		Flags  -> ()
	 */
	struct FGuid ASurvivalCharacter::GetID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetID");
		
		ASurvivalCharacter_GetID_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetGiveUpTimeRemaining
	 * 		Flags  -> ()
	 */
	float ASurvivalCharacter::GetGiveUpTimeRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetGiveUpTimeRemaining");
		
		ASurvivalCharacter_GetGiveUpTimeRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetGiveUpMaxTime
	 * 		Flags  -> ()
	 */
	float ASurvivalCharacter::GetGiveUpMaxTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetGiveUpMaxTime");
		
		ASurvivalCharacter_GetGiveUpMaxTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetFirstPersonCamera
	 * 		Flags  -> ()
	 */
	class UCameraComponent* ASurvivalCharacter::GetFirstPersonCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetFirstPersonCamera");
		
		ASurvivalCharacter_GetFirstPersonCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetEmoteAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                EmoteTypeTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::GetEmoteAnim(const struct FGameplayTag& EmoteTypeTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetEmoteAnim");
		
		ASurvivalCharacter_GetEmoteAnim_Params params {};
		params.EmoteTypeTag = EmoteTypeTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetEmergeAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            EmergeVariation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimMontage* ASurvivalCharacter::GetEmergeAnim(int32_t EmergeVariation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetEmergeAnim");
		
		ASurvivalCharacter_GetEmergeAnim_Params params {};
		params.EmergeVariation = EmergeVariation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetCurrentMount
	 * 		Flags  -> ()
	 */
	class ASurvivalCharacter* ASurvivalCharacter::GetCurrentMount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetCurrentMount");
		
		ASurvivalCharacter_GetCurrentMount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetCurrentCameraLocation
	 * 		Flags  -> ()
	 */
	struct FVector ASurvivalCharacter::GetCurrentCameraLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetCurrentCameraLocation");
		
		ASurvivalCharacter_GetCurrentCameraLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetCurrentCamera
	 * 		Flags  -> ()
	 */
	class UCameraComponent* ASurvivalCharacter::GetCurrentCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetCurrentCamera");
		
		ASurvivalCharacter_GetCurrentCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetCurrentAttack
	 * 		Flags  -> ()
	 */
	class UAttack* ASurvivalCharacter::GetCurrentAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetCurrentAttack");
		
		ASurvivalCharacter_GetCurrentAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetControlOptions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UControlOptions* ASurvivalCharacter::GetControlOptions(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetControlOptions");
		
		ASurvivalCharacter_GetControlOptions_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetCharacterTypeName
	 * 		Flags  -> ()
	 */
	struct FLocString ASurvivalCharacter::GetCharacterTypeName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetCharacterTypeName");
		
		ASurvivalCharacter_GetCharacterTypeName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetCharacterInstanceName
	 * 		Flags  -> ()
	 */
	class FString ASurvivalCharacter::GetCharacterInstanceName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetCharacterInstanceName");
		
		ASurvivalCharacter_GetCharacterInstanceName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetCharacterDataRow
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle ASurvivalCharacter::GetCharacterDataRow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetCharacterDataRow");
		
		ASurvivalCharacter_GetCharacterDataRow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetCapsuleBounds
	 * 		Flags  -> ()
	 */
	struct FBoxSphereBounds ASurvivalCharacter::GetCapsuleBounds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetCapsuleBounds");
		
		ASurvivalCharacter_GetCapsuleBounds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetCameraDisplayMode
	 * 		Flags  -> ()
	 */
	ECameraDisplayMode ASurvivalCharacter::GetCameraDisplayMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetCameraDisplayMode");
		
		ASurvivalCharacter_GetCameraDisplayMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetAnimProp
	 * 		Flags  -> ()
	 */
	class AActor* ASurvivalCharacter::GetAnimProp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetAnimProp");
		
		ASurvivalCharacter_GetAnimProp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.GetAbilities
	 * 		Flags  -> ()
	 */
	TArray<class UAbility*> ASurvivalCharacter::GetAbilities()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.GetAbilities");
		
		ASurvivalCharacter_GetAbilities_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.DisablePlayerLookAndTurnInput
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DisableTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::DisablePlayerLookAndTurnInput(float DisableTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.DisablePlayerLookAndTurnInput");
		
		ASurvivalCharacter_DisablePlayerLookAndTurnInput_Params params {};
		params.DisableTime = DisableTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ClientNotifyStartAttackFailure
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::ClientNotifyStartAttackFailure()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ClientNotifyStartAttackFailure");
		
		ASurvivalCharacter_ClientNotifyStartAttackFailure_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ClientNotifyRangedAttackHit
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::ClientNotifyRangedAttackHit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ClientNotifyRangedAttackHit");
		
		ASurvivalCharacter_ClientNotifyRangedAttackHit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ClearOverrideCameraDisplayMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Handle                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InBlendTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCharacter::ClearOverrideCameraDisplayMode(int32_t Handle, float InBlendTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ClearOverrideCameraDisplayMode");
		
		ASurvivalCharacter_ClearOverrideCameraDisplayMode_Params params {};
		params.Handle = Handle;
		params.InBlendTime = InBlendTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.CanBeMounted
	 * 		Flags  -> ()
	 */
	bool ASurvivalCharacter::CanBeMounted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.CanBeMounted");
		
		ASurvivalCharacter_CanBeMounted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacter.ApplyFallDamage
	 * 		Flags  -> ()
	 */
	void ASurvivalCharacter::ApplyFallDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacter.ApplyFallDamage");
		
		ASurvivalCharacter_ApplyFallDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASurvivalCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASurvivalCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCreature.OnRep_TameData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTamedCreatureData*                          OldData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCreature::OnRep_TameData(class UTamedCreatureData* OldData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCreature.OnRep_TameData");
		
		ASurvivalCreature_OnRep_TameData_Params params {};
		params.OldData = OldData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCreature.IsTamingFood
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalCreature::IsTamingFood(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCreature.IsTamingFood");
		
		ASurvivalCreature_IsTamingFood_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCreature.IsInactivePet
	 * 		Flags  -> ()
	 */
	bool ASurvivalCreature::IsInactivePet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCreature.IsInactivePet");
		
		ASurvivalCreature_IsInactivePet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCreature.IsActivePet
	 * 		Flags  -> ()
	 */
	bool ASurvivalCreature::IsActivePet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCreature.IsActivePet");
		
		ASurvivalCreature_IsActivePet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCreature.HandleTameStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTamedCreatureData*                          Sender                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETamedState                                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalCreature::HandleTameStateChanged(class UTamedCreatureData* Sender, ETamedState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCreature.HandleTameStateChanged");
		
		ASurvivalCreature_HandleTameStateChanged_Params params {};
		params.Sender = Sender;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCreature.GetPetMasterLocation
	 * 		Flags  -> ()
	 */
	struct FVector ASurvivalCreature::GetPetMasterLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCreature.GetPetMasterLocation");
		
		ASurvivalCreature_GetPetMasterLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCreature.GetPetMaster
	 * 		Flags  -> ()
	 */
	class ASurvivalPlayerCharacter* ASurvivalCreature::GetPetMaster()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCreature.GetPetMaster");
		
		ASurvivalCreature_GetPetMaster_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCreature.GetPetHomeLocation
	 * 		Flags  -> ()
	 */
	struct FVector ASurvivalCreature::GetPetHomeLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCreature.GetPetHomeLocation");
		
		ASurvivalCreature_GetPetHomeLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCreature.GetPetHappinessNormalized
	 * 		Flags  -> ()
	 */
	float ASurvivalCreature::GetPetHappinessNormalized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCreature.GetPetHappinessNormalized");
		
		ASurvivalCreature_GetPetHappinessNormalized_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCreature.GetFoodsList
	 * 		Flags  -> ()
	 */
	class FString ASurvivalCreature::GetFoodsList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCreature.GetFoodsList");
		
		ASurvivalCreature_GetFoodsList_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCreature.GetActivePetPassiveEffects
	 * 		Flags  -> ()
	 */
	TArray<struct FDataTableRowHandle> ASurvivalCreature::GetActivePetPassiveEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCreature.GetActivePetPassiveEffects");
		
		ASurvivalCreature_GetActivePetPassiveEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASurvivalCreature.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASurvivalCreature::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalCreature");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurrowSurvivalCharacter.SetBurrowParticleComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UParticleSystemComponent*                    PSC                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABurrowSurvivalCharacter::SetBurrowParticleComponent(class UParticleSystemComponent* PSC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurrowSurvivalCharacter.SetBurrowParticleComponent");
		
		ABurrowSurvivalCharacter_SetBurrowParticleComponent_Params params {};
		params.PSC = PSC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurrowSurvivalCharacter.SetBurrowAudioComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAudioComponent*                             AudioComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABurrowSurvivalCharacter::SetBurrowAudioComponent(class UAudioComponent* AudioComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurrowSurvivalCharacter.SetBurrowAudioComponent");
		
		ABurrowSurvivalCharacter_SetBurrowAudioComponent_Params params {};
		params.AudioComponent = AudioComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.BurrowSurvivalCharacter.HandleBurrowStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EBurrowState                                       BurrowState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABurrowSurvivalCharacter::HandleBurrowStateChanged(EBurrowState BurrowState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.BurrowSurvivalCharacter.HandleBurrowStateChanged");
		
		ABurrowSurvivalCharacter_HandleBurrowStateChanged_Params params {};
		params.BurrowState = BurrowState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABurrowSurvivalCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABurrowSurvivalCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.BurrowSurvivalCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.SetTimeSpeedMultiplier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Multiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCalendarComponent::SetTimeSpeedMultiplier(float Multiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.SetTimeSpeedMultiplier");
		
		UCalendarComponent_SetTimeSpeedMultiplier_Params params {};
		params.Multiplier = Multiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.ServerAdvanceTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCalendarComponent::ServerAdvanceTime(float Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.ServerAdvanceTime");
		
		UCalendarComponent_ServerAdvanceTime_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.OnRep_CurrentTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		double                                             PreviousValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCalendarComponent::OnRep_CurrentTime(double PreviousValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.OnRep_CurrentTime");
		
		UCalendarComponent_OnRep_CurrentTime_Params params {};
		params.PreviousValue = PreviousValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.MulticastSyncTimeOfDay
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              TimeToSync                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCalendarComponent::MulticastSyncTimeOfDay(float TimeToSync)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.MulticastSyncTimeOfDay");
		
		UCalendarComponent_MulticastSyncTimeOfDay_Params params {};
		params.TimeToSync = TimeToSync;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.IsNightTime
	 * 		Flags  -> ()
	 */
	bool UCalendarComponent::IsNightTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.IsNightTime");
		
		UCalendarComponent_IsNightTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.IsDayTime
	 * 		Flags  -> ()
	 */
	bool UCalendarComponent::IsDayTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.IsDayTime");
		
		UCalendarComponent_IsDayTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetTotalHour
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Day                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DayHour                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UCalendarComponent::GetTotalHour(float Day, float DayHour)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetTotalHour");
		
		UCalendarComponent_GetTotalHour_Params params {};
		params.Day = Day;
		params.DayHour = DayHour;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetTotalGameHoursPassed
	 * 		Flags  -> ()
	 */
	float UCalendarComponent::GetTotalGameHoursPassed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetTotalGameHoursPassed");
		
		UCalendarComponent_GetTotalGameHoursPassed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetTimeString
	 * 		Flags  -> ()
	 */
	class FString UCalendarComponent::GetTimeString()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetTimeString");
		
		UCalendarComponent_GetTimeString_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetSecondsPerHour
	 * 		Flags  -> ()
	 */
	int32_t UCalendarComponent::GetSecondsPerHour()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetSecondsPerHour");
		
		UCalendarComponent_GetSecondsPerHour_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetSecondsPerDay
	 * 		Flags  -> ()
	 */
	int32_t UCalendarComponent::GetSecondsPerDay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetSecondsPerDay");
		
		UCalendarComponent_GetSecondsPerDay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetNormalizedTime
	 * 		Flags  -> ()
	 */
	float UCalendarComponent::GetNormalizedTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetNormalizedTime");
		
		UCalendarComponent_GetNormalizedTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetNextDayHourTotalHour
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DayHour                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UCalendarComponent::GetNextDayHourTotalHour(float DayHour)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetNextDayHourTotalHour");
		
		UCalendarComponent_GetNextDayHourTotalHour_Params params {};
		params.DayHour = DayHour;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetMinutesPerHour
	 * 		Flags  -> ()
	 */
	int32_t UCalendarComponent::GetMinutesPerHour()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetMinutesPerHour");
		
		UCalendarComponent_GetMinutesPerHour_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetMinute
	 * 		Flags  -> ()
	 */
	int32_t UCalendarComponent::GetMinute()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetMinute");
		
		UCalendarComponent_GetMinute_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetHoursUntilHour
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              TargetHour                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UCalendarComponent::GetHoursUntilHour(float TargetHour)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetHoursUntilHour");
		
		UCalendarComponent_GetHoursUntilHour_Params params {};
		params.TargetHour = TargetHour;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetHoursString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Hours                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UCalendarComponent::GetHoursString(float Hours)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetHoursString");
		
		UCalendarComponent_GetHoursString_Params params {};
		params.Hours = Hours;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetHoursPerDay
	 * 		Flags  -> ()
	 */
	int32_t UCalendarComponent::GetHoursPerDay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetHoursPerDay");
		
		UCalendarComponent_GetHoursPerDay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetHourFloat
	 * 		Flags  -> ()
	 */
	float UCalendarComponent::GetHourFloat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetHourFloat");
		
		UCalendarComponent_GetHourFloat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetHour
	 * 		Flags  -> ()
	 */
	int32_t UCalendarComponent::GetHour()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetHour");
		
		UCalendarComponent_GetHour_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetGameToRealTimeRatio
	 * 		Flags  -> ()
	 */
	float UCalendarComponent::GetGameToRealTimeRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetGameToRealTimeRatio");
		
		UCalendarComponent_GetGameToRealTimeRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetDaytimeStart
	 * 		Flags  -> ()
	 */
	int32_t UCalendarComponent::GetDaytimeStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetDaytimeStart");
		
		UCalendarComponent_GetDaytimeStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetDaytimeEnd
	 * 		Flags  -> ()
	 */
	int32_t UCalendarComponent::GetDaytimeEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetDaytimeEnd");
		
		UCalendarComponent_GetDaytimeEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetDay
	 * 		Flags  -> ()
	 */
	int32_t UCalendarComponent::GetDay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetDay");
		
		UCalendarComponent_GetDay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetCurrentTimeHours
	 * 		Flags  -> ()
	 */
	float UCalendarComponent::GetCurrentTimeHours()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetCurrentTimeHours");
		
		UCalendarComponent_GetCurrentTimeHours_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetCurrentTime
	 * 		Flags  -> ()
	 */
	float UCalendarComponent::GetCurrentTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetCurrentTime");
		
		UCalendarComponent_GetCurrentTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.GetClockFormat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Hours                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UCalendarComponent::GetClockFormat(float Hours)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.GetClockFormat");
		
		UCalendarComponent_GetClockFormat_Params params {};
		params.Hours = Hours;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.ForceSetTimeOfDay
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            TargetDay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TargetHour                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCalendarComponent::ForceSetTimeOfDay(int32_t TargetDay, int32_t TargetHour)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.ForceSetTimeOfDay");
		
		UCalendarComponent_ForceSetTimeOfDay_Params params {};
		params.TargetDay = TargetDay;
		params.TargetHour = TargetHour;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CalendarComponent.DeltaHoursToTimestamp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Hours                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UCalendarComponent::DeltaHoursToTimestamp(float Hours)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CalendarComponent.DeltaHoursToTimestamp");
		
		UCalendarComponent_DeltaHoursToTimestamp_Params params {};
		params.Hours = Hours;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCalendarComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCalendarComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CalendarComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Switch.SetUsesRemaining
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              UsesRemaining                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASwitch::SetUsesRemaining(float UsesRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Switch.SetUsesRemaining");
		
		ASwitch_SetUsesRemaining_Params params {};
		params.UsesRemaining = UsesRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Switch.OnUpdateVisualState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsOpen                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASwitch::OnUpdateVisualState(bool IsOpen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Switch.OnUpdateVisualState");
		
		ASwitch_OnUpdateVisualState_Params params {};
		params.IsOpen = IsOpen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Switch.OnOpenStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsOpen                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ActorInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASwitch::OnOpenStateChanged(bool IsOpen, class AActor* ActorInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Switch.OnOpenStateChanged");
		
		ASwitch_OnOpenStateChanged_Params params {};
		params.IsOpen = IsOpen;
		params.ActorInstigator = ActorInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Switch.OnLockStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsLocked                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASwitch::OnLockStateChanged(bool IsLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Switch.OnLockStateChanged");
		
		ASwitch_OnLockStateChanged_Params params {};
		params.IsLocked = IsLocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Switch.NativeOnUpdateVisualState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsOpen                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASwitch::NativeOnUpdateVisualState(bool IsOpen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Switch.NativeOnUpdateVisualState");
		
		ASwitch_NativeOnUpdateVisualState_Params params {};
		params.IsOpen = IsOpen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Switch.NativeOnOpenStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsOpen                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ActorInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASwitch::NativeOnOpenStateChanged(bool IsOpen, class AActor* ActorInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Switch.NativeOnOpenStateChanged");
		
		ASwitch_NativeOnOpenStateChanged_Params params {};
		params.IsOpen = IsOpen;
		params.ActorInstigator = ActorInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Switch.NativeOnLockStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsLocked                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASwitch::NativeOnLockStateChanged(bool IsLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Switch.NativeOnLockStateChanged");
		
		ASwitch_NativeOnLockStateChanged_Params params {};
		params.IsLocked = IsLocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASwitch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASwitch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Switch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CameraMonitorTerminal.OnLocalPlayerOverlappingOnBeginPlay
	 * 		Flags  -> ()
	 */
	void ACameraMonitorTerminal::OnLocalPlayerOverlappingOnBeginPlay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CameraMonitorTerminal.OnLocalPlayerOverlappingOnBeginPlay");
		
		ACameraMonitorTerminal_OnLocalPlayerOverlappingOnBeginPlay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACameraMonitorTerminal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACameraMonitorTerminal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CameraMonitorTerminal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CameraViewProvider.HasLookAtLocation
	 * 		Flags  -> ()
	 */
	bool UCameraViewProvider::HasLookAtLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CameraViewProvider.HasLookAtLocation");
		
		UCameraViewProvider_HasLookAtLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CameraViewProvider.GetLookAtLocation
	 * 		Flags  -> ()
	 */
	struct FVector UCameraViewProvider::GetLookAtLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CameraViewProvider.GetLookAtLocation");
		
		UCameraViewProvider_GetLookAtLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CameraViewProvider.GetCameraViewTransform
	 * 		Flags  -> ()
	 */
	struct FTransform UCameraViewProvider::GetCameraViewTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CameraViewProvider.GetCameraViewTransform");
		
		UCameraViewProvider_GetCameraViewTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCameraViewProvider.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCameraViewProvider::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CameraViewProvider");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CDOFunctionLibrary.IsDefaultObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCDOFunctionLibrary::IsDefaultObject(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CDOFunctionLibrary.IsDefaultObject");
		
		UCDOFunctionLibrary_IsDefaultObject_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CDOFunctionLibrary.GetDefaultComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UActorComponent*                             Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UActorComponent* UCDOFunctionLibrary::GetDefaultComponent(class UActorComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CDOFunctionLibrary.GetDefaultComponent");
		
		UCDOFunctionLibrary_GetDefaultComponent_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CDOFunctionLibrary.FindDefaultComponentsByClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ComponentClass                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UActorComponent*> UCDOFunctionLibrary::FindDefaultComponentsByClass(class AActor* Actor, class UClass* ComponentClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CDOFunctionLibrary.FindDefaultComponentsByClass");
		
		UCDOFunctionLibrary_FindDefaultComponentsByClass_Params params {};
		params.Actor = Actor;
		params.ComponentClass = ComponentClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CDOFunctionLibrary.FindDefaultComponentByName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ComponentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UActorComponent* UCDOFunctionLibrary::FindDefaultComponentByName(class AActor* Actor, const class FName& ComponentName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CDOFunctionLibrary.FindDefaultComponentByName");
		
		UCDOFunctionLibrary_FindDefaultComponentByName_Params params {};
		params.Actor = Actor;
		params.ComponentName = ComponentName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CDOFunctionLibrary.FindDefaultComponentByClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ComponentClass                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UActorComponent* UCDOFunctionLibrary::FindDefaultComponentByClass(class AActor* Actor, class UClass* ComponentClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CDOFunctionLibrary.FindDefaultComponentByClass");
		
		UCDOFunctionLibrary_FindDefaultComponentByClass_Params params {};
		params.Actor = Actor;
		params.ComponentClass = ComponentClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCDOFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCDOFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CDOFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ChairBuilding.SetupSittingCharacterTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                                  Transform                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AChairBuilding::SetupSittingCharacterTransform(const struct FTransform& Transform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ChairBuilding.SetupSittingCharacterTransform");
		
		AChairBuilding_SetupSittingCharacterTransform_Params params {};
		params.Transform = Transform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ChairBuilding.IsOccupied
	 * 		Flags  -> ()
	 */
	bool AChairBuilding::IsOccupied()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ChairBuilding.IsOccupied");
		
		AChairBuilding_IsOccupied_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ChairBuilding.GetSitTargetTransform
	 * 		Flags  -> ()
	 */
	struct FTransform AChairBuilding::GetSitTargetTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ChairBuilding.GetSitTargetTransform");
		
		AChairBuilding_GetSitTargetTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AChairBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AChairBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ChairBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterAudioData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterAudioData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CharacterAudioData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyCharacterActor.UpdateHomeLocation
	 * 		Flags  -> ()
	 */
	void UProxyCharacterActor::UpdateHomeLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyCharacterActor.UpdateHomeLocation");
		
		UProxyCharacterActor_UpdateHomeLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyCharacterActor.OnNavigationPathUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UNavigationPath*                             AffectedPath                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ENavPathEvent                                      PathEvent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UProxyCharacterActor::OnNavigationPathUpdated(class UNavigationPath* AffectedPath, ENavPathEvent PathEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyCharacterActor.OnNavigationPathUpdated");
		
		UProxyCharacterActor_OnNavigationPathUpdated_Params params {};
		params.AffectedPath = AffectedPath;
		params.PathEvent = PathEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyCharacterActor.MarkDesiredActionUnreachable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bObstructed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UProxyCharacterActor::MarkDesiredActionUnreachable(bool bObstructed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyCharacterActor.MarkDesiredActionUnreachable");
		
		UProxyCharacterActor_MarkDesiredActionUnreachable_Params params {};
		params.bObstructed = bObstructed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyCharacterActor.GetWaveDestination
	 * 		Flags  -> ()
	 */
	struct FVector UProxyCharacterActor::GetWaveDestination()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyCharacterActor.GetWaveDestination");
		
		UProxyCharacterActor_GetWaveDestination_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyCharacterActor.GetSearchOrigin
	 * 		Flags  -> ()
	 */
	struct FVector UProxyCharacterActor::GetSearchOrigin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyCharacterActor.GetSearchOrigin");
		
		UProxyCharacterActor_GetSearchOrigin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyCharacterActor.GetHomeLocation
	 * 		Flags  -> ()
	 */
	struct FVector UProxyCharacterActor::GetHomeLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyCharacterActor.GetHomeLocation");
		
		UProxyCharacterActor_GetHomeLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyCharacterActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyCharacterActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyCharacterActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CharacterLODActor.IsSwimming
	 * 		Flags  -> ()
	 */
	bool UCharacterLODActor::IsSwimming()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CharacterLODActor.IsSwimming");
		
		UCharacterLODActor_IsSwimming_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CharacterLODActor.IsResting
	 * 		Flags  -> ()
	 */
	bool UCharacterLODActor::IsResting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CharacterLODActor.IsResting");
		
		UCharacterLODActor_IsResting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CharacterLODActor.IsMoving
	 * 		Flags  -> ()
	 */
	bool UCharacterLODActor::IsMoving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CharacterLODActor.IsMoving");
		
		UCharacterLODActor_IsMoving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CharacterLODActor.IsFlying
	 * 		Flags  -> ()
	 */
	bool UCharacterLODActor::IsFlying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CharacterLODActor.IsFlying");
		
		UCharacterLODActor_IsFlying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CharacterLODActor.GetInterestCore
	 * 		Flags  -> ()
	 */
	class UInterestCore* UCharacterLODActor::GetInterestCore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CharacterLODActor.GetInterestCore");
		
		UCharacterLODActor_GetInterestCore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CharacterLODActor.GetCharacterTypeName
	 * 		Flags  -> ()
	 */
	struct FLocString UCharacterLODActor::GetCharacterTypeName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CharacterLODActor.GetCharacterTypeName");
		
		UCharacterLODActor_GetCharacterTypeName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CharacterLODActor.GetCharacterInstanceName
	 * 		Flags  -> ()
	 */
	class FString UCharacterLODActor::GetCharacterInstanceName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CharacterLODActor.GetCharacterInstanceName");
		
		UCharacterLODActor_GetCharacterInstanceName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CharacterLODActor.GetBlackboardTargetLocation
	 * 		Flags  -> ()
	 */
	struct FVector UCharacterLODActor::GetBlackboardTargetLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CharacterLODActor.GetBlackboardTargetLocation");
		
		UCharacterLODActor_GetBlackboardTargetLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CharacterLODActor.GetBlackboardTargetActor
	 * 		Flags  -> ()
	 */
	class AActor* UCharacterLODActor::GetBlackboardTargetActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CharacterLODActor.GetBlackboardTargetActor");
		
		UCharacterLODActor_GetBlackboardTargetActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterLODActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterLODActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CharacterLODActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CharacterMotionEaterComponent.OnRep_AttachedCharacters
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class ASurvivalCharacter*>                  PreviousCharacters                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterMotionEaterComponent::OnRep_AttachedCharacters(TArray<class ASurvivalCharacter*> PreviousCharacters)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CharacterMotionEaterComponent.OnRep_AttachedCharacters");
		
		UCharacterMotionEaterComponent_OnRep_AttachedCharacters_Params params {};
		params.PreviousCharacters = PreviousCharacters;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CharacterMotionEaterComponent.HandleAttachedCharacterDestroyed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Sender                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterMotionEaterComponent::HandleAttachedCharacterDestroyed(class AActor* Sender)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CharacterMotionEaterComponent.HandleAttachedCharacterDestroyed");
		
		UCharacterMotionEaterComponent_HandleAttachedCharacterDestroyed_Params params {};
		params.Sender = Sender;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterMotionEaterComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterMotionEaterComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CharacterMotionEaterComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterSelectWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterSelectWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CharacterSelectWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ChatBoxWidget.HandleChatMessageReceived
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FChatBoxMessage                             Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UChatBoxWidget::HandleChatMessageReceived(const struct FChatBoxMessage& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ChatBoxWidget.HandleChatMessageReceived");
		
		UChatBoxWidget_HandleChatMessageReceived_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChatBoxWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChatBoxWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ChatBoxWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClimbableSplineComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClimbableSplineComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ClimbableSplineComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACollectible.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACollectible::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Collectible");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UColonyConfiguration.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UColonyConfiguration::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ColonyConfiguration");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ColonyManagerComponent.DebugDumpColonies
	 * 		Flags  -> ()
	 */
	void UColonyManagerComponent::DebugDumpColonies()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ColonyManagerComponent.DebugDumpColonies");
		
		UColonyManagerComponent_DebugDumpColonies_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UColonyManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UColonyManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ColonyManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ColonyMemberComponent.OnDeathCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UColonyMemberComponent::OnDeathCallback(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ColonyMemberComponent.OnDeathCallback");
		
		UColonyMemberComponent_OnDeathCallback_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ColonyMemberComponent.IsMemberOf
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FColonyIdentifier                           Identifier                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UColonyMemberComponent::IsMemberOf(const struct FColonyIdentifier& Identifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ColonyMemberComponent.IsMemberOf");
		
		UColonyMemberComponent_IsMemberOf_Params params {};
		params.Identifier = Identifier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ColonyMemberComponent.GetColonyIdentifier
	 * 		Flags  -> ()
	 */
	struct FColonyIdentifier UColonyMemberComponent::GetColonyIdentifier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ColonyMemberComponent.GetColonyIdentifier");
		
		UColonyMemberComponent_GetColonyIdentifier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UColonyMemberComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UColonyMemberComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ColonyMemberComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyColonyMemberComponent.IsMemberOf
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FColonyIdentifier                           ColonyId                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UProxyColonyMemberComponent::IsMemberOf(const struct FColonyIdentifier& ColonyId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyColonyMemberComponent.IsMemberOf");
		
		UProxyColonyMemberComponent_IsMemberOf_Params params {};
		params.ColonyId = ColonyId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyColonyMemberComponent.GetColonyIdentifier
	 * 		Flags  -> ()
	 */
	struct FColonyIdentifier UProxyColonyMemberComponent::GetColonyIdentifier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyColonyMemberComponent.GetColonyIdentifier");
		
		UProxyColonyMemberComponent_GetColonyIdentifier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyColonyMemberComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyColonyMemberComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyColonyMemberComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ColonyMemberLODComponent.IsMemberOf
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FColonyIdentifier                           ColonyId                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UColonyMemberLODComponent::IsMemberOf(const struct FColonyIdentifier& ColonyId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ColonyMemberLODComponent.IsMemberOf");
		
		UColonyMemberLODComponent_IsMemberOf_Params params {};
		params.ColonyId = ColonyId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ColonyMemberLODComponent.GetColonyIdentifier
	 * 		Flags  -> ()
	 */
	struct FColonyIdentifier UColonyMemberLODComponent::GetColonyIdentifier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ColonyMemberLODComponent.GetColonyIdentifier");
		
		UColonyMemberLODComponent_GetColonyIdentifier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UColonyMemberLODComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UColonyMemberLODComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ColonyMemberLODComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AColorCollectible.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AColorCollectible::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ColorCollectible");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyColorCollectibleActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyColorCollectibleActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyColorCollectibleActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UColorCollectibleLODActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UColorCollectibleLODActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ColorCollectibleLODActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CombinedLadder.OnRep_SplinePoints
	 * 		Flags  -> ()
	 */
	void ACombinedLadder::OnRep_SplinePoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CombinedLadder.OnRep_SplinePoints");
		
		ACombinedLadder_OnRep_SplinePoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACombinedLadder.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACombinedLadder::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CombinedLadder");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCombinedMeshAssetUserData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCombinedMeshAssetUserData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CombinedMeshAssetUserData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Conditionals.TechChipAvailableForSpeaker
	 * 		Flags  -> ()
	 */
	bool UConditionals::TechChipAvailableForSpeaker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Conditionals.TechChipAvailableForSpeaker");
		
		UConditionals_TechChipAvailableForSpeaker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Conditionals.IsPartySize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EComparisonOperator                                Operator                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UConditionals::IsPartySize(EComparisonOperator Operator, int32_t Size)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Conditionals.IsPartySize");
		
		UConditionals_IsPartySize_Params params {};
		params.Operator = Operator;
		params.Size = Size;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Conditionals.IsOwnerTheSpeaker
	 * 		Flags  -> ()
	 */
	bool UConditionals::IsOwnerTheSpeaker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Conditionals.IsOwnerTheSpeaker");
		
		UConditionals_IsOwnerTheSpeaker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Conditionals.IsInSpeakingRange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       CharacterA                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPlayerCharacterIdentity                           CharacterB                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UConditionals::IsInSpeakingRange(const struct FGuid& CharacterA, EPlayerCharacterIdentity CharacterB)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Conditionals.IsInSpeakingRange");
		
		UConditionals_IsInSpeakingRange_Params params {};
		params.CharacterA = CharacterA;
		params.CharacterB = CharacterB;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Conditionals.IsInParty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerCharacterIdentity                           Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UConditionals::IsInParty(EPlayerCharacterIdentity Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Conditionals.IsInParty");
		
		UConditionals_IsInParty_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Conditionals.IsAnyPartyMemberInSpeakingRange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       Character                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UConditionals::IsAnyPartyMemberInSpeakingRange(const struct FGuid& Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Conditionals.IsAnyPartyMemberInSpeakingRange");
		
		UConditionals_IsAnyPartyMemberInSpeakingRange_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Conditionals.HasPartyOrPersonalUpgradeBeenCollected
	 * 		Flags  -> ()
	 */
	bool UConditionals::HasPartyOrPersonalUpgradeBeenCollected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Conditionals.HasPartyOrPersonalUpgradeBeenCollected");
		
		UConditionals_HasPartyOrPersonalUpgradeBeenCollected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConditionals.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConditionals::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Conditionals");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConditionalToggleComponent.OnRep_Enabled
	 * 		Flags  -> ()
	 */
	void UConditionalToggleComponent::OnRep_Enabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConditionalToggleComponent.OnRep_Enabled");
		
		UConditionalToggleComponent_OnRep_Enabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConditionalToggleComponent.OnHourChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewHour                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewDay                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConditionalToggleComponent::OnHourChanged(int32_t NewHour, int32_t NewDay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConditionalToggleComponent.OnHourChanged");
		
		UConditionalToggleComponent_OnHourChanged_Params params {};
		params.NewHour = NewHour;
		params.NewDay = NewDay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConditionalToggleComponent.OnGlobalVariableChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       GlobalVariableID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            VariableValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConditionalToggleComponent::OnGlobalVariableChanged(const struct FGuid& GlobalVariableID, int32_t VariableValue, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConditionalToggleComponent.OnGlobalVariableChanged");
		
		UConditionalToggleComponent_OnGlobalVariableChanged_Params params {};
		params.GlobalVariableID = GlobalVariableID;
		params.VariableValue = VariableValue;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConditionalToggleComponent.IsEnabled
	 * 		Flags  -> ()
	 */
	bool UConditionalToggleComponent::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConditionalToggleComponent.IsEnabled");
		
		UConditionalToggleComponent_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConditionalToggleComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConditionalToggleComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ConditionalToggleComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ContextMenuEntryWidget.SetIsValid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UContextMenuEntryWidget::SetIsValid(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ContextMenuEntryWidget.SetIsValid");
		
		UContextMenuEntryWidget_SetIsValid_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ContextMenuEntryWidget.OnSetIsValid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UContextMenuEntryWidget::OnSetIsValid(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ContextMenuEntryWidget.OnSetIsValid");
		
		UContextMenuEntryWidget_OnSetIsValid_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UContextMenuEntryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UContextMenuEntryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ContextMenuEntryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ContextMenuWidget.SetFocusFirst
	 * 		Flags  -> ()
	 */
	void UContextMenuWidget::SetFocusFirst()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ContextMenuWidget.SetFocusFirst");
		
		UContextMenuWidget_SetFocusFirst_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ContextMenuWidget.NotifyOptionSelected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                Action                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UContextMenuWidget::NotifyOptionSelected(const struct FGameplayTag& Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ContextMenuWidget.NotifyOptionSelected");
		
		UContextMenuWidget_NotifyOptionSelected_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ContextMenuWidget.AddEntry
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FContextEntry                               Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UContextMenuEntryWidget* UContextMenuWidget::AddEntry(const struct FContextEntry& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ContextMenuWidget.AddEntry");
		
		UContextMenuWidget_AddEntry_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UContextMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UContextMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ContextMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.UnbindGame
	 * 		Flags  -> ()
	 */
	void UControlOptions::UnbindGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.UnbindGame");
		
		UControlOptions_UnbindGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.SetSprintToggle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewSprintToggle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlOptions::SetSprintToggle(bool bNewSprintToggle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.SetSprintToggle");
		
		UControlOptions_SetSprintToggle_Params params {};
		params.bNewSprintToggle = bNewSprintToggle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.SetSensitivityY
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewSensitivity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlOptions::SetSensitivityY(float NewSensitivity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.SetSensitivityY");
		
		UControlOptions_SetSensitivityY_Params params {};
		params.NewSensitivity = NewSensitivity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.SetSensitivityX
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewSensitivity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlOptions::SetSensitivityX(float NewSensitivity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.SetSensitivityX");
		
		UControlOptions_SetSensitivityX_Params params {};
		params.NewSensitivity = NewSensitivity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.SetSensitivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector2D                                   NewSensitivity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlOptions::SetSensitivity(const struct FVector2D& NewSensitivity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.SetSensitivity");
		
		UControlOptions_SetSensitivity_Params params {};
		params.NewSensitivity = NewSensitivity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.SetInvertY
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               NewInvertY                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlOptions::SetInvertY(bool NewInvertY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.SetInvertY");
		
		UControlOptions_SetInvertY_Params params {};
		params.NewInvertY = NewInvertY;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.SetInvertX
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               NewInvertX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlOptions::SetInvertX(bool NewInvertX)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.SetInvertX");
		
		UControlOptions_SetInvertX_Params params {};
		params.NewInvertX = NewInvertX;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.SetGlideToggle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewGlideToggle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlOptions::SetGlideToggle(bool bNewGlideToggle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.SetGlideToggle");
		
		UControlOptions_SetGlideToggle_Params params {};
		params.bNewGlideToggle = bNewGlideToggle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.SetDefaults
	 * 		Flags  -> ()
	 */
	void UControlOptions::SetDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.SetDefaults");
		
		UControlOptions_SetDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.SetCrouchToggle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewCrouchToggle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlOptions::SetCrouchToggle(bool bNewCrouchToggle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.SetCrouchToggle");
		
		UControlOptions_SetCrouchToggle_Params params {};
		params.bNewCrouchToggle = bNewCrouchToggle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.Save
	 * 		Flags  -> ()
	 */
	void UControlOptions::Save()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.Save");
		
		UControlOptions_Save_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.Load
	 * 		Flags  -> ()
	 */
	void UControlOptions::Load()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.Load");
		
		UControlOptions_Load_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.GetSprintToggle
	 * 		Flags  -> ()
	 */
	bool UControlOptions::GetSprintToggle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.GetSprintToggle");
		
		UControlOptions_GetSprintToggle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.GetSensitivity
	 * 		Flags  -> ()
	 */
	struct FVector2D UControlOptions::GetSensitivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.GetSensitivity");
		
		UControlOptions_GetSensitivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.GetInvertY
	 * 		Flags  -> ()
	 */
	bool UControlOptions::GetInvertY()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.GetInvertY");
		
		UControlOptions_GetInvertY_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.GetInvertX
	 * 		Flags  -> ()
	 */
	bool UControlOptions::GetInvertX()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.GetInvertX");
		
		UControlOptions_GetInvertX_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.GetGlideToggle
	 * 		Flags  -> ()
	 */
	bool UControlOptions::GetGlideToggle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.GetGlideToggle");
		
		UControlOptions_GetGlideToggle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.GetCrouchToggle
	 * 		Flags  -> ()
	 */
	bool UControlOptions::GetCrouchToggle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.GetCrouchToggle");
		
		UControlOptions_GetCrouchToggle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlOptions.BindGame
	 * 		Flags  -> ()
	 */
	void UControlOptions::BindGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlOptions.BindGame");
		
		UControlOptions_BindGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UControlOptions.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UControlOptions::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ControlOptions");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetInteractComponent.OnInteractingActorDestroyed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidgetInteractComponent::OnInteractingActorDestroyed(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetInteractComponent.OnInteractingActorDestroyed");
		
		UWidgetInteractComponent_OnInteractingActorDestroyed_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetInteractComponent.IsBusy
	 * 		Flags  -> ()
	 */
	bool UWidgetInteractComponent::IsBusy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetInteractComponent.IsBusy");
		
		UWidgetInteractComponent_IsBusy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWidgetInteractComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWidgetInteractComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WidgetInteractComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationComponent.StartConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationComponent::StartConversation(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationComponent.StartConversation");
		
		UConversationComponent_StartConversation_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationComponent.EndConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationComponent::EndConversation(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationComponent.EndConversation");
		
		UConversationComponent_EndConversation_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConversationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConversationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ConversationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.StartLocalConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGuid                                       ConversationID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NodeId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::StartLocalConversation(class AActor* OwnerActor, const struct FGuid& ConversationID, int32_t NodeId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.StartLocalConversation");
		
		UConversationNavigatorComponent_StartLocalConversation_Params params {};
		params.OwnerActor = OwnerActor;
		params.ConversationID = ConversationID;
		params.NodeId = NodeId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.ShowConversation
	 * 		Flags  -> ()
	 */
	bool UConversationNavigatorComponent::ShowConversation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.ShowConversation");
		
		UConversationNavigatorComponent_ShowConversation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.ShouldQueue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       ConversationID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EConversationPlayPriority                          Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UConversationNavigatorComponent::ShouldQueue(const struct FGuid& ConversationID, EConversationPlayPriority Priority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.ShouldQueue");
		
		UConversationNavigatorComponent_ShouldQueue_Params params {};
		params.ConversationID = ConversationID;
		params.Priority = Priority;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.ShouldInterrupt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       ConversationID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EConversationPlayPriority                          Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UConversationNavigatorComponent::ShouldInterrupt(const struct FGuid& ConversationID, EConversationPlayPriority Priority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.ShouldInterrupt");
		
		UConversationNavigatorComponent_ShouldInterrupt_Params params {};
		params.ConversationID = ConversationID;
		params.Priority = Priority;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.ServerStartConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGuid                                       ConversationID                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NodeId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EConversationPlayPriority                          Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EConversationNodeDisplayStyle                      DisplayStyle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::ServerStartConversation(class AActor* OwnerActor, const struct FGuid& ConversationID, int32_t NodeId, EConversationPlayPriority Priority, EConversationNodeDisplayStyle DisplayStyle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.ServerStartConversation");
		
		UConversationNavigatorComponent_ServerStartConversation_Params params {};
		params.OwnerActor = OwnerActor;
		params.ConversationID = ConversationID;
		params.NodeId = NodeId;
		params.Priority = Priority;
		params.DisplayStyle = DisplayStyle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.ServerSelectPlayerResponse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ResponseNodeID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::ServerSelectPlayerResponse(class AActor* Owner, int32_t ResponseNodeID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.ServerSelectPlayerResponse");
		
		UConversationNavigatorComponent_ServerSelectPlayerResponse_Params params {};
		params.Owner = Owner;
		params.ResponseNodeID = ResponseNodeID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.ServerEndPlayerDrivenConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::ServerEndPlayerDrivenConversation(class AActor* Owner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.ServerEndPlayerDrivenConversation");
		
		UConversationNavigatorComponent_ServerEndPlayerDrivenConversation_Params params {};
		params.Owner = Owner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.ServerEndConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       ConversationID                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::ServerEndConversation(const struct FGuid& ConversationID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.ServerEndConversation");
		
		UConversationNavigatorComponent_ServerEndConversation_Params params {};
		params.ConversationID = ConversationID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.ServerAdvancePlayerDrivenConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::ServerAdvancePlayerDrivenConversation(class AActor* Owner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.ServerAdvancePlayerDrivenConversation");
		
		UConversationNavigatorComponent_ServerAdvancePlayerDrivenConversation_Params params {};
		params.Owner = Owner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.ServerAdvanceConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       ConversationID                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::ServerAdvanceConversation(const struct FGuid& ConversationID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.ServerAdvanceConversation");
		
		UConversationNavigatorComponent_ServerAdvanceConversation_Params params {};
		params.ConversationID = ConversationID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.ServerAbortConversations
	 * 		Flags  -> ()
	 */
	void UConversationNavigatorComponent::ServerAbortConversations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.ServerAbortConversations");
		
		UConversationNavigatorComponent_ServerAbortConversations_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.RemovePlayerDrivenConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::RemovePlayerDrivenConversation(class AActor* Owner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.RemovePlayerDrivenConversation");
		
		UConversationNavigatorComponent_RemovePlayerDrivenConversation_Params params {};
		params.Owner = Owner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.QueueConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGuid                                       ConversationID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NodeId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EConversationPlayPriority                          Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EConversationNodeDisplayStyle                      DisplayStyle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::QueueConversation(class AActor* OwnerActor, const struct FGuid& ConversationID, int32_t NodeId, EConversationPlayPriority Priority, EConversationNodeDisplayStyle DisplayStyle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.QueueConversation");
		
		UConversationNavigatorComponent_QueueConversation_Params params {};
		params.OwnerActor = OwnerActor;
		params.ConversationID = ConversationID;
		params.NodeId = NodeId;
		params.Priority = Priority;
		params.DisplayStyle = DisplayStyle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.MulticastStartConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EConversationNodeDisplayStyle                      DisplayStyle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::MulticastStartConversation(EConversationNodeDisplayStyle DisplayStyle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.MulticastStartConversation");
		
		UConversationNavigatorComponent_MulticastStartConversation_Params params {};
		params.DisplayStyle = DisplayStyle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.MulticastPlayChatterNode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NodeId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::MulticastPlayChatterNode(class ASurvivalCharacter* OwnerActor, int32_t NodeId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.MulticastPlayChatterNode");
		
		UConversationNavigatorComponent_MulticastPlayChatterNode_Params params {};
		params.OwnerActor = OwnerActor;
		params.NodeId = NodeId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.MulticastEndConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       ConversationID                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::MulticastEndConversation(const struct FGuid& ConversationID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.MulticastEndConversation");
		
		UConversationNavigatorComponent_MulticastEndConversation_Params params {};
		params.ConversationID = ConversationID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.MulticastAdvanceConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGuid                                       ConversationID                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NodeId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EConversationNodeDisplayStyle                      DisplayStyle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::MulticastAdvanceConversation(class AActor* OwnerActor, const struct FGuid& ConversationID, int32_t NodeId, EConversationNodeDisplayStyle DisplayStyle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.MulticastAdvanceConversation");
		
		UConversationNavigatorComponent_MulticastAdvanceConversation_Params params {};
		params.OwnerActor = OwnerActor;
		params.ConversationID = ConversationID;
		params.NodeId = NodeId;
		params.DisplayStyle = DisplayStyle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.IsPlayerDrivenNode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EConversationNodeDisplayStyle                      DisplayStyle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGuid                                       ConversationNavigatorID                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UConversationNavigatorComponent::IsPlayerDrivenNode(EConversationNodeDisplayStyle DisplayStyle, const struct FGuid& ConversationNavigatorID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.IsPlayerDrivenNode");
		
		UConversationNavigatorComponent_IsPlayerDrivenNode_Params params {};
		params.DisplayStyle = DisplayStyle;
		params.ConversationNavigatorID = ConversationNavigatorID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.IsPlayerDrivenConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EConversationNodeDisplayStyle                      DisplayStyle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UConversationNavigatorComponent::IsPlayerDrivenConversation(EConversationNodeDisplayStyle DisplayStyle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.IsPlayerDrivenConversation");
		
		UConversationNavigatorComponent_IsPlayerDrivenConversation_Params params {};
		params.DisplayStyle = DisplayStyle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.GetConversationQueue
	 * 		Flags  -> ()
	 */
	TArray<struct FConversationPlayData> UConversationNavigatorComponent::GetConversationQueue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.GetConversationQueue");
		
		UConversationNavigatorComponent_GetConversationQueue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.EndConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       ConversationID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bViaStartNewConversation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::EndConversation(const struct FGuid& ConversationID, bool bViaStartNewConversation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.EndConversation");
		
		UConversationNavigatorComponent_EndConversation_Params params {};
		params.ConversationID = ConversationID;
		params.bViaStartNewConversation = bViaStartNewConversation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.AdvanceConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGuid                                       ConversationID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NodeId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EConversationNodeDisplayStyle                      DisplayStyle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::AdvanceConversation(class AActor* OwnerActor, const struct FGuid& ConversationID, int32_t NodeId, EConversationNodeDisplayStyle DisplayStyle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.AdvanceConversation");
		
		UConversationNavigatorComponent_AdvanceConversation_Params params {};
		params.OwnerActor = OwnerActor;
		params.ConversationID = ConversationID;
		params.NodeId = NodeId;
		params.DisplayStyle = DisplayStyle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationNavigatorComponent.AddPlayerDrivenConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FActiveConversationData                     Convo                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UConversationNavigatorComponent::AddPlayerDrivenConversation(const struct FActiveConversationData& Convo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationNavigatorComponent.AddPlayerDrivenConversation");
		
		UConversationNavigatorComponent_AddPlayerDrivenConversation_Params params {};
		params.Convo = Convo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConversationNavigatorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConversationNavigatorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ConversationNavigatorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractionWidget.HandleInitialize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractionWidget::HandleInitialize(class AActor* TargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractionWidget.HandleInitialize");
		
		UInteractionWidget_HandleInitialize_Params params {};
		params.TargetActor = TargetActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractionWidget.GetInteractableActor
	 * 		Flags  -> ()
	 */
	class AActor* UInteractionWidget::GetInteractableActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractionWidget.GetInteractableActor");
		
		UInteractionWidget_GetInteractableActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInteractionWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInteractionWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.InteractionWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationWidget.SelectPlayerResponse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ResponseIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversationWidget::SelectPlayerResponse(int32_t ResponseIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationWidget.SelectPlayerResponse");
		
		UConversationWidget_SelectPlayerResponse_Params params {};
		params.ResponseIndex = ResponseIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationWidget.GetPlayerResponses
	 * 		Flags  -> ()
	 */
	TArray<struct FPlayerResponseData> UConversationWidget::GetPlayerResponses()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationWidget.GetPlayerResponses");
		
		UConversationWidget_GetPlayerResponses_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationWidget.EndConversation
	 * 		Flags  -> ()
	 */
	void UConversationWidget::EndConversation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationWidget.EndConversation");
		
		UConversationWidget_EndConversation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ConversationWidget.ContinueConversation
	 * 		Flags  -> ()
	 */
	void UConversationWidget::ContinueConversation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ConversationWidget.ContinueConversation");
		
		UConversationWidget_ContinueConversation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConversationWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConversationWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ConversationWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CozinessEvaluatorComponent.OnRep_StructuralValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCozinessEvaluatorComponent::OnRep_StructuralValue(int32_t OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CozinessEvaluatorComponent.OnRep_StructuralValue");
		
		UCozinessEvaluatorComponent_OnRep_StructuralValue_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CozinessEvaluatorComponent.OnRep_CozinessValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCozinessEvaluatorComponent::OnRep_CozinessValue(int32_t OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CozinessEvaluatorComponent.OnRep_CozinessValue");
		
		UCozinessEvaluatorComponent_OnRep_CozinessValue_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CozinessEvaluatorComponent.GetCozinessValue
	 * 		Flags  -> ()
	 */
	int32_t UCozinessEvaluatorComponent::GetCozinessValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CozinessEvaluatorComponent.GetCozinessValue");
		
		UCozinessEvaluatorComponent_GetCozinessValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CozinessEvaluatorComponent.GetCozinessLevel
	 * 		Flags  -> ()
	 */
	int32_t UCozinessEvaluatorComponent::GetCozinessLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CozinessEvaluatorComponent.GetCozinessLevel");
		
		UCozinessEvaluatorComponent_GetCozinessLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCozinessEvaluatorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCozinessEvaluatorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CozinessEvaluatorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWidgetBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWidgetBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WidgetBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CozinessSamplerBuilding.K2_HandleCozinessValueChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACozinessSamplerBuilding::K2_HandleCozinessValueChanged(int32_t OldValue, int32_t NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CozinessSamplerBuilding.K2_HandleCozinessValueChanged");
		
		ACozinessSamplerBuilding_K2_HandleCozinessValueChanged_Params params {};
		params.OldValue = OldValue;
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CozinessSamplerBuilding.K2_HandleCozinessLevelChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            OldLevel                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewLevel                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACozinessSamplerBuilding::K2_HandleCozinessLevelChanged(int32_t OldLevel, int32_t NewLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CozinessSamplerBuilding.K2_HandleCozinessLevelChanged");
		
		ACozinessSamplerBuilding_K2_HandleCozinessLevelChanged_Params params {};
		params.OldLevel = OldLevel;
		params.NewLevel = NewLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CozinessSamplerBuilding.HandleCozinessValueChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCozinessEvaluatorComponent*                 Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACozinessSamplerBuilding::HandleCozinessValueChanged(class UCozinessEvaluatorComponent* Sender, int32_t OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CozinessSamplerBuilding.HandleCozinessValueChanged");
		
		ACozinessSamplerBuilding_HandleCozinessValueChanged_Params params {};
		params.Sender = Sender;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CozinessSamplerBuilding.HandleCozinessLevelChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCozinessEvaluatorComponent*                 Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldLevel                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACozinessSamplerBuilding::HandleCozinessLevelChanged(class UCozinessEvaluatorComponent* Sender, int32_t OldLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CozinessSamplerBuilding.HandleCozinessLevelChanged");
		
		ACozinessSamplerBuilding_HandleCozinessLevelChanged_Params params {};
		params.Sender = Sender;
		params.OldLevel = OldLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACozinessSamplerBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACozinessSamplerBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CozinessSamplerBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CraftingBuilding.GetCraftingBuildingType
	 * 		Flags  -> ()
	 */
	struct FGameplayTag ACraftingBuilding::GetCraftingBuildingType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CraftingBuilding.GetCraftingBuildingType");
		
		ACraftingBuilding_GetCraftingBuildingType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACraftingBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACraftingBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CraftingBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CraftingInterfaceWidget.OnSelectionChanged
	 * 		Flags  -> ()
	 */
	void UCraftingInterfaceWidget::OnSelectionChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CraftingInterfaceWidget.OnSelectionChanged");
		
		UCraftingInterfaceWidget_OnSelectionChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CraftingInterfaceWidget.OnPageOpened
	 * 		Flags  -> ()
	 */
	void UCraftingInterfaceWidget::OnPageOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CraftingInterfaceWidget.OnPageOpened");
		
		UCraftingInterfaceWidget_OnPageOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCraftingInterfaceWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCraftingInterfaceWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CraftingInterfaceWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCreateLobbyWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCreateLobbyWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CreateLobbyWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyCreatureActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyCreatureActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyCreatureActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CreatureLODActor.IsTame
	 * 		Flags  -> ()
	 */
	bool UCreatureLODActor::IsTame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CreatureLODActor.IsTame");
		
		UCreatureLODActor_IsTame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CreatureLODActor.HandleVitalChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInterestCore*                               Sender                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UVitalStat*                                  Stat                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCreatureLODActor::HandleVitalChanged(class UInterestCore* Sender, class UVitalStat* Stat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CreatureLODActor.HandleVitalChanged");
		
		UCreatureLODActor_HandleVitalChanged_Params params {};
		params.Sender = Sender;
		params.Stat = Stat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CreatureLODActor.HandleTameStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTamedCreatureData*                          Sender                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETamedState                                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCreatureLODActor::HandleTameStateChanged(class UTamedCreatureData* Sender, ETamedState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CreatureLODActor.HandleTameStateChanged");
		
		UCreatureLODActor_HandleTameStateChanged_Params params {};
		params.Sender = Sender;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CreatureLODActor.HandleSelfDeath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UCreatureLODActor::HandleSelfDeath(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CreatureLODActor.HandleSelfDeath");
		
		UCreatureLODActor_HandleSelfDeath_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CreatureLODActor.GetTamedState
	 * 		Flags  -> ()
	 */
	ETamedState UCreatureLODActor::GetTamedState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CreatureLODActor.GetTamedState");
		
		UCreatureLODActor_GetTamedState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CreatureLODActor.GetTamedCreatureData
	 * 		Flags  -> ()
	 */
	class UTamedCreatureData* UCreatureLODActor::GetTamedCreatureData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CreatureLODActor.GetTamedCreatureData");
		
		UCreatureLODActor_GetTamedCreatureData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CreatureLODActor.GetHappinessNormalized
	 * 		Flags  -> ()
	 */
	float UCreatureLODActor::GetHappinessNormalized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CreatureLODActor.GetHappinessNormalized");
		
		UCreatureLODActor_GetHappinessNormalized_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CreatureLODActor.GetActivePetPassiveEffects
	 * 		Flags  -> ()
	 */
	TArray<struct FDataTableRowHandle> UCreatureLODActor::GetActivePetPassiveEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CreatureLODActor.GetActivePetPassiveEffects");
		
		UCreatureLODActor_GetActivePetPassiveEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCreatureLODActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCreatureLODActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CreatureLODActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCreditsData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCreditsData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CreditsData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCreditsFormattingData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCreditsFormattingData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CreditsFormattingData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CreditsWidget.StopCredits
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bForced                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCreditsWidget::StopCredits(bool bForced)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CreditsWidget.StopCredits");
		
		UCreditsWidget_StopCredits_Params params {};
		params.bForced = bForced;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CreditsWidget.StartCredits
	 * 		Flags  -> ()
	 */
	void UCreditsWidget::StartCredits()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CreditsWidget.StartCredits");
		
		UCreditsWidget_StartCredits_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CreditsWidget.OnCreditsStarted
	 * 		Flags  -> ()
	 */
	void UCreditsWidget::OnCreditsStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CreditsWidget.OnCreditsStarted");
		
		UCreditsWidget_OnCreditsStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CreditsWidget.OnCreditsEnded
	 * 		Flags  -> ()
	 */
	void UCreditsWidget::OnCreditsEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CreditsWidget.OnCreditsEnded");
		
		UCreditsWidget_OnCreditsEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CreditsWidget.IsPlaying
	 * 		Flags  -> ()
	 */
	bool UCreditsWidget::IsPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CreditsWidget.IsPlaying");
		
		UCreditsWidget_IsPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCreditsWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCreditsWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CreditsWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomizeInteractionComponent.ShowCustomizationUI
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCustomPropertyComponent*                    CustomPropertyComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomizeInteractionComponent::ShowCustomizationUI(class UCustomPropertyComponent* CustomPropertyComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomizeInteractionComponent.ShowCustomizationUI");
		
		UCustomizeInteractionComponent_ShowCustomizationUI_Params params {};
		params.CustomPropertyComponent = CustomPropertyComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomizeInteractionComponent.ServerSetCustomPropertyComponentInUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCustomPropertyComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               InUse                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomizeInteractionComponent::ServerSetCustomPropertyComponentInUse(class UCustomPropertyComponent* Component, bool InUse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomizeInteractionComponent.ServerSetCustomPropertyComponentInUse");
		
		UCustomizeInteractionComponent_ServerSetCustomPropertyComponentInUse_Params params {};
		params.Component = Component;
		params.InUse = InUse;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomizeInteractionComponent.ServerOnCustomPropertyComponentChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCustomPropertyComponent*                    CustomPropertyComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PropertyValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomizeInteractionComponent::ServerOnCustomPropertyComponentChanged(class UCustomPropertyComponent* CustomPropertyComponent, const class FName& PropertyName, float PropertyValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomizeInteractionComponent.ServerOnCustomPropertyComponentChanged");
		
		UCustomizeInteractionComponent_ServerOnCustomPropertyComponentChanged_Params params {};
		params.CustomPropertyComponent = CustomPropertyComponent;
		params.PropertyName = PropertyName;
		params.PropertyValue = PropertyValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomizeInteractionComponent.OnCustomizeUIClosed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InteractableActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomizeInteractionComponent::OnCustomizeUIClosed(class AActor* InteractableActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomizeInteractionComponent.OnCustomizeUIClosed");
		
		UCustomizeInteractionComponent_OnCustomizeUIClosed_Params params {};
		params.InteractableActor = InteractableActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCustomizeInteractionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCustomizeInteractionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CustomizeInteractionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertiesWindowWidget.ResetToDefaults
	 * 		Flags  -> ()
	 */
	void UCustomPropertiesWindowWidget::ResetToDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertiesWindowWidget.ResetToDefaults");
		
		UCustomPropertiesWindowWidget_ResetToDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertiesWindowWidget.OnInputChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PropertyValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertiesWindowWidget::OnInputChanged(const class FName& PropertyName, float PropertyValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertiesWindowWidget.OnInputChanged");
		
		UCustomPropertiesWindowWidget_OnInputChanged_Params params {};
		params.PropertyName = PropertyName;
		params.PropertyValue = PropertyValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertiesWindowWidget.GetWidgetForProperty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Property                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UCustomPropertyWidget* UCustomPropertiesWindowWidget::GetWidgetForProperty(const class FName& Property)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertiesWindowWidget.GetWidgetForProperty");
		
		UCustomPropertiesWindowWidget_GetWidgetForProperty_Params params {};
		params.Property = Property;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCustomPropertiesWindowWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCustomPropertiesWindowWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CustomPropertiesWindowWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyComponent.SetIsInUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               InUse                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertyComponent::SetIsInUse(bool InUse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyComponent.SetIsInUse");
		
		UCustomPropertyComponent_SetIsInUse_Params params {};
		params.InUse = InUse;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyComponent.SetCustomPropertyValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertyComponent::SetCustomPropertyValue(const class FName& PropertyName, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyComponent.SetCustomPropertyValue");
		
		UCustomPropertyComponent_SetCustomPropertyValue_Params params {};
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyComponent.OnUIReady
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCustomPropertiesWindowWidget*               Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertyComponent::OnUIReady(class UCustomPropertiesWindowWidget* Widget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyComponent.OnUIReady");
		
		UCustomPropertyComponent_OnUIReady_Params params {};
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyComponent.OnRep_CustomizedValuesArray
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FCustomizedValue>                    PreviousCustomizedValuesArray                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertyComponent::OnRep_CustomizedValuesArray(TArray<struct FCustomizedValue> PreviousCustomizedValuesArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyComponent.OnRep_CustomizedValuesArray");
		
		UCustomPropertyComponent_OnRep_CustomizedValuesArray_Params params {};
		params.PreviousCustomizedValuesArray = PreviousCustomizedValuesArray;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyComponent.NeedsManualValueTextUpdates
	 * 		Flags  -> ()
	 */
	bool UCustomPropertyComponent::NeedsManualValueTextUpdates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyComponent.NeedsManualValueTextUpdates");
		
		UCustomPropertyComponent_NeedsManualValueTextUpdates_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyComponent.NativeOnPropertyChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PropertyValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertyComponent::NativeOnPropertyChanged(const class FName& PropertyName, float PropertyValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyComponent.NativeOnPropertyChanged");
		
		UCustomPropertyComponent_NativeOnPropertyChanged_Params params {};
		params.PropertyName = PropertyName;
		params.PropertyValue = PropertyValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyComponent.IsPropertyCustomized
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Property                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCustomPropertyComponent::IsPropertyCustomized(const class FName& Property)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyComponent.IsPropertyCustomized");
		
		UCustomPropertyComponent_IsPropertyCustomized_Params params {};
		params.Property = Property;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyComponent.HasCustomProperties
	 * 		Flags  -> ()
	 */
	bool UCustomPropertyComponent::HasCustomProperties()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyComponent.HasCustomProperties");
		
		UCustomPropertyComponent_HasCustomProperties_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyComponent.GetIsInUse
	 * 		Flags  -> ()
	 */
	bool UCustomPropertyComponent::GetIsInUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyComponent.GetIsInUse");
		
		UCustomPropertyComponent_GetIsInUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyComponent.GetCustomPropertyValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AsFloat                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            AsInt                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               AsBool                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertyComponent::GetCustomPropertyValue(const class FName& PropertyName, float* AsFloat, int32_t* AsInt, bool* AsBool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyComponent.GetCustomPropertyValue");
		
		UCustomPropertyComponent_GetCustomPropertyValue_Params params {};
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (AsFloat != nullptr)
			*AsFloat = params.AsFloat;
		if (AsInt != nullptr)
			*AsInt = params.AsInt;
		if (AsBool != nullptr)
			*AsBool = params.AsBool;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyComponent.GetCameraInterestLocation
	 * 		Flags  -> ()
	 */
	struct FVector UCustomPropertyComponent::GetCameraInterestLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyComponent.GetCameraInterestLocation");
		
		UCustomPropertyComponent_GetCameraInterestLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCustomPropertyComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCustomPropertyComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CustomPropertyComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCustomPropertyDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCustomPropertyDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CustomPropertyDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyWidget.SetInputStyles
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECustomPropertyInputType                           InputType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertyWidget::SetInputStyles(ECustomPropertyInputType InputType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyWidget.SetInputStyles");
		
		UCustomPropertyWidget_SetInputStyles_Params params {};
		params.InputType = InputType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyWidget.SetEnabledState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertyWidget::SetEnabledState(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyWidget.SetEnabledState");
		
		UCustomPropertyWidget_SetEnabledState_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyWidget.SetComboBoxOptions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FLocString>                          InOptions                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertyWidget::SetComboBoxOptions(TArray<struct FLocString> InOptions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyWidget.SetComboBoxOptions");
		
		UCustomPropertyWidget_SetComboBoxOptions_Params params {};
		params.InOptions = InOptions;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyWidget.ResetToDefaults
	 * 		Flags  -> ()
	 */
	void UCustomPropertyWidget::ResetToDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyWidget.ResetToDefaults");
		
		UCustomPropertyWidget_ResetToDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyWidget.OnSliderValueChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertyWidget::OnSliderValueChanged(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyWidget.OnSliderValueChanged");
		
		UCustomPropertyWidget_OnSliderValueChanged_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyWidget.OnSettingChangedSlider
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertyWidget::OnSettingChangedSlider(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyWidget.OnSettingChangedSlider");
		
		UCustomPropertyWidget_OnSettingChangedSlider_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyWidget.OnSettingChangedComboBox
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SelectedItem                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESelectInfo                                        SelectionType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertyWidget::OnSettingChangedComboBox(const class FString& SelectedItem, ESelectInfo SelectionType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyWidget.OnSettingChangedComboBox");
		
		UCustomPropertyWidget_OnSettingChangedComboBox_Params params {};
		params.SelectedItem = SelectedItem;
		params.SelectionType = SelectionType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyWidget.OnSettingChangedCheckBox
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bChecked                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertyWidget::OnSettingChangedCheckBox(bool bChecked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyWidget.OnSettingChangedCheckBox");
		
		UCustomPropertyWidget_OnSettingChangedCheckBox_Params params {};
		params.bChecked = bChecked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CustomPropertyWidget.OnEnabledChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomPropertyWidget::OnEnabledChanged(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CustomPropertyWidget.OnEnabledChanged");
		
		UCustomPropertyWidget_OnEnabledChanged_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCustomPropertyWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCustomPropertyWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CustomPropertyWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ActiveCutscene.OnLevelSequenceFinished
	 * 		Flags  -> ()
	 */
	void UActiveCutscene::OnLevelSequenceFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ActiveCutscene.OnLevelSequenceFinished");
		
		UActiveCutscene_OnLevelSequenceFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ActiveCutscene.OnInitialCameraCut
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCameraComponent*                            CameraComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActiveCutscene::OnInitialCameraCut(class UCameraComponent* CameraComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ActiveCutscene.OnInitialCameraCut");
		
		UActiveCutscene_OnInitialCameraCut_Params params {};
		params.CameraComponent = CameraComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActiveCutscene.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActiveCutscene::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ActiveCutscene");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CutsceneComponent.StartCutscene
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCutsceneDataAsset*                          CutsceneData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TriggerActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCutsceneComponent::StartCutscene(class UCutsceneDataAsset* CutsceneData, class AActor* TriggerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CutsceneComponent.StartCutscene");
		
		UCutsceneComponent_StartCutscene_Params params {};
		params.CutsceneData = CutsceneData;
		params.TriggerActor = TriggerActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.CutsceneComponent.MulticastStartCutscene
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCutsceneDataAsset*                          CutsceneData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TriggerActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCutsceneComponent::MulticastStartCutscene(class UCutsceneDataAsset* CutsceneData, class AActor* TriggerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.CutsceneComponent.MulticastStartCutscene");
		
		UCutsceneComponent_MulticastStartCutscene_Params params {};
		params.CutsceneData = CutsceneData;
		params.TriggerActor = TriggerActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCutsceneComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCutsceneComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CutsceneComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCutsceneDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCutsceneDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.CutsceneDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.DamageInfoBlueprintFunction.GetLODActorDamageSource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* UDamageInfoBlueprintFunction::GetLODActorDamageSource(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.DamageInfoBlueprintFunction.GetLODActorDamageSource");
		
		UDamageInfoBlueprintFunction_GetLODActorDamageSource_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.DamageInfoBlueprintFunction.GetDeathMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerState*                                OwnerPlayerState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDeathInfo                                  DeathInfo                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FString                                      OutText                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceDeathMessage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageInfoBlueprintFunction::GetDeathMessage(class APlayerState* OwnerPlayerState, const struct FDeathInfo& DeathInfo, class FString* OutText, bool bForceDeathMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.DamageInfoBlueprintFunction.GetDeathMessage");
		
		UDamageInfoBlueprintFunction_GetDeathMessage_Params params {};
		params.OwnerPlayerState = OwnerPlayerState;
		params.DeathInfo = DeathInfo;
		params.bForceDeathMessage = bForceDeathMessage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutText != nullptr)
			*OutText = params.OutText;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.DamageInfoBlueprintFunction.GetActorDamageSource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AActor* UDamageInfoBlueprintFunction::GetActorDamageSource(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.DamageInfoBlueprintFunction.GetActorDamageSource");
		
		UDamageInfoBlueprintFunction_GetActorDamageSource_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageInfoBlueprintFunction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageInfoBlueprintFunction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.DamageInfoBlueprintFunction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.DamageSwitch.SetCurrentState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADamageSwitch::SetCurrentState(int32_t NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.DamageSwitch.SetCurrentState");
		
		ADamageSwitch_SetCurrentState_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.DamageSwitch.OnRep_CurrentState
	 * 		Flags  -> ()
	 */
	void ADamageSwitch::OnRep_CurrentState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.DamageSwitch.OnRep_CurrentState");
		
		ADamageSwitch_OnRep_CurrentState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.DamageSwitch.OnDamaged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsKillingBlow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADamageSwitch::OnDamaged(float Damage, const struct FDamageInfo& DamageInfo, class AController* InstigatedBy, class UBaseLODActor* DamageCauser, bool IsKillingBlow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.DamageSwitch.OnDamaged");
		
		ADamageSwitch_OnDamaged_Params params {};
		params.Damage = Damage;
		params.DamageInfo = DamageInfo;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		params.IsKillingBlow = IsKillingBlow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.DamageSwitch.GetCurrentState
	 * 		Flags  -> ()
	 */
	int32_t ADamageSwitch::GetCurrentState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.DamageSwitch.GetCurrentState");
		
		ADamageSwitch_GetCurrentState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADamageSwitch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADamageSwitch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.DamageSwitch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.DeathCountdownWidget.NotifyElementDeactivated
	 * 		Flags  -> ()
	 */
	void UDeathCountdownWidget::NotifyElementDeactivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.DeathCountdownWidget.NotifyElementDeactivated");
		
		UDeathCountdownWidget_NotifyElementDeactivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.DeathCountdownWidget.NotifyElementActivated
	 * 		Flags  -> ()
	 */
	void UDeathCountdownWidget::NotifyElementActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.DeathCountdownWidget.NotifyElementActivated");
		
		UDeathCountdownWidget_NotifyElementActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDeathCountdownWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDeathCountdownWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.DeathCountdownWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.DefenseScalingData.GetStunDurationMultiplier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PlayerCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UDefenseScalingData::GetStunDurationMultiplier(int32_t PlayerCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.DefenseScalingData.GetStunDurationMultiplier");
		
		UDefenseScalingData_GetStunDurationMultiplier_Params params {};
		params.PlayerCount = PlayerCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.DefenseScalingData.GetMaxStunMultiplier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PlayerCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UDefenseScalingData::GetMaxStunMultiplier(int32_t PlayerCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.DefenseScalingData.GetMaxStunMultiplier");
		
		UDefenseScalingData_GetMaxStunMultiplier_Params params {};
		params.PlayerCount = PlayerCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.DefenseScalingData.GetMaxHealthMultiplier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PlayerCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UDefenseScalingData::GetMaxHealthMultiplier(int32_t PlayerCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.DefenseScalingData.GetMaxHealthMultiplier");
		
		UDefenseScalingData_GetMaxHealthMultiplier_Params params {};
		params.PlayerCount = PlayerCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.DefenseScalingData.GetDamageResistanceMultiplier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PlayerCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UDefenseScalingData::GetDamageResistanceMultiplier(int32_t PlayerCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.DefenseScalingData.GetDamageResistanceMultiplier");
		
		UDefenseScalingData_GetDamageResistanceMultiplier_Params params {};
		params.PlayerCount = PlayerCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDefenseScalingData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDefenseScalingData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.DefenseScalingData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDirectionalAnimEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDirectionalAnimEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.DirectionalAnimEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADivingSpiderNest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADivingSpiderNest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.DivingSpiderNest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Door.OnUpdateVisualState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsOpen                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::OnUpdateVisualState(bool IsOpen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Door.OnUpdateVisualState");
		
		ADoor_OnUpdateVisualState_Params params {};
		params.IsOpen = IsOpen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Door.OnTimelineCoreEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::OnTimelineCoreEvent(int32_t Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Door.OnTimelineCoreEvent");
		
		ADoor_OnTimelineCoreEvent_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Door.OnOpenStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsOpen                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ActorInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::OnOpenStateChanged(bool IsOpen, class AActor* ActorInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Door.OnOpenStateChanged");
		
		ADoor_OnOpenStateChanged_Params params {};
		params.IsOpen = IsOpen;
		params.ActorInstigator = ActorInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Door.OnLockStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsLocked                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::OnLockStateChanged(bool IsLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Door.OnLockStateChanged");
		
		ADoor_OnLockStateChanged_Params params {};
		params.IsLocked = IsLocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Door.OnDeath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ADoor::OnDeath(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Door.OnDeath");
		
		ADoor_OnDeath_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Door.NativeOnUpdateVisualState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsOpen                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::NativeOnUpdateVisualState(bool IsOpen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Door.NativeOnUpdateVisualState");
		
		ADoor_NativeOnUpdateVisualState_Params params {};
		params.IsOpen = IsOpen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Door.NativeOnOpenStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsOpen                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ActorInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::NativeOnOpenStateChanged(bool IsOpen, class AActor* ActorInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Door.NativeOnOpenStateChanged");
		
		ADoor_NativeOnOpenStateChanged_Params params {};
		params.IsOpen = IsOpen;
		params.ActorInstigator = ActorInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Door.NativeOnLockStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsLocked                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::NativeOnLockStateChanged(bool IsLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Door.NativeOnLockStateChanged");
		
		ADoor_NativeOnLockStateChanged_Params params {};
		params.IsLocked = IsLocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Door");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDropletContentsComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDropletContentsComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.DropletContentsComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEggComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEggComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EggComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyEggComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyEggComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyEggComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEggLODComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEggLODComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EggLODComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Encounter.Spawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bForceSpawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AEncounter::Spawn(bool bForceSpawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Encounter.Spawn");
		
		AEncounter_Spawn_Params params {};
		params.bForceSpawn = bForceSpawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Encounter.OnSpawnKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AEncounter::OnSpawnKilled(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Encounter.OnSpawnKilled");
		
		AEncounter_OnSpawnKilled_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Encounter.OnGlobalVariableChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       GlobalVariableID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            VariableValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ActionInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AEncounter::OnGlobalVariableChanged(const struct FGuid& GlobalVariableID, int32_t VariableValue, class AActor* ActionInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Encounter.OnGlobalVariableChanged");
		
		AEncounter_OnGlobalVariableChanged_Params params {};
		params.GlobalVariableID = GlobalVariableID;
		params.VariableValue = VariableValue;
		params.ActionInstigator = ActionInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Encounter.IsComplete
	 * 		Flags  -> ()
	 */
	bool AEncounter::IsComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Encounter.IsComplete");
		
		AEncounter_IsComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Encounter.Despawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bImmediate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AEncounter::Despawn(bool bImmediate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Encounter.Despawn");
		
		AEncounter_Despawn_Params params {};
		params.bImmediate = bImmediate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AEncounter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AEncounter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Encounter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEncounterComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEncounterComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EncounterComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_QuerierLocation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_QuerierLocation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EnvQueryContext_QuerierLocation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryGenerator_FoliageKeys.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryGenerator_FoliageKeys::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EnvQueryGenerator_FoliageKeys");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryGenerator_Sphere.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryGenerator_Sphere::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EnvQueryGenerator_Sphere");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryItemType_FoliageKey.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryItemType_FoliageKey::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EnvQueryItemType_FoliageKey");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryTest_AllowableHeight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryTest_AllowableHeight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EnvQueryTest_AllowableHeight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryTest_BaseDistance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryTest_BaseDistance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EnvQueryTest_BaseDistance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryTest_Height.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryTest_Height::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EnvQueryTest_Height");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryTest_IsClimbable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryTest_IsClimbable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EnvQueryTest_IsClimbable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryTest_IsClimbingRole.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryTest_IsClimbingRole::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EnvQueryTest_IsClimbingRole");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryTest_PartyDistance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryTest_PartyDistance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EnvQueryTest_PartyDistance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEQSRequest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEQSRequest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EQSRequest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.SpawnVisuals
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Socket                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EItemVisualsPriority                               Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::SpawnVisuals(class UItem* Item, const class FName& Socket, EItemVisualsPriority Priority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.SpawnVisuals");
		
		UEquipmentComponent_SpawnVisuals_Params params {};
		params.Item = Item;
		params.Socket = Socket;
		params.Priority = Priority;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.ServerUnequipItemSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ReaddToInventory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TargetInventorySlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::ServerUnequipItemSlot(EEquipmentSlot Slot, bool ReaddToInventory, int32_t TargetInventorySlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.ServerUnequipItemSlot");
		
		UEquipmentComponent_ServerUnequipItemSlot_Params params {};
		params.Slot = Slot;
		params.ReaddToInventory = ReaddToInventory;
		params.TargetInventorySlot = TargetInventorySlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.ServerUnequipItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Equippable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ReaddToInventory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TargetInventorySlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::ServerUnequipItem(class UItem* Equippable, bool ReaddToInventory, int32_t TargetInventorySlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.ServerUnequipItem");
		
		UEquipmentComponent_ServerUnequipItem_Params params {};
		params.Equippable = Equippable;
		params.ReaddToInventory = ReaddToInventory;
		params.TargetInventorySlot = TargetInventorySlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.ServerRemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::ServerRemoveItem(class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.ServerRemoveItem");
		
		UEquipmentComponent_ServerRemoveItem_Params params {};
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.ServerEquipPreviousMainHand
	 * 		Flags  -> ()
	 */
	void UEquipmentComponent::ServerEquipPreviousMainHand()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.ServerEquipPreviousMainHand");
		
		UEquipmentComponent_ServerEquipPreviousMainHand_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.ServerEquipItemToSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Equippable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::ServerEquipItemToSlot(class UItem* Equippable, EEquipmentSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.ServerEquipItemToSlot");
		
		UEquipmentComponent_ServerEquipItemToSlot_Params params {};
		params.Equippable = Equippable;
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.ServerEquipItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Equippable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::ServerEquipItem(class UItem* Equippable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.ServerEquipItem");
		
		UEquipmentComponent_ServerEquipItem_Params params {};
		params.Equippable = Equippable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.ServerDumpItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::ServerDumpItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.ServerDumpItem");
		
		UEquipmentComponent_ServerDumpItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.ServerDropItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::ServerDropItem(class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.ServerDropItem");
		
		UEquipmentComponent_ServerDropItem_Params params {};
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.ServerDisarmWeapon
	 * 		Flags  -> ()
	 */
	void UEquipmentComponent::ServerDisarmWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.ServerDisarmWeapon");
		
		UEquipmentComponent_ServerDisarmWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.ServerCreateAndEquipItemData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RowData                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::ServerCreateAndEquipItemData(const struct FDataTableRowHandle& RowData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.ServerCreateAndEquipItemData");
		
		UEquipmentComponent_ServerCreateAndEquipItemData_Params params {};
		params.RowData = RowData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.OnUnderwaterChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsUnderwater                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::OnUnderwaterChanged(bool IsUnderwater)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.OnUnderwaterChanged");
		
		UEquipmentComponent_OnUnderwaterChanged_Params params {};
		params.IsUnderwater = IsUnderwater;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.OnRep_OffHand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       LastEquippable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::OnRep_OffHand(class UItem* LastEquippable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.OnRep_OffHand");
		
		UEquipmentComponent_OnRep_OffHand_Params params {};
		params.LastEquippable = LastEquippable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.OnRep_MainHand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       LastEquippable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::OnRep_MainHand(class UItem* LastEquippable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.OnRep_MainHand");
		
		UEquipmentComponent_OnRep_MainHand_Params params {};
		params.LastEquippable = LastEquippable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.OnRep_Legs
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       LastEquippable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::OnRep_Legs(class UItem* LastEquippable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.OnRep_Legs");
		
		UEquipmentComponent_OnRep_Legs_Params params {};
		params.LastEquippable = LastEquippable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.OnRep_Head
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       LastEquippable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::OnRep_Head(class UItem* LastEquippable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.OnRep_Head");
		
		UEquipmentComponent_OnRep_Head_Params params {};
		params.LastEquippable = LastEquippable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.OnRep_Glider
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       LastEquippable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::OnRep_Glider(class UItem* LastEquippable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.OnRep_Glider");
		
		UEquipmentComponent_OnRep_Glider_Params params {};
		params.LastEquippable = LastEquippable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.OnRep_Chest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       LastEquippable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::OnRep_Chest(class UItem* LastEquippable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.OnRep_Chest");
		
		UEquipmentComponent_OnRep_Chest_Params params {};
		params.LastEquippable = LastEquippable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.OnRep_Arms
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       LastEquippable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::OnRep_Arms(class UItem* LastEquippable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.OnRep_Arms");
		
		UEquipmentComponent_OnRep_Arms_Params params {};
		params.LastEquippable = LastEquippable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.OnItemChanged
	 * 		Flags  -> ()
	 */
	void UEquipmentComponent::OnItemChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.OnItemChanged");
		
		UEquipmentComponent_OnItemChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.OnHaulEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHaulingComponent*                           Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::OnHaulEnd(class UHaulingComponent* Sender)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.OnHaulEnd");
		
		UEquipmentComponent_OnHaulEnd_Params params {};
		params.Sender = Sender;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.OnHaulBegin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHaulingComponent*                           Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::OnHaulBegin(class UHaulingComponent* Sender)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.OnHaulBegin");
		
		UEquipmentComponent_OnHaulBegin_Params params {};
		params.Sender = Sender;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.OnCameraModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECameraDisplayMode                                 DisplayMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::OnCameraModeChanged(ECameraDisplayMode DisplayMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.OnCameraModeChanged");
		
		UEquipmentComponent_OnCameraModeChanged_Params params {};
		params.DisplayMode = DisplayMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.LocalUnequipItemInSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ReaddToInventory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TargetInventorySlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInventoryComponent*                         ToFromInventory                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UEquipmentComponent::LocalUnequipItemInSlot(EEquipmentSlot Slot, bool ReaddToInventory, int32_t TargetInventorySlot, class UInventoryComponent* ToFromInventory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.LocalUnequipItemInSlot");
		
		UEquipmentComponent_LocalUnequipItemInSlot_Params params {};
		params.Slot = Slot;
		params.ReaddToInventory = ReaddToInventory;
		params.TargetInventorySlot = TargetInventorySlot;
		params.ToFromInventory = ToFromInventory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.LocalUnequipItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Equippable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ReaddToInventory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TargetInventorySlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInventoryComponent*                         ToFromInventory                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UEquipmentComponent::LocalUnequipItem(class UItem* Equippable, bool ReaddToInventory, int32_t TargetInventorySlot, class UInventoryComponent* ToFromInventory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.LocalUnequipItem");
		
		UEquipmentComponent_LocalUnequipItem_Params params {};
		params.Equippable = Equippable;
		params.ReaddToInventory = ReaddToInventory;
		params.TargetInventorySlot = TargetInventorySlot;
		params.ToFromInventory = ToFromInventory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.LocalEquipItemToSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Equippable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInventoryComponent*                         ToFromInventory                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::LocalEquipItemToSlot(class UItem* Equippable, EEquipmentSlot Slot, class UInventoryComponent* ToFromInventory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.LocalEquipItemToSlot");
		
		UEquipmentComponent_LocalEquipItemToSlot_Params params {};
		params.Equippable = Equippable;
		params.Slot = Slot;
		params.ToFromInventory = ToFromInventory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.IsItemRowHandleEquipped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UEquipmentComponent::IsItemRowHandleEquipped(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.IsItemRowHandleEquipped");
		
		UEquipmentComponent_IsItemRowHandleEquipped_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.IsItemEquipped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UEquipmentComponent::IsItemEquipped(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.IsItemEquipped");
		
		UEquipmentComponent_IsItemEquipped_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.HasSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UEquipmentComponent::HasSlot(EEquipmentSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.HasSlot");
		
		UEquipmentComponent_HasSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.HasAnyItemEquipped
	 * 		Flags  -> ()
	 */
	bool UEquipmentComponent::HasAnyItemEquipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.HasAnyItemEquipped");
		
		UEquipmentComponent_HasAnyItemEquipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.GetWeapon
	 * 		Flags  -> ()
	 */
	class UItem* UEquipmentComponent::GetWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.GetWeapon");
		
		UEquipmentComponent_GetWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.GetStance
	 * 		Flags  -> ()
	 */
	int32_t UEquipmentComponent::GetStance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.GetStance");
		
		UEquipmentComponent_GetStance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.GetPreviousItemInSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UEquipmentComponent::GetPreviousItemInSlot(EEquipmentSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.GetPreviousItemInSlot");
		
		UEquipmentComponent_GetPreviousItemInSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.GetOffhandStance
	 * 		Flags  -> ()
	 */
	int32_t UEquipmentComponent::GetOffhandStance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.GetOffhandStance");
		
		UEquipmentComponent_GetOffhandStance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.GetItemSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EEquipmentSlot UEquipmentComponent::GetItemSlot(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.GetItemSlot");
		
		UEquipmentComponent_GetItemSlot_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.GetItemInSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UEquipmentComponent::GetItemInSlot(EEquipmentSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.GetItemInSlot");
		
		UEquipmentComponent_GetItemInSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.GetItemCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UEquipmentComponent::GetItemCount(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.GetItemCount");
		
		UEquipmentComponent_GetItemCount_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.GetEquipmentSlots
	 * 		Flags  -> ()
	 */
	TArray<EEquipmentSlot> UEquipmentComponent::GetEquipmentSlots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.GetEquipmentSlots");
		
		UEquipmentComponent_GetEquipmentSlots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.GetAverageEquippedTier
	 * 		Flags  -> ()
	 */
	float UEquipmentComponent::GetAverageEquippedTier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.GetAverageEquippedTier");
		
		UEquipmentComponent_GetAverageEquippedTier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.GetActiveItemSet
	 * 		Flags  -> ()
	 */
	struct FItemSetData UEquipmentComponent::GetActiveItemSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.GetActiveItemSet");
		
		UEquipmentComponent_GetActiveItemSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.EquipItemData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RowData                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UEquipmentComponent::EquipItemData(const struct FDataTableRowHandle& RowData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.EquipItemData");
		
		UEquipmentComponent_EquipItemData_Params params {};
		params.RowData = RowData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.DestroyVisuals
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UEquipmentComponent::DestroyVisuals(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.DestroyVisuals");
		
		UEquipmentComponent_DestroyVisuals_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.ClientNotifyItemPowerDepleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::ClientNotifyItemPowerDepleted(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.ClientNotifyItemPowerDepleted");
		
		UEquipmentComponent_ClientNotifyItemPowerDepleted_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.ClientNotifyItemPowerChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::ClientNotifyItemPowerChanged(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.ClientNotifyItemPowerChanged");
		
		UEquipmentComponent_ClientNotifyItemPowerChanged_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.ClientNotifyItemBroken
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ItemDroppedInWorld                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::ClientNotifyItemBroken(class UItem* Item, bool ItemDroppedInWorld)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.ClientNotifyItemBroken");
		
		UEquipmentComponent_ClientNotifyItemBroken_Params params {};
		params.Item = Item;
		params.ItemDroppedInWorld = ItemDroppedInWorld;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentComponent.ClientNotifyEquipmentChangeFailureFromFullInventory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquipmentChangeFailureFromFullInventoryStimulus   FailureStimulus                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentComponent::ClientNotifyEquipmentChangeFailureFromFullInventory(EEquipmentChangeFailureFromFullInventoryStimulus FailureStimulus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentComponent.ClientNotifyEquipmentChangeFailureFromFullInventory");
		
		UEquipmentComponent_ClientNotifyEquipmentChangeFailureFromFullInventory_Params params {};
		params.FailureStimulus = FailureStimulus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEquipmentComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEquipmentComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EquipmentComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentDisplayBuilding.IsValidItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AEquipmentDisplayBuilding::IsValidItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentDisplayBuilding.IsValidItem");
		
		AEquipmentDisplayBuilding_IsValidItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentDisplayBuilding.IsValidEquipmentSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AEquipmentDisplayBuilding::IsValidEquipmentSlot(EEquipmentSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentDisplayBuilding.IsValidEquipmentSlot");
		
		AEquipmentDisplayBuilding_IsValidEquipmentSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentDisplayBuilding.GetEquipmentMeshComponent
	 * 		Flags  -> ()
	 */
	class UMeshComponent* AEquipmentDisplayBuilding::GetEquipmentMeshComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentDisplayBuilding.GetEquipmentMeshComponent");
		
		AEquipmentDisplayBuilding_GetEquipmentMeshComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentDisplayBuilding.GetArmorMeshComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USkeletalMeshComponent* AEquipmentDisplayBuilding::GetArmorMeshComponent(EEquipmentSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentDisplayBuilding.GetArmorMeshComponent");
		
		AEquipmentDisplayBuilding_GetArmorMeshComponent_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AEquipmentDisplayBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AEquipmentDisplayBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EquipmentDisplayBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyEquipmentComponent.HasSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UProxyEquipmentComponent::HasSlot(EEquipmentSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyEquipmentComponent.HasSlot");
		
		UProxyEquipmentComponent_HasSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyEquipmentComponent.GetItemInSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UProxyEquipmentComponent::GetItemInSlot(EEquipmentSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyEquipmentComponent.GetItemInSlot");
		
		UProxyEquipmentComponent_GetItemInSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyEquipmentComponent.GetEquipmentSlots
	 * 		Flags  -> ()
	 */
	TArray<EEquipmentSlot> UProxyEquipmentComponent::GetEquipmentSlots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyEquipmentComponent.GetEquipmentSlots");
		
		UProxyEquipmentComponent_GetEquipmentSlots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyEquipmentComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyEquipmentComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyEquipmentComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentLODComponent.HasSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UEquipmentLODComponent::HasSlot(EEquipmentSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentLODComponent.HasSlot");
		
		UEquipmentLODComponent_HasSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentLODComponent.GetItemInSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UEquipmentLODComponent::GetItemInSlot(EEquipmentSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentLODComponent.GetItemInSlot");
		
		UEquipmentLODComponent_GetItemInSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EquipmentLODComponent.GetEquipmentSlots
	 * 		Flags  -> ()
	 */
	TArray<EEquipmentSlot> UEquipmentLODComponent::GetEquipmentSlots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EquipmentLODComponent.GetEquipmentSlots");
		
		UEquipmentLODComponent_GetEquipmentSlots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEquipmentLODComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEquipmentLODComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EquipmentLODComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EventAttackComponent.ResetValues
	 * 		Flags  -> ()
	 */
	void UEventAttackComponent::ResetValues()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EventAttackComponent.ResetValues");
		
		UEventAttackComponent_ResetValues_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EventAttackComponent.OnDamagedCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsKillingBlow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEventAttackComponent::OnDamagedCharacter(float Damage, const struct FDamageInfo& DamageInfo, class AController* InstigatedBy, class UBaseLODActor* DamageCauser, bool IsKillingBlow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EventAttackComponent.OnDamagedCharacter");
		
		UEventAttackComponent_OnDamagedCharacter_Params params {};
		params.Damage = Damage;
		params.DamageInfo = DamageInfo;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		params.IsKillingBlow = IsKillingBlow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EventAttackComponent.OnAttack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAttack*                                     Attack                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEventAttackComponent::OnAttack(class UAttack* Attack)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EventAttackComponent.OnAttack");
		
		UEventAttackComponent_OnAttack_Params params {};
		params.Attack = Attack;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EventAttackComponent.EndAttack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAttack*                                     Attack                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEventAttackComponent::EndAttack(class UAttack* Attack)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EventAttackComponent.EndAttack");
		
		UEventAttackComponent_EndAttack_Params params {};
		params.Attack = Attack;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.EventAttackComponent.ApplyEffects
	 * 		Flags  -> ()
	 */
	void UEventAttackComponent::ApplyEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.EventAttackComponent.ApplyEffects");
		
		UEventAttackComponent_ApplyEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEventAttackComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEventAttackComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.EventAttackComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Fabricator.TickProcessing
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFabricator::TickProcessing(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Fabricator.TickProcessing");
		
		AFabricator_TickProcessing_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Fabricator.OnRep_FabricationState
	 * 		Flags  -> ()
	 */
	void AFabricator::OnRep_FabricationState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Fabricator.OnRep_FabricationState");
		
		AFabricator_OnRep_FabricationState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Fabricator.OnRep_FabricationItems
	 * 		Flags  -> ()
	 */
	void AFabricator::OnRep_FabricationItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Fabricator.OnRep_FabricationItems");
		
		AFabricator_OnRep_FabricationItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Fabricator.OnHealthChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHealthComponent*                            SourceHealthComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OldHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFabricator::OnHealthChanged(class UHealthComponent* SourceHealthComponent, float NewHealth, float OldHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Fabricator.OnHealthChanged");
		
		AFabricator_OnHealthChanged_Params params {};
		params.SourceHealthComponent = SourceHealthComponent;
		params.NewHealth = NewHealth;
		params.OldHealth = OldHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Fabricator.GetRemainingFabricationRequirements
	 * 		Flags  -> ()
	 */
	TArray<struct FRecipeRequirements> AFabricator::GetRemainingFabricationRequirements()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Fabricator.GetRemainingFabricationRequirements");
		
		AFabricator_GetRemainingFabricationRequirements_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Fabricator.GetProcessingTimePercentage
	 * 		Flags  -> ()
	 */
	float AFabricator::GetProcessingTimePercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Fabricator.GetProcessingTimePercentage");
		
		AFabricator_GetProcessingTimePercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Fabricator.GetFabricationState
	 * 		Flags  -> ()
	 */
	EFabricationState AFabricator::GetFabricationState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Fabricator.GetFabricationState");
		
		AFabricator_GetFabricationState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFabricator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFabricator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Fabricator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFaucetBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFaucetBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FaucetBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FaucetSpawnerComponent.Spawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemSpawnPointData                         SpawnPoint                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* UFaucetSpawnerComponent::Spawn(const struct FItemSpawnPointData& SpawnPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FaucetSpawnerComponent.Spawn");
		
		UFaucetSpawnerComponent_Spawn_Params params {};
		params.SpawnPoint = SpawnPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FaucetSpawnerComponent.GetSpawnPoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FItemSpawnPointData>                 SpawnPoints                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UFaucetSpawnerComponent::GetSpawnPoints(TArray<struct FItemSpawnPointData>* SpawnPoints)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FaucetSpawnerComponent.GetSpawnPoints");
		
		UFaucetSpawnerComponent_GetSpawnPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SpawnPoints != nullptr)
			*SpawnPoints = params.SpawnPoints;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FaucetSpawnerComponent.GetItemSpawnGroupData
	 * 		Flags  -> ()
	 */
	class UClass* UFaucetSpawnerComponent::GetItemSpawnGroupData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FaucetSpawnerComponent.GetItemSpawnGroupData");
		
		UFaucetSpawnerComponent_GetItemSpawnGroupData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FaucetSpawnerComponent.DoesSpawnActors
	 * 		Flags  -> ()
	 */
	bool UFaucetSpawnerComponent::DoesSpawnActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FaucetSpawnerComponent.DoesSpawnActors");
		
		UFaucetSpawnerComponent_DoesSpawnActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FaucetSpawnerComponent.Despawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemSpawnPointData                         SpawnPoint                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFaucetSpawnerComponent::Despawn(const struct FItemSpawnPointData& SpawnPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FaucetSpawnerComponent.Despawn");
		
		UFaucetSpawnerComponent_Despawn_Params params {};
		params.SpawnPoint = SpawnPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFaucetSpawnerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFaucetSpawnerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FaucetSpawnerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.TickMaintainActorList
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFluidVolume::TickMaintainActorList(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.TickMaintainActorList");
		
		AFluidVolume_TickMaintainActorList_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.TickCreateRipples
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFluidVolume::TickCreateRipples(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.TickCreateRipples");
		
		AFluidVolume_TickCreateRipples_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.SpawnSplashVFX
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsOverlapEvent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFluidVolume::SpawnSplashVFX(class AActor* Actor, bool IsOverlapEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.SpawnSplashVFX");
		
		AFluidVolume_SpawnSplashVFX_Params params {};
		params.Actor = Actor;
		params.IsOverlapEvent = IsOverlapEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.SetupNativeReferences
	 * 		Flags  -> ()
	 */
	void AFluidVolume::SetupNativeReferences()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.SetupNativeReferences");
		
		AFluidVolume_SetupNativeReferences_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.SetTickEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFluidVolume::SetTickEnabled(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.SetTickEnabled");
		
		AFluidVolume_SetTickEnabled_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.OnPhotoModeExit
	 * 		Flags  -> ()
	 */
	void AFluidVolume::OnPhotoModeExit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.OnPhotoModeExit");
		
		AFluidVolume_OnPhotoModeExit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.OnPhotoModeEntered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APhotoPawn*                                  PhotoPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFluidVolume::OnPhotoModeEntered(class APhotoPawn* PhotoPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.OnPhotoModeEntered");
		
		AFluidVolume_OnPhotoModeEntered_Params params {};
		params.PhotoPawn = PhotoPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.OnColliderOverlapEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFluidVolume::OnColliderOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.OnColliderOverlapEnd");
		
		AFluidVolume_OnColliderOverlapEnd_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.OnColliderOverlapBegin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AFluidVolume::OnColliderOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.OnColliderOverlapBegin");
		
		AFluidVolume_OnColliderOverlapBegin_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.OnCameraColliderOverlapEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFluidVolume::OnCameraColliderOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.OnCameraColliderOverlapEnd");
		
		AFluidVolume_OnCameraColliderOverlapEnd_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.OnCameraColliderOverlapBegin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AFluidVolume::OnCameraColliderOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.OnCameraColliderOverlapBegin");
		
		AFluidVolume_OnCameraColliderOverlapBegin_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.NativeToggleDepthImpostorVisibility
	 * 		Flags  -> ()
	 */
	void AFluidVolume::NativeToggleDepthImpostorVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.NativeToggleDepthImpostorVisibility");
		
		AFluidVolume_NativeToggleDepthImpostorVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.NativeQualifyActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ActorToCheck                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AFluidVolume::NativeQualifyActor(class AActor* ActorToCheck)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.NativeQualifyActor");
		
		AFluidVolume_NativeQualifyActor_Params params {};
		params.ActorToCheck = ActorToCheck;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.NativeModifyRipple
	 * 		Flags  -> ()
	 */
	void AFluidVolume::NativeModifyRipple()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.NativeModifyRipple");
		
		AFluidVolume_NativeModifyRipple_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.NativeMaintainActorList
	 * 		Flags  -> ()
	 */
	void AFluidVolume::NativeMaintainActorList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.NativeMaintainActorList");
		
		AFluidVolume_NativeMaintainActorList_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.NativeIsLocalPlayerInTickRange
	 * 		Flags  -> ()
	 */
	bool AFluidVolume::NativeIsLocalPlayerInTickRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.NativeIsLocalPlayerInTickRange");
		
		AFluidVolume_NativeIsLocalPlayerInTickRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.NativeInitDepthImpostor
	 * 		Flags  -> ()
	 */
	void AFluidVolume::NativeInitDepthImpostor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.NativeInitDepthImpostor");
		
		AFluidVolume_NativeInitDepthImpostor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.NativeDrawAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNativeRippleEvent                          RippleEvent                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AFluidVolume::NativeDrawAtLocation(const struct FNativeRippleEvent& RippleEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.NativeDrawAtLocation");
		
		AFluidVolume_NativeDrawAtLocation_Params params {};
		params.RippleEvent = RippleEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.NativeCreateRippleEvents
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsOverlapEvent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFluidVolume::NativeCreateRippleEvents(bool bIsOverlapEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.NativeCreateRippleEvents");
		
		AFluidVolume_NativeCreateRippleEvents_Params params {};
		params.bIsOverlapEvent = bIsOverlapEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.NativeCreateOverlapRipple
	 * 		Flags  -> ()
	 */
	void AFluidVolume::NativeCreateOverlapRipple()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.NativeCreateOverlapRipple");
		
		AFluidVolume_NativeCreateOverlapRipple_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.IsCameraInVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               XYOnly                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AFluidVolume::IsCameraInVolume(bool XYOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.IsCameraInVolume");
		
		AFluidVolume_IsCameraInVolume_Params params {};
		params.XYOnly = XYOnly;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.IsActorNearWaterSurface
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AFluidVolume::IsActorNearWaterSurface(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.IsActorNearWaterSurface");
		
		AFluidVolume_IsActorNearWaterSurface_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FluidVolume.GetInitialOverlaps
	 * 		Flags  -> ()
	 */
	void AFluidVolume::GetInitialOverlaps()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FluidVolume.GetInitialOverlaps");
		
		AFluidVolume_GetInitialOverlaps_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFluidVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFluidVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FluidVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FlySwimSurvivalCharacter.OnRep_BaseSeed
	 * 		Flags  -> ()
	 */
	void AFlySwimSurvivalCharacter::OnRep_BaseSeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FlySwimSurvivalCharacter.OnRep_BaseSeed");
		
		AFlySwimSurvivalCharacter_OnRep_BaseSeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FlySwimSurvivalCharacter.InterpolateRotationTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRotator                                    InTargetRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaTime                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFlySwimSurvivalCharacter::InterpolateRotationTo(const struct FRotator& InTargetRotation, float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FlySwimSurvivalCharacter.InterpolateRotationTo");
		
		AFlySwimSurvivalCharacter_InterpolateRotationTo_Params params {};
		params.InTargetRotation = InTargetRotation;
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFlySwimSurvivalCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFlySwimSurvivalCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FlySwimSurvivalCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFlyingSurvivalCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFlyingSurvivalCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FlyingSurvivalCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFocusRerouteWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFocusRerouteWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FocusRerouteWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFoliageDisplacerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFoliageDisplacerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FoliageDisplacerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFoliageManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFoliageManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FoliageManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.SetSwappedActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFoliageManagerComponent::SetSwappedActor(const struct FFoliageKey& Key, class UBaseLODActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.SetSwappedActor");
		
		UFoliageManagerComponent_SetSwappedActor_Params params {};
		params.Key = Key;
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.SetFoliageInstanceDefaultState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 FoliageKey                                                 (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFoliageManagerComponent::SetFoliageInstanceDefaultState(const struct FFoliageKey& FoliageKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.SetFoliageInstanceDefaultState");
		
		UFoliageManagerComponent_SetFoliageInstanceDefaultState_Params params {};
		params.FoliageKey = FoliageKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.ReplaceFoliageMeshWithBlueprintActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 FoliageKey                                                 (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFoliageSwapFlags                                  Flags                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* UFoliageManagerComponent::ReplaceFoliageMeshWithBlueprintActor(const struct FFoliageKey& FoliageKey, EFoliageSwapFlags Flags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.ReplaceFoliageMeshWithBlueprintActor");
		
		UFoliageManagerComponent_ReplaceFoliageMeshWithBlueprintActor_Params params {};
		params.FoliageKey = FoliageKey;
		params.Flags = Flags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.RemoveFoliageInstance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 FoliageKey                                                 (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFoliageOperationFlags                             Flags                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFoliageManagerComponent::RemoveFoliageInstance(const struct FFoliageKey& FoliageKey, EFoliageOperationFlags Flags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.RemoveFoliageInstance");
		
		UFoliageManagerComponent_RemoveFoliageInstance_Params params {};
		params.FoliageKey = FoliageKey;
		params.Flags = Flags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.ReaddFoliageInstance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 FoliageKey                                                 (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFoliageOperationFlags                             Flags                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFoliageManagerComponent::ReaddFoliageInstance(const struct FFoliageKey& FoliageKey, EFoliageOperationFlags Flags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.ReaddFoliageInstance");
		
		UFoliageManagerComponent_ReaddFoliageInstance_Params params {};
		params.FoliageKey = FoliageKey;
		params.Flags = Flags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.OnRest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              RestDuration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFoliageManagerComponent::OnRest(float RestDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.OnRest");
		
		UFoliageManagerComponent_OnRest_Params params {};
		params.RestDuration = RestDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.OnRep_RemovedFoliageItems
	 * 		Flags  -> ()
	 */
	void UFoliageManagerComponent::OnRep_RemovedFoliageItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.OnRep_RemovedFoliageItems");
		
		UFoliageManagerComponent_OnRep_RemovedFoliageItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.OnRep_AddedFoliageItems
	 * 		Flags  -> ()
	 */
	void UFoliageManagerComponent::OnRep_AddedFoliageItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.OnRep_AddedFoliageItems");
		
		UFoliageManagerComponent_OnRep_AddedFoliageItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.MulticastPlayFoliageInteractEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FTransform>                          SpawnTransforms                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FFoliageKey                                 FoliageKey                                                 (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFoliageManagerComponent::MulticastPlayFoliageInteractEffects(TArray<struct FTransform> SpawnTransforms, const struct FFoliageKey& FoliageKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.MulticastPlayFoliageInteractEffects");
		
		UFoliageManagerComponent_MulticastPlayFoliageInteractEffects_Params params {};
		params.SpawnTransforms = SpawnTransforms;
		params.FoliageKey = FoliageKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.IsRemovedFoliageInstance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 FoliageKey                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UFoliageManagerComponent::IsRemovedFoliageInstance(const struct FFoliageKey& FoliageKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.IsRemovedFoliageInstance");
		
		UFoliageManagerComponent_IsRemovedFoliageInstance_Params params {};
		params.FoliageKey = FoliageKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.HandleGlobalVariableChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       GlobalVariableID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            VariableValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFoliageManagerComponent::HandleGlobalVariableChanged(const struct FGuid& GlobalVariableID, int32_t VariableValue, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.HandleGlobalVariableChanged");
		
		UFoliageManagerComponent_HandleGlobalVariableChanged_Params params {};
		params.GlobalVariableID = GlobalVariableID;
		params.VariableValue = VariableValue;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.GetVisibleTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 FoliageKey                                                 (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Transform                                                  (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bWorldSpace                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UFoliageManagerComponent::GetVisibleTransform(const struct FFoliageKey& FoliageKey, struct FTransform* Transform, bool bWorldSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.GetVisibleTransform");
		
		UFoliageManagerComponent_GetVisibleTransform_Params params {};
		params.FoliageKey = FoliageKey;
		params.bWorldSpace = bWorldSpace;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Transform != nullptr)
			*Transform = params.Transform;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.GetNearestInstanceOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UFoliageType_InstancedStaticMesh*>    Types                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Center                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FFoliageKey UFoliageManagerComponent::GetNearestInstanceOfType(TArray<class UFoliageType_InstancedStaticMesh*> Types, const struct FVector& Center)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.GetNearestInstanceOfType");
		
		UFoliageManagerComponent_GetNearestInstanceOfType_Params params {};
		params.Types = Types;
		params.Center = Center;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.GetInstancesOverlappingSphereOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFoliageType_InstancedStaticMesh*            Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Center                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSphereInWorldSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FFoliageKey> UFoliageManagerComponent::GetInstancesOverlappingSphereOfType(class UFoliageType_InstancedStaticMesh* Type, const struct FVector& Center, float Radius, bool bSphereInWorldSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.GetInstancesOverlappingSphereOfType");
		
		UFoliageManagerComponent_GetInstancesOverlappingSphereOfType_Params params {};
		params.Type = Type;
		params.Center = Center;
		params.Radius = Radius;
		params.bSphereInWorldSpace = bSphereInWorldSpace;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.GetInstancesOverlappingSphere
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Center                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSphereInWorldSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FFoliageKey> UFoliageManagerComponent::GetInstancesOverlappingSphere(const struct FVector& Center, float Radius, bool bSphereInWorldSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.GetInstancesOverlappingSphere");
		
		UFoliageManagerComponent_GetInstancesOverlappingSphere_Params params {};
		params.Center = Center;
		params.Radius = Radius;
		params.bSphereInWorldSpace = bSphereInWorldSpace;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.GetInstancesOverlappingBox
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBox                                        Box                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bBoxInWorldSpace                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FFoliageKey> UFoliageManagerComponent::GetInstancesOverlappingBox(const struct FBox& Box, bool bBoxInWorldSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.GetInstancesOverlappingBox");
		
		UFoliageManagerComponent_GetInstancesOverlappingBox_Params params {};
		params.Box = Box;
		params.bBoxInWorldSpace = bBoxInWorldSpace;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.GetFoliageIsClimbable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 FoliageKey                                                 (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ClimberTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UFoliageManagerComponent::GetFoliageIsClimbable(const struct FFoliageKey& FoliageKey, const struct FGameplayTag& ClimberTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.GetFoliageIsClimbable");
		
		UFoliageManagerComponent_GetFoliageIsClimbable_Params params {};
		params.FoliageKey = FoliageKey;
		params.ClimberTag = ClimberTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.GetFoliageHasClimbRole
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 FoliageKey                                                 (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                RoleTag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UFoliageManagerComponent::GetFoliageHasClimbRole(const struct FFoliageKey& FoliageKey, const struct FGameplayTag& RoleTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.GetFoliageHasClimbRole");
		
		UFoliageManagerComponent_GetFoliageHasClimbRole_Params params {};
		params.FoliageKey = FoliageKey;
		params.RoleTag = RoleTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.GetCurrentTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 FoliageKey                                                 (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Transform                                                  (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bWorldSpace                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UFoliageManagerComponent::GetCurrentTransform(const struct FFoliageKey& FoliageKey, struct FTransform* Transform, bool bWorldSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.GetCurrentTransform");
		
		UFoliageManagerComponent_GetCurrentTransform_Params params {};
		params.FoliageKey = FoliageKey;
		params.bWorldSpace = bWorldSpace;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Transform != nullptr)
			*Transform = params.Transform;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.GetBlueprintInstance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 FoliageKey                                                 (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* UFoliageManagerComponent::GetBlueprintInstance(const struct FFoliageKey& FoliageKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.GetBlueprintInstance");
		
		UFoliageManagerComponent_GetBlueprintInstance_Params params {};
		params.FoliageKey = FoliageKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FoliageManagerComponent.ClearGroundFoliage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBox                                        BoundingBox                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UFoliageManagerComponent::ClearGroundFoliage(const struct FVector& Location, float Radius, const struct FBox& BoundingBox)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FoliageManagerComponent.ClearGroundFoliage");
		
		UFoliageManagerComponent_ClearGroundFoliage_Params params {};
		params.Location = Location;
		params.Radius = Radius;
		params.BoundingBox = BoundingBox;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFoliageManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFoliageManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FoliageManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFootstepData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFootstepData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FootstepData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FPCOverlayComponent.UpdatePositionForDynamicFOVChange
	 * 		Flags  -> ()
	 */
	void UFPCOverlayComponent::UpdatePositionForDynamicFOVChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FPCOverlayComponent.UpdatePositionForDynamicFOVChange");
		
		UFPCOverlayComponent_UpdatePositionForDynamicFOVChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FPCOverlayComponent.UpdatePositionForAspectRatioChange
	 * 		Flags  -> ()
	 */
	void UFPCOverlayComponent::UpdatePositionForAspectRatioChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FPCOverlayComponent.UpdatePositionForAspectRatioChange");
		
		UFPCOverlayComponent_UpdatePositionForAspectRatioChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FPCOverlayComponent.SetOverlay
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ConfigName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MeshVariant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFPCOverlayComponent::SetOverlay(const class FName& ConfigName, int32_t MeshVariant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FPCOverlayComponent.SetOverlay");
		
		UFPCOverlayComponent_SetOverlay_Params params {};
		params.ConfigName = ConfigName;
		params.MeshVariant = MeshVariant;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FPCOverlayComponent.RemoveOverlay
	 * 		Flags  -> ()
	 */
	void UFPCOverlayComponent::RemoveOverlay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FPCOverlayComponent.RemoveOverlay");
		
		UFPCOverlayComponent_RemoveOverlay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFPCOverlayComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFPCOverlayComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FPCOverlayComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFPCOverlayConfigDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFPCOverlayConfigDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FPCOverlayConfigDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFrankenlineControl.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFrankenlineControl::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FrankenlineControl");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineButton.HandleButtonPressed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFrankenlineButton::HandleButtonPressed(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineButton.HandleButtonPressed");
		
		AFrankenlineButton_HandleButtonPressed_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFrankenlineButton.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFrankenlineButton::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FrankenlineButton");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WalkDial.OnMotionInput
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCharacterMotionEaterComponent*              Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   Input                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AWalkDial::OnMotionInput(class UCharacterMotionEaterComponent* Sender, const struct FVector2D& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WalkDial.OnMotionInput");
		
		AWalkDial_OnMotionInput_Params params {};
		params.Sender = Sender;
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WalkDial.OnCharacterDetached
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCharacterMotionEaterComponent*              Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalCharacter*                          Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AWalkDial::OnCharacterDetached(class UCharacterMotionEaterComponent* Sender, class ASurvivalCharacter* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WalkDial.OnCharacterDetached");
		
		AWalkDial_OnCharacterDetached_Params params {};
		params.Sender = Sender;
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WalkDial.OnCharacterAttached
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCharacterMotionEaterComponent*              Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalCharacter*                          Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AWalkDial::OnCharacterAttached(class UCharacterMotionEaterComponent* Sender, class ASurvivalCharacter* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WalkDial.OnCharacterAttached");
		
		AWalkDial_OnCharacterAttached_Params params {};
		params.Sender = Sender;
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WalkDial.HandleDialRotated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Delta                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AWalkDial::HandleDialRotated(float Delta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WalkDial.HandleDialRotated");
		
		AWalkDial_HandleDialRotated_Params params {};
		params.Delta = Delta;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WalkDial.HandleCharacterDetached
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AWalkDial::HandleCharacterDetached(class ASurvivalCharacter* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WalkDial.HandleCharacterDetached");
		
		AWalkDial_HandleCharacterDetached_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WalkDial.HandleCharacterAttached
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AWalkDial::HandleCharacterAttached(class ASurvivalCharacter* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WalkDial.HandleCharacterAttached");
		
		AWalkDial_HandleCharacterAttached_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWalkDial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWalkDial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WalkDial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFrankenlineDial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFrankenlineDial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FrankenlineDial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineMaster.ReplicateDrawLine
	 * 		Flags  -> ()
	 */
	void AFrankenlineMaster::ReplicateDrawLine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineMaster.ReplicateDrawLine");
		
		AFrankenlineMaster_ReplicateDrawLine_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineMaster.MulticastDrawLine
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector2D                                   To                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      ColorIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFrankenlineMaster::MulticastDrawLine(const struct FVector2D& To, unsigned char ColorIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineMaster.MulticastDrawLine");
		
		AFrankenlineMaster_MulticastDrawLine_Params params {};
		params.To = To;
		params.ColorIndex = ColorIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineMaster.MulticastCycleColor
	 * 		Flags  -> ()
	 */
	void AFrankenlineMaster::MulticastCycleColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineMaster.MulticastCycleColor");
		
		AFrankenlineMaster_MulticastCycleColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineMaster.MulticastClear
	 * 		Flags  -> ()
	 */
	void AFrankenlineMaster::MulticastClear()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineMaster.MulticastClear");
		
		AFrankenlineMaster_MulticastClear_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineMaster.InputMotion
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector2D                                   Motion                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFrankenlineMaster::InputMotion(const struct FVector2D& Motion)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineMaster.InputMotion");
		
		AFrankenlineMaster_InputMotion_Params params {};
		params.Motion = Motion;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineMaster.HandleRenderTargetCreated
	 * 		Flags  -> ()
	 */
	void AFrankenlineMaster::HandleRenderTargetCreated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineMaster.HandleRenderTargetCreated");
		
		AFrankenlineMaster_HandleRenderTargetCreated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineMaster.HandleHitEdge
	 * 		Flags  -> ()
	 */
	void AFrankenlineMaster::HandleHitEdge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineMaster.HandleHitEdge");
		
		AFrankenlineMaster_HandleHitEdge_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineMaster.HandleCycleColor
	 * 		Flags  -> ()
	 */
	void AFrankenlineMaster::HandleCycleColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineMaster.HandleCycleColor");
		
		AFrankenlineMaster_HandleCycleColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineMaster.HandleClearScreen
	 * 		Flags  -> ()
	 */
	void AFrankenlineMaster::HandleClearScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineMaster.HandleClearScreen");
		
		AFrankenlineMaster_HandleClearScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineMaster.GetNextColor
	 * 		Flags  -> ()
	 */
	struct FLinearColor AFrankenlineMaster::GetNextColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineMaster.GetNextColor");
		
		AFrankenlineMaster_GetNextColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineMaster.GetCurrentColor
	 * 		Flags  -> ()
	 */
	struct FLinearColor AFrankenlineMaster::GetCurrentColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineMaster.GetCurrentColor");
		
		AFrankenlineMaster_GetCurrentColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineMaster.FinallyCycleColor
	 * 		Flags  -> ()
	 */
	void AFrankenlineMaster::FinallyCycleColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineMaster.FinallyCycleColor");
		
		AFrankenlineMaster_FinallyCycleColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineMaster.FinallyClear
	 * 		Flags  -> ()
	 */
	void AFrankenlineMaster::FinallyClear()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineMaster.FinallyClear");
		
		AFrankenlineMaster_FinallyClear_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.FrankenlineMaster.CacheCursorMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMeshComponent*                        InCursorMesh                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFrankenlineMaster::CacheCursorMesh(class UStaticMeshComponent* InCursorMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.FrankenlineMaster.CacheCursorMesh");
		
		AFrankenlineMaster_CacheCursorMesh_Params params {};
		params.InCursorMesh = InCursorMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFrankenlineMaster.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFrankenlineMaster::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.FrankenlineMaster");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameLobbyWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameLobbyWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GameLobbyWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameOptions.UnbindGame
	 * 		Flags  -> ()
	 */
	void UGameOptions::UnbindGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameOptions.UnbindGame");
		
		UGameOptions_UnbindGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameOptions.Save
	 * 		Flags  -> ()
	 */
	void UGameOptions::Save()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameOptions.Save");
		
		UGameOptions_Save_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameOptions.Load
	 * 		Flags  -> ()
	 */
	void UGameOptions::Load()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameOptions.Load");
		
		UGameOptions_Load_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameOptions.GetControlOptions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsGamepad                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UControlOptions* UGameOptions::GetControlOptions(bool bIsGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameOptions.GetControlOptions");
		
		UGameOptions_GetControlOptions_Params params {};
		params.bIsGamepad = bIsGamepad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameOptions.BindGame
	 * 		Flags  -> ()
	 */
	void UGameOptions::BindGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameOptions.BindGame");
		
		UGameOptions_BindGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameOptions.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameOptions::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GameOptions");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameTextBlock.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameTextBlock::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GameTextBlock");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUI.PostPlayerChatMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGameUI::PostPlayerChatMessage(const class FString& Message, class ASurvivalPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUI.PostPlayerChatMessage");
		
		AGameUI_PostPlayerChatMessage_Params params {};
		params.Message = Message;
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUI.PostGenericMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  MessageTexture                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGameUI::PostGenericMessage(const class FString& Message, class UTexture2D* MessageTexture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUI.PostGenericMessage");
		
		AGameUI_PostGenericMessage_Params params {};
		params.Message = Message;
		params.MessageTexture = MessageTexture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUI.PostChatMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FChatBoxMessage                             Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AGameUI::PostChatMessage(const struct FChatBoxMessage& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUI.PostChatMessage");
		
		AGameUI_PostChatMessage_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUI.OnDayNightChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsDayTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGameUI::OnDayNightChange(bool bIsDayTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUI.OnDayNightChange");
		
		AGameUI_OnDayNightChange_Params params {};
		params.bIsDayTime = bIsDayTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUI.NotifyPossessedPlayerChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalPlayerCharacter*                    NewPlayerCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGameUI::NotifyPossessedPlayerChanged(class ASurvivalPlayerCharacter* NewPlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUI.NotifyPossessedPlayerChanged");
		
		AGameUI_NotifyPossessedPlayerChanged_Params params {};
		params.NewPlayerCharacter = NewPlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUI.NotifyPlayerStateRegistered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalPlayerState*                        NewPlayerState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGameUI::NotifyPlayerStateRegistered(class ASurvivalPlayerState* NewPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUI.NotifyPlayerStateRegistered");
		
		AGameUI_NotifyPlayerStateRegistered_Params params {};
		params.NewPlayerState = NewPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUI.NotifyGlobalColorChanged
	 * 		Flags  -> ()
	 */
	void AGameUI::NotifyGlobalColorChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUI.NotifyGlobalColorChanged");
		
		AGameUI_NotifyGlobalColorChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUI.NotifyColorBlindChanged
	 * 		Flags  -> ()
	 */
	void AGameUI::NotifyColorBlindChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUI.NotifyColorBlindChanged");
		
		AGameUI_NotifyColorBlindChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUI.GetShowSubtitles
	 * 		Flags  -> ()
	 */
	bool AGameUI::GetShowSubtitles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUI.GetShowSubtitles");
		
		AGameUI_GetShowSubtitles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameUI.GetHUD
	 * 		Flags  -> ()
	 */
	class UHUDWidget* AGameUI::GetHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameUI.GetHUD");
		
		AGameUI_GetHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGameUI.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGameUI::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GameUI");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameVersionFunctionLibrary.GetGameVersionString
	 * 		Flags  -> ()
	 */
	class FString UGameVersionFunctionLibrary::GetGameVersionString()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameVersionFunctionLibrary.GetGameVersionString");
		
		UGameVersionFunctionLibrary_GetGameVersionString_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameVersionFunctionLibrary.GetGameVersion
	 * 		Flags  -> ()
	 */
	struct FGameVersion UGameVersionFunctionLibrary::GetGameVersion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameVersionFunctionLibrary.GetGameVersion");
		
		UGameVersionFunctionLibrary_GetGameVersion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameVersionFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameVersionFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GameVersionFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGameZoneVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGameZoneVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GameZoneVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.TickProduction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGardenBuilding::TickProduction(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.TickProduction");
		
		AGardenBuilding_TickProduction_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.ReceiveProductionTick
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGardenBuilding::ReceiveProductionTick(float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.ReceiveProductionTick");
		
		AGardenBuilding_ReceiveProductionTick_Params params {};
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.OnSpawnedActorDestroyed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               LODActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGardenBuilding::OnSpawnedActorDestroyed(class UBaseLODActor* LODActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.OnSpawnedActorDestroyed");
		
		AGardenBuilding_OnSpawnedActorDestroyed_Params params {};
		params.LODActor = LODActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.OnRep_RareSpawnList
	 * 		Flags  -> ()
	 */
	void AGardenBuilding::OnRep_RareSpawnList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.OnRep_RareSpawnList");
		
		AGardenBuilding_OnRep_RareSpawnList_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.OnRep_ProductionState
	 * 		Flags  -> ()
	 */
	void AGardenBuilding::OnRep_ProductionState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.OnRep_ProductionState");
		
		AGardenBuilding_OnRep_ProductionState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.OnRep_ModifierItems
	 * 		Flags  -> ()
	 */
	void AGardenBuilding::OnRep_ModifierItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.OnRep_ModifierItems");
		
		AGardenBuilding_OnRep_ModifierItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.OnRep_CurrentRecipe
	 * 		Flags  -> ()
	 */
	void AGardenBuilding::OnRep_CurrentRecipe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.OnRep_CurrentRecipe");
		
		AGardenBuilding_OnRep_CurrentRecipe_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.OnRep_CatalystItems
	 * 		Flags  -> ()
	 */
	void AGardenBuilding::OnRep_CatalystItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.OnRep_CatalystItems");
		
		AGardenBuilding_OnRep_CatalystItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.GetTimeRemaining
	 * 		Flags  -> ()
	 */
	float AGardenBuilding::GetTimeRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.GetTimeRemaining");
		
		AGardenBuilding_GetTimeRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.GetModifierItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> AGardenBuilding::GetModifierItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.GetModifierItems");
		
		AGardenBuilding_GetModifierItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.GetGardenModifier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGardenModifierType                                ModifierType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AGardenBuilding::GetGardenModifier(EGardenModifierType ModifierType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.GetGardenModifier");
		
		AGardenBuilding_GetGardenModifier_Params params {};
		params.ModifierType = ModifierType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.GetCurrentState
	 * 		Flags  -> ()
	 */
	EGardenState AGardenBuilding::GetCurrentState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.GetCurrentState");
		
		AGardenBuilding_GetCurrentState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.GetCatalystItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> AGardenBuilding::GetCatalystItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.GetCatalystItems");
		
		AGardenBuilding_GetCatalystItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.GetAllItemTags
	 * 		Flags  -> ()
	 */
	struct FGameplayTagContainer AGardenBuilding::GetAllItemTags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.GetAllItemTags");
		
		AGardenBuilding_GetAllItemTags_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.FindRecipeForSelectedCatalyst
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle AGardenBuilding::FindRecipeForSelectedCatalyst()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.FindRecipeForSelectedCatalyst");
		
		AGardenBuilding_FindRecipeForSelectedCatalyst_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.CanAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AGardenBuilding::CanAddItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.CanAddItem");
		
		AGardenBuilding_CanAddItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.CalculateRareSpawnChance
	 * 		Flags  -> ()
	 */
	float AGardenBuilding::CalculateRareSpawnChance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.CalculateRareSpawnChance");
		
		AGardenBuilding_CalculateRareSpawnChance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.CalculateProductionDuration
	 * 		Flags  -> ()
	 */
	float AGardenBuilding::CalculateProductionDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.CalculateProductionDuration");
		
		AGardenBuilding_CalculateProductionDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.AreModifiersFull
	 * 		Flags  -> ()
	 */
	bool AGardenBuilding::AreModifiersFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.AreModifiersFull");
		
		AGardenBuilding_AreModifiersFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GardenBuilding.AreCatalystsFull
	 * 		Flags  -> ()
	 */
	bool AGardenBuilding::AreCatalystsFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GardenBuilding.AreCatalystsFull");
		
		AGardenBuilding_AreCatalystsFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGardenBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGardenBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GardenBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalAIData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalAIData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GlobalAIData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalAudioData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalAudioData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GlobalAudioData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.RotateSnapCentered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FIntVector                                  Snap                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridKey                            Origin                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FIntVector UGlobalBuildingData::RotateSnapCentered(const struct FIntVector& Snap, const struct FBuildingGridKey& Origin, float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.RotateSnapCentered");
		
		UGlobalBuildingData_RotateSnapCentered_Params params {};
		params.Snap = Snap;
		params.Origin = Origin;
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.RotateSnap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FIntVector                                  Snap                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridKey                            Origin                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FIntVector UGlobalBuildingData::RotateSnap(const struct FIntVector& Snap, const struct FBuildingGridKey& Origin, float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.RotateSnap");
		
		UGlobalBuildingData_RotateSnap_Params params {};
		params.Snap = Snap;
		params.Origin = Origin;
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.RotateSlotCentered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            Slot                                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridKey                            Origin                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FBuildingGridKey UGlobalBuildingData::RotateSlotCentered(const struct FBuildingGridKey& Slot, const struct FBuildingGridKey& Origin, float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.RotateSlotCentered");
		
		UGlobalBuildingData_RotateSlotCentered_Params params {};
		params.Slot = Slot;
		params.Origin = Origin;
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.RotateSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            Slot                                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridKey                            Origin                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FBuildingGridKey UGlobalBuildingData::RotateSlot(const struct FBuildingGridKey& Slot, const struct FBuildingGridKey& Origin, float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.RotateSlot");
		
		UGlobalBuildingData_RotateSlot_Params params {};
		params.Slot = Slot;
		params.Origin = Origin;
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.GridToLocal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FIntVector                                  Position                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UGlobalBuildingData::GridToLocal(const struct FIntVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.GridToLocal");
		
		UGlobalBuildingData_GridToLocal_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.GetWeight
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                Class                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGlobalBuildingData::GetWeight(const struct FGameplayTag& Class)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.GetWeight");
		
		UGlobalBuildingData_GetWeight_Params params {};
		params.Class = Class;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.GetSturdiness
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                Class                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGlobalBuildingData::GetSturdiness(const struct FGameplayTag& Class)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.GetSturdiness");
		
		UGlobalBuildingData_GetSturdiness_Params params {};
		params.Class = Class;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.GetSnapOffset
	 * 		Flags  -> ()
	 */
	struct FVector UGlobalBuildingData::GetSnapOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.GetSnapOffset");
		
		UGlobalBuildingData_GetSnapOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.GetSlotDebugShape
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            GridLocation                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FQuat                                       Rotation                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FBox UGlobalBuildingData::GetSlotDebugShape(const struct FBuildingGridKey& GridLocation, struct FQuat* Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.GetSlotDebugShape");
		
		UGlobalBuildingData_GetSlotDebugShape_Params params {};
		params.GridLocation = GridLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Rotation != nullptr)
			*Rotation = params.Rotation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.GetSlotBounds
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingGridKey                            GridLocation                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FBox UGlobalBuildingData::GetSlotBounds(const struct FBuildingGridKey& GridLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.GetSlotBounds");
		
		UGlobalBuildingData_GetSlotBounds_Params params {};
		params.GridLocation = GridLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.GetMaxWeight
	 * 		Flags  -> ()
	 */
	int32_t UGlobalBuildingData::GetMaxWeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.GetMaxWeight");
		
		UGlobalBuildingData_GetMaxWeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.GetMaxSturdiness
	 * 		Flags  -> ()
	 */
	int32_t UGlobalBuildingData::GetMaxSturdiness()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.GetMaxSturdiness");
		
		UGlobalBuildingData_GetMaxSturdiness_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.GetMaxCozinessValue
	 * 		Flags  -> ()
	 */
	int32_t UGlobalBuildingData::GetMaxCozinessValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.GetMaxCozinessValue");
		
		UGlobalBuildingData_GetMaxCozinessValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.GetMaxCozinessLevel
	 * 		Flags  -> ()
	 */
	int32_t UGlobalBuildingData::GetMaxCozinessLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.GetMaxCozinessLevel");
		
		UGlobalBuildingData_GetMaxCozinessLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.GetEffectiveCozinessValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InCoziness                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InStructural                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGlobalBuildingData::GetEffectiveCozinessValue(int32_t InCoziness, int32_t InStructural)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.GetEffectiveCozinessValue");
		
		UGlobalBuildingData_GetEffectiveCozinessValue_Params params {};
		params.InCoziness = InCoziness;
		params.InStructural = InStructural;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.GetCozinessLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InCoziness                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InStructural                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGlobalBuildingData::GetCozinessLevel(int32_t InCoziness, int32_t InStructural)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.GetCozinessLevel");
		
		UGlobalBuildingData_GetCozinessLevel_Params params {};
		params.InCoziness = InCoziness;
		params.InStructural = InStructural;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.DrawDebugSnap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  GridTransform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FIntVector                                  Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGlobalBuildingData::DrawDebugSnap(class UObject* WorldContextObject, const struct FTransform& GridTransform, const struct FIntVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.DrawDebugSnap");
		
		UGlobalBuildingData_DrawDebugSnap_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.GridTransform = GridTransform;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalBuildingData.DrawDebugCell
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  GridTransform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridKey                            Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FColor                                      Color                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGlobalBuildingData::DrawDebugCell(class UObject* WorldContextObject, const struct FTransform& GridTransform, const struct FBuildingGridKey& Key, const struct FColor& Color)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalBuildingData.DrawDebugCell");
		
		UGlobalBuildingData_DrawDebugCell_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.GridTransform = GridTransform;
		params.Key = Key;
		params.Color = Color;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalBuildingData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalBuildingData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GlobalBuildingData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalColorTheme.SetColorListColorByName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ListName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ColorName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                Color                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGlobalColorTheme::SetColorListColorByName(const class FName& ListName, const class FName& ColorName, const struct FLinearColor& Color)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalColorTheme.SetColorListColorByName");
		
		UGlobalColorTheme_SetColorListColorByName_Params params {};
		params.ListName = ListName;
		params.ColorName = ColorName;
		params.Color = Color;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalColorTheme.ProduceColorblindCaches
	 * 		Flags  -> ()
	 */
	void UGlobalColorTheme::ProduceColorblindCaches()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalColorTheme.ProduceColorblindCaches");
		
		UGlobalColorTheme_ProduceColorblindCaches_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalColorTheme.GetColorListColorByName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ListName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ColorName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLinearColor UGlobalColorTheme::GetColorListColorByName(const class FName& ListName, const class FName& ColorName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalColorTheme.GetColorListColorByName");
		
		UGlobalColorTheme_GetColorListColorByName_Params params {};
		params.ListName = ListName;
		params.ColorName = ColorName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalColorTheme.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalColorTheme::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GlobalColorTheme");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalCombatData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalCombatData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GlobalCombatData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlMetadataLibrary.GetControlDisplayName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FControlMetadata                            MetaData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisplayingForGamepad                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLocString UControlMetadataLibrary::GetControlDisplayName(const struct FControlMetadata& MetaData, bool bDisplayingForGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlMetadataLibrary.GetControlDisplayName");
		
		UControlMetadataLibrary_GetControlDisplayName_Params params {};
		params.MetaData = MetaData;
		params.bDisplayingForGamepad = bDisplayingForGamepad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlMetadataLibrary.GetConflictCategoryMask
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FControlMetadata                            MetaData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	int32_t UControlMetadataLibrary::GetConflictCategoryMask(const struct FControlMetadata& MetaData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlMetadataLibrary.GetConflictCategoryMask");
		
		UControlMetadataLibrary_GetConflictCategoryMask_Params params {};
		params.MetaData = MetaData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlMetadataLibrary.AxisMappingToAnyMapping
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputAxisKeyMapping                        InMapping                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FAnyControlMapping UControlMetadataLibrary::AxisMappingToAnyMapping(const struct FInputAxisKeyMapping& InMapping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlMetadataLibrary.AxisMappingToAnyMapping");
		
		UControlMetadataLibrary_AxisMappingToAnyMapping_Params params {};
		params.InMapping = InMapping;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ControlMetadataLibrary.ActionMappingToAnyMapping
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputActionKeyMapping                      InMapping                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FAnyControlMapping UControlMetadataLibrary::ActionMappingToAnyMapping(const struct FInputActionKeyMapping& InMapping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ControlMetadataLibrary.ActionMappingToAnyMapping");
		
		UControlMetadataLibrary_ActionMappingToAnyMapping_Params params {};
		params.InMapping = InMapping;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UControlMetadataLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UControlMetadataLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ControlMetadataLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalControlsData.GetConflictsWithMask
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EControlConflictContext                            Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGlobalControlsData::GetConflictsWithMask(EControlConflictContext Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalControlsData.GetConflictsWithMask");
		
		UGlobalControlsData_GetConflictsWithMask_Params params {};
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalControlsData.FindMetadata
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAnyControlMappingKey                       Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FControlMetadata                            OutData                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool UGlobalControlsData::FindMetadata(const struct FAnyControlMappingKey& Key, struct FControlMetadata* OutData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalControlsData.FindMetadata");
		
		UGlobalControlsData_FindMetadata_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutData != nullptr)
			*OutData = params.OutData;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalControlsData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalControlsData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GlobalControlsData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalFoliageData.GetFoliagePlayerSwapDistanceFromMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 StaticMesh                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGlobalFoliageData::GetFoliagePlayerSwapDistanceFromMesh(class UStaticMesh* StaticMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalFoliageData.GetFoliagePlayerSwapDistanceFromMesh");
		
		UGlobalFoliageData_GetFoliagePlayerSwapDistanceFromMesh_Params params {};
		params.StaticMesh = StaticMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalFoliageData.GetFoliagePlayerSwapDistanceFromKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGlobalFoliageData::GetFoliagePlayerSwapDistanceFromKey(const struct FFoliageKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalFoliageData.GetFoliagePlayerSwapDistanceFromKey");
		
		UGlobalFoliageData_GetFoliagePlayerSwapDistanceFromKey_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalFoliageData.GetFoliageDefaultStateFromMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 StaticMesh                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EFoliageInstanceState UGlobalFoliageData::GetFoliageDefaultStateFromMesh(class UStaticMesh* StaticMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalFoliageData.GetFoliageDefaultStateFromMesh");
		
		UGlobalFoliageData_GetFoliageDefaultStateFromMesh_Params params {};
		params.StaticMesh = StaticMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalFoliageData.GetFoliageDefaultStateFromKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EFoliageInstanceState UGlobalFoliageData::GetFoliageDefaultStateFromKey(const struct FFoliageKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalFoliageData.GetFoliageDefaultStateFromKey");
		
		UGlobalFoliageData_GetFoliageDefaultStateFromKey_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalFoliageData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalFoliageData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GlobalFoliageData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalItemData.GetRecipeModData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FRecipeModData UGlobalItemData::GetRecipeModData(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalItemData.GetRecipeModData");
		
		UGlobalItemData_GetRecipeModData_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalItemData.GetBonusEnhancementTypes
	 * 		Flags  -> ()
	 */
	TArray<struct FGameplayTag> UGlobalItemData::GetBonusEnhancementTypes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalItemData.GetBonusEnhancementTypes");
		
		UGlobalItemData_GetBonusEnhancementTypes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalItemData.GetBonusEnhancementRepairItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                BonusEnhancementType                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle UGlobalItemData::GetBonusEnhancementRepairItem(const struct FGameplayTag& BonusEnhancementType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalItemData.GetBonusEnhancementRepairItem");
		
		UGlobalItemData_GetBonusEnhancementRepairItem_Params params {};
		params.BonusEnhancementType = BonusEnhancementType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalItemData.GetBonusEnhancementItemCost
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            BonusEnhancementLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGlobalItemData::GetBonusEnhancementItemCost(int32_t BonusEnhancementLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalItemData.GetBonusEnhancementItemCost");
		
		UGlobalItemData_GetBonusEnhancementItemCost_Params params {};
		params.BonusEnhancementLevel = BonusEnhancementLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalItemData.GetBonusEnhancementItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                BonusEnhancementType                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            BonusEnhancementLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle UGlobalItemData::GetBonusEnhancementItem(const struct FGameplayTag& BonusEnhancementType, int32_t BonusEnhancementLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalItemData.GetBonusEnhancementItem");
		
		UGlobalItemData_GetBonusEnhancementItem_Params params {};
		params.BonusEnhancementType = BonusEnhancementType;
		params.BonusEnhancementLevel = BonusEnhancementLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalItemData.GetBonusEnhancementDamageType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                BonusEnhancementType                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* UGlobalItemData::GetBonusEnhancementDamageType(const struct FGameplayTag& BonusEnhancementType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalItemData.GetBonusEnhancementDamageType");
		
		UGlobalItemData_GetBonusEnhancementDamageType_Params params {};
		params.BonusEnhancementType = BonusEnhancementType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalItemData.GetBaseEnhancementItemCost
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            EnhancementLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGlobalItemData::GetBaseEnhancementItemCost(int32_t EnhancementLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalItemData.GetBaseEnhancementItemCost");
		
		UGlobalItemData_GetBaseEnhancementItemCost_Params params {};
		params.EnhancementLevel = EnhancementLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalItemData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalItemData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GlobalItemData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalSaveLoadData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalSaveLoadData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GlobalSaveLoadData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalTableData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalTableData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GlobalTableData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalTamingData.HungerToHappiness
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Hunger                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGlobalTamingData::HungerToHappiness(float Hunger)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalTamingData.HungerToHappiness");
		
		UGlobalTamingData_HungerToHappiness_Params params {};
		params.Hunger = Hunger;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalTamingData.HappinessToHunger
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Happiness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGlobalTamingData::HappinessToHunger(float Happiness)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalTamingData.HappinessToHunger");
		
		UGlobalTamingData_HappinessToHunger_Params params {};
		params.Happiness = Happiness;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalTamingData.GetHappinessStepIndexFromHunger
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Hunger                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGlobalTamingData::GetHappinessStepIndexFromHunger(float Hunger)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalTamingData.GetHappinessStepIndexFromHunger");
		
		UGlobalTamingData_GetHappinessStepIndexFromHunger_Params params {};
		params.Hunger = Hunger;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalTamingData.GetHappinessStepIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Happiness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGlobalTamingData::GetHappinessStepIndex(float Happiness)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalTamingData.GetHappinessStepIndex");
		
		UGlobalTamingData_GetHappinessStepIndex_Params params {};
		params.Happiness = Happiness;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalTamingData.GetHappinessStepData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Happiness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTamingHappinessStep UGlobalTamingData::GetHappinessStepData(float Happiness)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalTamingData.GetHappinessStepData");
		
		UGlobalTamingData_GetHappinessStepData_Params params {};
		params.Happiness = Happiness;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalTamingData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalTamingData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GlobalTamingData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalUIData.GetMarkerBuildingHiddenIconIndex
	 * 		Flags  -> ()
	 */
	int32_t UGlobalUIData::GetMarkerBuildingHiddenIconIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalUIData.GetMarkerBuildingHiddenIconIndex");
		
		UGlobalUIData_GetMarkerBuildingHiddenIconIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalUIData.GetMarkerBuildingBurgleIconIndex
	 * 		Flags  -> ()
	 */
	int32_t UGlobalUIData::GetMarkerBuildingBurgleIconIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalUIData.GetMarkerBuildingBurgleIconIndex");
		
		UGlobalUIData_GetMarkerBuildingBurgleIconIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalUIData.GetKeyNarrationName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UGlobalUIData::GetKeyNarrationName(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalUIData.GetKeyNarrationName");
		
		UGlobalUIData_GetKeyNarrationName_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GlobalUIData.GetChordNarrationName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputChord                                 Chord                                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UGlobalUIData::GetChordNarrationName(const struct FInputChord& Chord)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GlobalUIData.GetChordNarrationName");
		
		UGlobalUIData_GetChordNarrationName_Params params {};
		params.Chord = Chord;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalUIData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalUIData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GlobalUIData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GoapAction.ExecuteReal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCharacterLODActor*                          Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGoapActionOwner                            Owner                                                      (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EGoapActionResult UGoapAction::ExecuteReal(class UCharacterLODActor* Actor, struct FGoapActionOwner* Owner, const struct FVector& TargetLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GoapAction.ExecuteReal");
		
		UGoapAction_ExecuteReal_Params params {};
		params.Actor = Actor;
		params.TargetLocation = TargetLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Owner != nullptr)
			*Owner = params.Owner;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GoapAction.CanExecuteReal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCharacterLODActor*                          Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGoapActionOwner                            Owner                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGoapAction::CanExecuteReal(class UCharacterLODActor* Actor, const struct FGoapActionOwner& Owner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GoapAction.CanExecuteReal");
		
		UGoapAction_CanExecuteReal_Params params {};
		params.Actor = Actor;
		params.Owner = Owner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GoapAction.CanActorExecuteEver
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCharacterLODActor*                          Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGoapActionOwner                            Owner                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGoapAction::CanActorExecuteEver(class UCharacterLODActor* Actor, const struct FGoapActionOwner& Owner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GoapAction.CanActorExecuteEver");
		
		UGoapAction_CanActorExecuteEver_Params params {};
		params.Actor = Actor;
		params.Owner = Owner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionAdjustVitals.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionAdjustVitals::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionAdjustVitals");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionActivityMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionActivityMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionActivityMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GoapActionUseHeldItem.IsUsableData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemDataHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FGoapActionOwner                            Owner                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGoapActionUseHeldItem::IsUsableData(const struct FDataTableRowHandle& ItemDataHandle, const struct FGoapActionOwner& Owner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GoapActionUseHeldItem.IsUsableData");
		
		UGoapActionUseHeldItem_IsUsableData_Params params {};
		params.ItemDataHandle = ItemDataHandle;
		params.Owner = Owner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GoapActionUseHeldItem.IsUsable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGoapActionOwner                            Owner                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGoapActionUseHeldItem::IsUsable(class UItem* Item, const struct FGoapActionOwner& Owner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GoapActionUseHeldItem.IsUsable");
		
		UGoapActionUseHeldItem_IsUsable_Params params {};
		params.Item = Item;
		params.Owner = Owner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionUseHeldItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionUseHeldItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionUseHeldItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionBuild.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionBuild::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionBuild");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionCacheData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionCacheData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionCacheData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionCache.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionCache::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionCache");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionConsumeItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionConsumeItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionConsumeItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionConsumeItemDynamic.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionConsumeItemDynamic::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionConsumeItemDynamic");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionDeliverItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionDeliverItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionDeliverItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionDropItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionDropItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionDropItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionRemoveItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionRemoveItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionRemoveItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionDumpItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionDumpItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionDumpItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionGetItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionGetItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionGetItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionGetItemDynamic.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionGetItemDynamic::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionGetItemDynamic");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionHarvest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionHarvest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionHarvest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionHoldItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionHoldItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionHoldItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GoapActionInstanceFunctionLibrary.GetGoapActionInstanceLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGoapActionInstance                         ActionInstance                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UGoapActionInstanceFunctionLibrary::GetGoapActionInstanceLocation(const struct FGoapActionInstance& ActionInstance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GoapActionInstanceFunctionLibrary.GetGoapActionInstanceLocation");
		
		UGoapActionInstanceFunctionLibrary_GetGoapActionInstanceLocation_Params params {};
		params.ActionInstance = ActionInstance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionInstanceFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionInstanceFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionInstanceFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionKill.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionKill::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionKill");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GoapActionProviderInterface.AllocateGOAPActions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USurvivalGameInstance*                       GameInstance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InOwner                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UGoapAction*> UGoapActionProviderInterface::AllocateGOAPActions(class USurvivalGameInstance* GameInstance, class UObject* InOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GoapActionProviderInterface.AllocateGOAPActions");
		
		UGoapActionProviderInterface_AllocateGOAPActions_Params params {};
		params.GameInstance = GameInstance;
		params.InOwner = InOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionProviderInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionProviderInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionProviderInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionSpawnActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionSpawnActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionSpawnActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapActionSpawnEgg.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapActionSpawnEgg::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapActionSpawnEgg");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapWorldStateEvaluator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapWorldStateEvaluator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapWorldStateEvaluator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapColonyPopulationEvaluator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapColonyPopulationEvaluator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapColonyPopulationEvaluator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapItemsInRegionEvaluator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapItemsInRegionEvaluator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapItemsInRegionEvaluator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGoapSphereRegionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGoapSphereRegionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GoapSphereRegionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GridLaddersComponent.RebuildDirty
	 * 		Flags  -> ()
	 */
	void UGridLaddersComponent::RebuildDirty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GridLaddersComponent.RebuildDirty");
		
		UGridLaddersComponent_RebuildDirty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GridLaddersComponent.RebuildAll
	 * 		Flags  -> ()
	 */
	void UGridLaddersComponent::RebuildAll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GridLaddersComponent.RebuildAll");
		
		UGridLaddersComponent_RebuildAll_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GridLaddersComponent.HandleBuildingUnregistered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBuildingGridComponent*                      Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridBuilding                       Building                                                   (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridKey                            Slot                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGridLaddersComponent::HandleBuildingUnregistered(class UBuildingGridComponent* Sender, const struct FBuildingGridBuilding& Building, const struct FBuildingGridKey& Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GridLaddersComponent.HandleBuildingUnregistered");
		
		UGridLaddersComponent_HandleBuildingUnregistered_Params params {};
		params.Sender = Sender;
		params.Building = Building;
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GridLaddersComponent.HandleBuildingRegistered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBuildingGridComponent*                      Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridBuilding                       Building                                                   (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridKey                            Slot                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGridLaddersComponent::HandleBuildingRegistered(class UBuildingGridComponent* Sender, const struct FBuildingGridBuilding& Building, const struct FBuildingGridKey& Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GridLaddersComponent.HandleBuildingRegistered");
		
		UGridLaddersComponent_HandleBuildingRegistered_Params params {};
		params.Sender = Sender;
		params.Building = Building;
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GridLaddersComponent.HandleBuildingBuilt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBuildingGridComponent*                      Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridBuilding                       Building                                                   (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridKey                            Slot                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGridLaddersComponent::HandleBuildingBuilt(class UBuildingGridComponent* Sender, const struct FBuildingGridBuilding& Building, const struct FBuildingGridKey& Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GridLaddersComponent.HandleBuildingBuilt");
		
		UGridLaddersComponent_HandleBuildingBuilt_Params params {};
		params.Sender = Sender;
		params.Building = Building;
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGridLaddersComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGridLaddersComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GridLaddersComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGroundLevelAssetUserData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGroundLevelAssetUserData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GroundLevelAssetUserData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HarvestNode.SetAdditiveRotationQuat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FQuat                                       Rotation                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AHarvestNode::SetAdditiveRotationQuat(class UObject* Source, const struct FQuat& Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HarvestNode.SetAdditiveRotationQuat");
		
		AHarvestNode_SetAdditiveRotationQuat_Params params {};
		params.Source = Source;
		params.Rotation = Rotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HarvestNode.SetAdditiveRotation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AHarvestNode::SetAdditiveRotation(class UObject* Source, const struct FRotator& Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HarvestNode.SetAdditiveRotation");
		
		AHarvestNode_SetAdditiveRotation_Params params {};
		params.Source = Source;
		params.Rotation = Rotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HarvestNode.OnDeath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AHarvestNode::OnDeath(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HarvestNode.OnDeath");
		
		AHarvestNode_OnDeath_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HarvestNode.OnDamaged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsKillingBlow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AHarvestNode::OnDamaged(float Damage, const struct FDamageInfo& DamageInfo, class AController* InstigatedBy, class UBaseLODActor* DamageCauser, bool IsKillingBlow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HarvestNode.OnDamaged");
		
		AHarvestNode_OnDamaged_Params params {};
		params.Damage = Damage;
		params.DamageInfo = DamageInfo;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		params.IsKillingBlow = IsKillingBlow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HarvestNode.HasTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                InTag                                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AHarvestNode::HasTag(const struct FGameplayTag& InTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HarvestNode.HasTag");
		
		AHarvestNode_HasTag_Params params {};
		params.InTag = InTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HarvestNode.HasAnyTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTagContainer                       InTags                                                     (Parm, NativeAccessSpecifierPublic)
	 */
	bool AHarvestNode::HasAnyTag(const struct FGameplayTagContainer& InTags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HarvestNode.HasAnyTag");
		
		AHarvestNode_HasAnyTag_Params params {};
		params.InTags = InTags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHarvestNode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHarvestNode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HarvestNode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyHarvestNodeActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyHarvestNodeActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyHarvestNodeActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHarvestNodeLODActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHarvestNodeLODActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HarvestNodeLODActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHatchingDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHatchingDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HatchingDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.ServerRemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHaulingComponent::ServerRemoveItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.ServerRemoveItem");
		
		UHaulingComponent_ServerRemoveItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.ServerDropItem
	 * 		Flags  -> ()
	 */
	void UHaulingComponent::ServerDropItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.ServerDropItem");
		
		UHaulingComponent_ServerDropItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.ServerDropAll
	 * 		Flags  -> ()
	 */
	void UHaulingComponent::ServerDropAll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.ServerDropAll");
		
		UHaulingComponent_ServerDropAll_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.ServerAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHaulingComponent::ServerAddItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.ServerAddItem");
		
		UHaulingComponent_ServerAddItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.RemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UHaulingComponent::RemoveItem(class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.RemoveItem");
		
		UHaulingComponent_RemoveItem_Params params {};
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.OnStatusEffectChanged
	 * 		Flags  -> ()
	 */
	void UHaulingComponent::OnStatusEffectChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.OnStatusEffectChanged");
		
		UHaulingComponent_OnStatusEffectChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.OnRep_HauledItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UItem*>                               PreviousHauledItems                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UHaulingComponent::OnRep_HauledItems(TArray<class UItem*> PreviousHauledItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.OnRep_HauledItems");
		
		UHaulingComponent_OnRep_HauledItems_Params params {};
		params.PreviousHauledItems = PreviousHauledItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.OnDeath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UHaulingComponent::OnDeath(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.OnDeath");
		
		UHaulingComponent_OnDeath_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.OnDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsKillingBlow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHaulingComponent::OnDamage(float Damage, const struct FDamageInfo& DamageInfo, class AController* InstigatedBy, class UBaseLODActor* DamageCauser, bool IsKillingBlow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.OnDamage");
		
		UHaulingComponent_OnDamage_Params params {};
		params.Damage = Damage;
		params.DamageInfo = DamageInfo;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		params.IsKillingBlow = IsKillingBlow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.OnCharacterMovementChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACharacter*                                  Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMovementMode                                      PrevMovementMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      PreviousCustomMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHaulingComponent::OnCharacterMovementChanged(class ACharacter* Character, EMovementMode PrevMovementMode, unsigned char PreviousCustomMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.OnCharacterMovementChanged");
		
		UHaulingComponent_OnCharacterMovementChanged_Params params {};
		params.Character = Character;
		params.PrevMovementMode = PrevMovementMode;
		params.PreviousCustomMode = PreviousCustomMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.OnAttackLaunch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAttack*                                     Attack                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHaulingComponent::OnAttackLaunch(class UAttack* Attack)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.OnAttackLaunch");
		
		UHaulingComponent_OnAttackLaunch_Params params {};
		params.Attack = Attack;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.IsHaulingThrowableItems
	 * 		Flags  -> ()
	 */
	bool UHaulingComponent::IsHaulingThrowableItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.IsHaulingThrowableItems");
		
		UHaulingComponent_IsHaulingThrowableItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.IsHaulingItems
	 * 		Flags  -> ()
	 */
	bool UHaulingComponent::IsHaulingItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.IsHaulingItems");
		
		UHaulingComponent_IsHaulingItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.IsHaulingItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UHaulingComponent::IsHaulingItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.IsHaulingItem");
		
		UHaulingComponent_IsHaulingItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.InputDropPressed
	 * 		Flags  -> ()
	 */
	void UHaulingComponent::InputDropPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.InputDropPressed");
		
		UHaulingComponent_InputDropPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.GetItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UHaulingComponent::GetItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.GetItems");
		
		UHaulingComponent_GetItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.GetHaulingItemCount
	 * 		Flags  -> ()
	 */
	int32_t UHaulingComponent::GetHaulingItemCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.GetHaulingItemCount");
		
		UHaulingComponent_GetHaulingItemCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.GetDropItemTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform UHaulingComponent::GetDropItemTransform(class UItem* Item, const struct FVector& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.GetDropItemTransform");
		
		UHaulingComponent_GetDropItemTransform_Params params {};
		params.Item = Item;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.GetAdjustedCapacity
	 * 		Flags  -> ()
	 */
	int32_t UHaulingComponent::GetAdjustedCapacity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.GetAdjustedCapacity");
		
		UHaulingComponent_GetAdjustedCapacity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.ClientOnItemAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UHaulingComponent::ClientOnItemAdded(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.ClientOnItemAdded");
		
		UHaulingComponent_ClientOnItemAdded_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.CanAddItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UItem*>                               Items                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UHaulingComponent::CanAddItems(TArray<class UItem*> Items)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.CanAddItems");
		
		UHaulingComponent_CanAddItems_Params params {};
		params.Items = Items;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.CanAddItemRowHandles
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 ItemRowHandles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UHaulingComponent::CanAddItemRowHandles(TArray<struct FDataTableRowHandle> ItemRowHandles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.CanAddItemRowHandles");
		
		UHaulingComponent_CanAddItemRowHandles_Params params {};
		params.ItemRowHandles = ItemRowHandles;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.CanAddItemRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UHaulingComponent::CanAddItemRowHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.CanAddItemRowHandle");
		
		UHaulingComponent_CanAddItemRowHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.CanAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UHaulingComponent::CanAddItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.CanAddItem");
		
		UHaulingComponent_CanAddItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingComponent.AddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNewItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHaulingComponent::AddItem(class UItem* Item, bool bIsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingComponent.AddItem");
		
		UHaulingComponent_AddItem_Params params {};
		params.Item = Item;
		params.bIsNewItem = bIsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHaulingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHaulingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HaulingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyHaulingComponent.RemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UProxyHaulingComponent::RemoveItem(class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyHaulingComponent.RemoveItem");
		
		UProxyHaulingComponent_RemoveItem_Params params {};
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyHaulingComponent.GetItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UProxyHaulingComponent::GetItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyHaulingComponent.GetItems");
		
		UProxyHaulingComponent_GetItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyHaulingComponent.GetDropItemTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform UProxyHaulingComponent::GetDropItemTransform(class UItem* Item, const struct FVector& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyHaulingComponent.GetDropItemTransform");
		
		UProxyHaulingComponent_GetDropItemTransform_Params params {};
		params.Item = Item;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyHaulingComponent.GetAdjustedCapacity
	 * 		Flags  -> ()
	 */
	int32_t UProxyHaulingComponent::GetAdjustedCapacity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyHaulingComponent.GetAdjustedCapacity");
		
		UProxyHaulingComponent_GetAdjustedCapacity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyHaulingComponent.CanAddItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UItem*>                               Items                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UProxyHaulingComponent::CanAddItems(TArray<class UItem*> Items)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyHaulingComponent.CanAddItems");
		
		UProxyHaulingComponent_CanAddItems_Params params {};
		params.Items = Items;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyHaulingComponent.CanAddItemRowHandles
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 ItemRowHandles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UProxyHaulingComponent::CanAddItemRowHandles(TArray<struct FDataTableRowHandle> ItemRowHandles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyHaulingComponent.CanAddItemRowHandles");
		
		UProxyHaulingComponent_CanAddItemRowHandles_Params params {};
		params.ItemRowHandles = ItemRowHandles;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyHaulingComponent.CanAddItemRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UProxyHaulingComponent::CanAddItemRowHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyHaulingComponent.CanAddItemRowHandle");
		
		UProxyHaulingComponent_CanAddItemRowHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyHaulingComponent.CanAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UProxyHaulingComponent::CanAddItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyHaulingComponent.CanAddItem");
		
		UProxyHaulingComponent_CanAddItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyHaulingComponent.AddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNewItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UProxyHaulingComponent::AddItem(class UItem* Item, bool bIsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyHaulingComponent.AddItem");
		
		UProxyHaulingComponent_AddItem_Params params {};
		params.Item = Item;
		params.bIsNewItem = bIsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyHaulingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyHaulingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyHaulingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingLODComponent.RemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UHaulingLODComponent::RemoveItem(class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingLODComponent.RemoveItem");
		
		UHaulingLODComponent_RemoveItem_Params params {};
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingLODComponent.GetItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UHaulingLODComponent::GetItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingLODComponent.GetItems");
		
		UHaulingLODComponent_GetItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingLODComponent.GetDropItemTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform UHaulingLODComponent::GetDropItemTransform(class UItem* Item, const struct FVector& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingLODComponent.GetDropItemTransform");
		
		UHaulingLODComponent_GetDropItemTransform_Params params {};
		params.Item = Item;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingLODComponent.CanAddItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UItem*>                               Items                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UHaulingLODComponent::CanAddItems(TArray<class UItem*> Items)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingLODComponent.CanAddItems");
		
		UHaulingLODComponent_CanAddItems_Params params {};
		params.Items = Items;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingLODComponent.CanAddItemRowHandles
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 ItemRowHandles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UHaulingLODComponent::CanAddItemRowHandles(TArray<struct FDataTableRowHandle> ItemRowHandles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingLODComponent.CanAddItemRowHandles");
		
		UHaulingLODComponent_CanAddItemRowHandles_Params params {};
		params.ItemRowHandles = ItemRowHandles;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingLODComponent.CanAddItemRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UHaulingLODComponent::CanAddItemRowHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingLODComponent.CanAddItemRowHandle");
		
		UHaulingLODComponent_CanAddItemRowHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingLODComponent.CanAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UHaulingLODComponent::CanAddItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingLODComponent.CanAddItem");
		
		UHaulingLODComponent_CanAddItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HaulingLODComponent.AddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNewItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHaulingLODComponent::AddItem(class UItem* Item, bool bIsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HaulingLODComponent.AddItem");
		
		UHaulingLODComponent_AddItem_Params params {};
		params.Item = Item;
		params.bIsNewItem = bIsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHaulingLODComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHaulingLODComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HaulingLODComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Hazard.SetProjectileAttackOwner
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      NewOwner                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AHazard::SetProjectileAttackOwner(class AActor* NewOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Hazard.SetProjectileAttackOwner");
		
		AHazard_SetProjectileAttackOwner_Params params {};
		params.NewOwner = NewOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Hazard.OnRep_HazardEnding
	 * 		Flags  -> ()
	 */
	void AHazard::OnRep_HazardEnding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Hazard.OnRep_HazardEnding");
		
		AHazard_OnRep_HazardEnding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Hazard.OnRep_HazardEnabled
	 * 		Flags  -> ()
	 */
	void AHazard::OnRep_HazardEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Hazard.OnRep_HazardEnabled");
		
		AHazard_OnRep_HazardEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Hazard.OnEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AHazard::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Hazard.OnEndOverlap");
		
		AHazard_OnEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Hazard.OnBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AHazard::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Hazard.OnBeginOverlap");
		
		AHazard_OnBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Hazard.IsHazardExpired
	 * 		Flags  -> ()
	 */
	bool AHazard::IsHazardExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Hazard.IsHazardExpired");
		
		AHazard_IsHazardExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Hazard.HazardExpired
	 * 		Flags  -> ()
	 */
	void AHazard::HazardExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Hazard.HazardExpired");
		
		AHazard_HazardExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Hazard.HandleHazardEnding
	 * 		Flags  -> ()
	 */
	void AHazard::HandleHazardEnding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Hazard.HandleHazardEnding");
		
		AHazard_HandleHazardEnding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Hazard.GetProjectileAttack
	 * 		Flags  -> ()
	 */
	class UAttack* AHazard::GetProjectileAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Hazard.GetProjectileAttack");
		
		AHazard_GetProjectileAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Hazard.GetHazardEnabled
	 * 		Flags  -> ()
	 */
	bool AHazard::GetHazardEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Hazard.GetHazardEnabled");
		
		AHazard_GetHazardEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Hazard.EnableHazard
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AHazard::EnableHazard(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Hazard.EnableHazard");
		
		AHazard_EnableHazard_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHazard.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHazard::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Hazard");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHazardBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHazardBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HazardBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHazardCapsule.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHazardCapsule::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HazardCapsule");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHazardSphere.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHazardSphere::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HazardSphere");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HazardVolume.OnVolumeEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AHazardVolume::OnVolumeEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HazardVolume.OnVolumeEndOverlap");
		
		AHazardVolume_OnVolumeEndOverlap_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HazardVolume.OnVolumeBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AHazardVolume::OnVolumeBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HazardVolume.OnVolumeBeginOverlap");
		
		AHazardVolume_OnVolumeBeginOverlap_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHazardVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHazardVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HazardVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.ToggleShowHealthDebug
	 * 		Flags  -> ()
	 */
	void UHealthComponent::ToggleShowHealthDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.ToggleShowHealthDebug");
		
		UHealthComponent_ToggleShowHealthDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.ShowDamageInteractUI
	 * 		Flags  -> ()
	 */
	bool UHealthComponent::ShowDamageInteractUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.ShowDamageInteractUI");
		
		UHealthComponent_ShowDamageInteractUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.SetCurrentHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DesiredHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthComponent::SetCurrentHealth(float DesiredHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.SetCurrentHealth");
		
		UHealthComponent_SetCurrentHealth_Params params {};
		params.DesiredHealth = DesiredHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.SetCurrentDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DesiredDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthComponent::SetCurrentDamage(float DesiredDamage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.SetCurrentDamage");
		
		UHealthComponent_SetCurrentDamage_Params params {};
		params.DesiredDamage = DesiredDamage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.ServerKill
	 * 		Flags  -> ()
	 */
	void UHealthComponent::ServerKill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.ServerKill");
		
		UHealthComponent_ServerKill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.ServerIncapacitate
	 * 		Flags  -> ()
	 */
	void UHealthComponent::ServerIncapacitate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.ServerIncapacitate");
		
		UHealthComponent_ServerIncapacitate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.Revive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InReviver                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthComponent::Revive(class AActor* InReviver)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.Revive");
		
		UHealthComponent_Revive_Params params {};
		params.InReviver = InReviver;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.Restore
	 * 		Flags  -> ()
	 */
	void UHealthComponent::Restore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.Restore");
		
		UHealthComponent_Restore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.OnStatusEffectChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStatusEffect*                               StatusEffect                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthComponent::OnStatusEffectChanged(class AActor* Owner, class UStatusEffect* StatusEffect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.OnStatusEffectChanged");
		
		UHealthComponent_OnStatusEffectChanged_Params params {};
		params.Owner = Owner;
		params.StatusEffect = StatusEffect;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.OnRest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              RestDuration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthComponent::OnRest(float RestDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.OnRest");
		
		UHealthComponent_OnRest_Params params {};
		params.RestDuration = RestDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.OnRep_Reviver
	 * 		Flags  -> ()
	 */
	void UHealthComponent::OnRep_Reviver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.OnRep_Reviver");
		
		UHealthComponent_OnRep_Reviver_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.OnRep_HealthState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHealthState                                       PrevHealthState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthComponent::OnRep_HealthState(EHealthState PrevHealthState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.OnRep_HealthState");
		
		UHealthComponent_OnRep_HealthState_Params params {};
		params.PrevHealthState = PrevHealthState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.OnRep_CurrentFragilityLevel
	 * 		Flags  -> ()
	 */
	void UHealthComponent::OnRep_CurrentFragilityLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.OnRep_CurrentFragilityLevel");
		
		UHealthComponent_OnRep_CurrentFragilityLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.OnRep_CurrentDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              PrevDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthComponent::OnRep_CurrentDamage(float PrevDamage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.OnRep_CurrentDamage");
		
		UHealthComponent_OnRep_CurrentDamage_Params params {};
		params.PrevDamage = PrevDamage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.OnPlayerScalingCountChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAuraReceiverComponent*                      Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            AuraCount                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthComponent::OnPlayerScalingCountChanged(class UAuraReceiverComponent* Sender, int32_t AuraCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.OnPlayerScalingCountChanged");
		
		UHealthComponent_OnPlayerScalingCountChanged_Params params {};
		params.Sender = Sender;
		params.AuraCount = AuraCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.OnCombatChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInCombat                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthComponent::OnCombatChanged(class ASurvivalCharacter* Character, bool bInCombat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.OnCombatChanged");
		
		UHealthComponent_OnCombatChanged_Params params {};
		params.Character = Character;
		params.bInCombat = bInCombat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.MulticastHandleEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EPlayEffectType                                    PlayEffectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthComponent::MulticastHandleEffects(const struct FVector& HitLocation, float Damage, const struct FDamageInfo& DamageInfo, EPlayEffectType PlayEffectType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.MulticastHandleEffects");
		
		UHealthComponent_MulticastHandleEffects_Params params {};
		params.HitLocation = HitLocation;
		params.Damage = Damage;
		params.DamageInfo = DamageInfo;
		params.PlayEffectType = PlayEffectType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.Kill
	 * 		Flags  -> ()
	 */
	void UHealthComponent::Kill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.Kill");
		
		UHealthComponent_Kill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.IsReviving
	 * 		Flags  -> ()
	 */
	bool UHealthComponent::IsReviving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.IsReviving");
		
		UHealthComponent_IsReviving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.IsKnockedOut
	 * 		Flags  -> ()
	 */
	bool UHealthComponent::IsKnockedOut()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.IsKnockedOut");
		
		UHealthComponent_IsKnockedOut_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.IsIncapacitated
	 * 		Flags  -> ()
	 */
	bool UHealthComponent::IsIncapacitated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.IsIncapacitated");
		
		UHealthComponent_IsIncapacitated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.IsFragile
	 * 		Flags  -> ()
	 */
	bool UHealthComponent::IsFragile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.IsFragile");
		
		UHealthComponent_IsFragile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.IsDead
	 * 		Flags  -> ()
	 */
	bool UHealthComponent::IsDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.IsDead");
		
		UHealthComponent_IsDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.IsDamaged
	 * 		Flags  -> ()
	 */
	bool UHealthComponent::IsDamaged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.IsDamaged");
		
		UHealthComponent_IsDamaged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.Incapacitate
	 * 		Flags  -> ()
	 */
	void UHealthComponent::Incapacitate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.Incapacitate");
		
		UHealthComponent_Incapacitate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.HandleOutOfCombatRegen
	 * 		Flags  -> ()
	 */
	void UHealthComponent::HandleOutOfCombatRegen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.HandleOutOfCombatRegen");
		
		UHealthComponent_HandleOutOfCombatRegen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.HandleDecay
	 * 		Flags  -> ()
	 */
	void UHealthComponent::HandleDecay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.HandleDecay");
		
		UHealthComponent_HandleDecay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.GetReviveTimeRatio
	 * 		Flags  -> ()
	 */
	float UHealthComponent::GetReviveTimeRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.GetReviveTimeRatio");
		
		UHealthComponent_GetReviveTimeRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.GetReviveTime
	 * 		Flags  -> ()
	 */
	float UHealthComponent::GetReviveTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.GetReviveTime");
		
		UHealthComponent_GetReviveTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.GetRequiredDamageTypeFlags
	 * 		Flags  -> ()
	 */
	int32_t UHealthComponent::GetRequiredDamageTypeFlags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.GetRequiredDamageTypeFlags");
		
		UHealthComponent_GetRequiredDamageTypeFlags_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.GetRequiredDamageTier
	 * 		Flags  -> ()
	 */
	unsigned char UHealthComponent::GetRequiredDamageTier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.GetRequiredDamageTier");
		
		UHealthComponent_GetRequiredDamageTier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.GetMaxHits
	 * 		Flags  -> ()
	 */
	float UHealthComponent::GetMaxHits()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.GetMaxHits");
		
		UHealthComponent_GetMaxHits_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.GetMaxHealth
	 * 		Flags  -> ()
	 */
	float UHealthComponent::GetMaxHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.GetMaxHealth");
		
		UHealthComponent_GetMaxHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.GetInverseHealthRatio
	 * 		Flags  -> ()
	 */
	float UHealthComponent::GetInverseHealthRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.GetInverseHealthRatio");
		
		UHealthComponent_GetInverseHealthRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.GetIncapacitatedTimeRatio
	 * 		Flags  -> ()
	 */
	float UHealthComponent::GetIncapacitatedTimeRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.GetIncapacitatedTimeRatio");
		
		UHealthComponent_GetIncapacitatedTimeRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.GetHealthState
	 * 		Flags  -> ()
	 */
	EHealthState UHealthComponent::GetHealthState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.GetHealthState");
		
		UHealthComponent_GetHealthState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.GetHealthRatio
	 * 		Flags  -> ()
	 */
	float UHealthComponent::GetHealthRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.GetHealthRatio");
		
		UHealthComponent_GetHealthRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.GetFragileProgress
	 * 		Flags  -> ()
	 */
	float UHealthComponent::GetFragileProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.GetFragileProgress");
		
		UHealthComponent_GetFragileProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.GetDamageReduction
	 * 		Flags  -> ()
	 */
	float UHealthComponent::GetDamageReduction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.GetDamageReduction");
		
		UHealthComponent_GetDamageReduction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.GetCurrentHealth
	 * 		Flags  -> ()
	 */
	float UHealthComponent::GetCurrentHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.GetCurrentHealth");
		
		UHealthComponent_GetCurrentHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.ApplyHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               Causer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthComponent::ApplyHit(class UBaseLODActor* Causer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.ApplyHit");
		
		UHealthComponent_ApplyHit_Params params {};
		params.Causer = Causer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.ApplyDamageFromInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UHealthComponent::ApplyDamageFromInfo(float* Damage, const struct FDamageEvent& DamageEvent, struct FDamageInfo* DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.ApplyDamageFromInfo");
		
		UHealthComponent_ApplyDamageFromInfo_Params params {};
		params.DamageEvent = DamageEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Damage != nullptr)
			*Damage = params.Damage;
		if (DamageInfo != nullptr)
			*DamageInfo = params.DamageInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.ApplyDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthComponent::ApplyDamage(float* Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.ApplyDamage");
		
		UHealthComponent_ApplyDamage_Params params {};
		params.DamageEvent = DamageEvent;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Damage != nullptr)
			*Damage = params.Damage;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.AllocateGOAPActions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USurvivalGameInstance*                       GameInstance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InOwner                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UGoapAction*> UHealthComponent::AllocateGOAPActions(class USurvivalGameInstance* GameInstance, class UObject* InOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.AllocateGOAPActions");
		
		UHealthComponent_AllocateGOAPActions_Params params {};
		params.GameInstance = GameInstance;
		params.InOwner = InOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthComponent.AddHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               Causer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthComponent::AddHealth(float Amount, class UBaseLODActor* Causer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthComponent.AddHealth");
		
		UHealthComponent_AddHealth_Params params {};
		params.Amount = Amount;
		params.Causer = Causer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHealthComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHealthComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HealthComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyHealthComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyHealthComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyHealthComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthLODComponent.HandleOnDeath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UHealthLODComponent::HandleOnDeath(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthLODComponent.HandleOnDeath");
		
		UHealthLODComponent_HandleOnDeath_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHealthLODComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHealthLODComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HealthLODComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthReadoutWidget.UpdateHealthAnim
	 * 		Flags  -> ()
	 */
	void UHealthReadoutWidget::UpdateHealthAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthReadoutWidget.UpdateHealthAnim");
		
		UHealthReadoutWidget_UpdateHealthAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HealthReadoutWidget.CheckHealthChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHealthComponent*                            SourceHealthComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OldHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthReadoutWidget::CheckHealthChange(class UHealthComponent* SourceHealthComponent, float NewHealth, float OldHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HealthReadoutWidget.CheckHealthChange");
		
		UHealthReadoutWidget_CheckHealthChange_Params params {};
		params.SourceHealthComponent = SourceHealthComponent;
		params.NewHealth = NewHealth;
		params.OldHealth = OldHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHealthReadoutWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHealthReadoutWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HealthReadoutWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.SetHazardStateActive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHeatHazardCondition                               Condition                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Active                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UHeatHazardComponent::SetHazardStateActive(EHeatHazardCondition Condition, bool Active)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.SetHazardStateActive");
		
		UHeatHazardComponent_SetHazardStateActive_Params params {};
		params.Condition = Condition;
		params.Active = Active;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.SetCurrentSizzle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewSizzle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHeatHazardComponent::SetCurrentSizzle(float NewSizzle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.SetCurrentSizzle");
		
		UHeatHazardComponent_SetCurrentSizzle_Params params {};
		params.NewSizzle = NewSizzle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.SetCurrentHeatHazardVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AHeatHazardVolume*                           HazardVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHeatHazardComponent::SetCurrentHeatHazardVolume(class AHeatHazardVolume* HazardVolume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.SetCurrentHeatHazardVolume");
		
		UHeatHazardComponent_SetCurrentHeatHazardVolume_Params params {};
		params.HazardVolume = HazardVolume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.OnRevive
	 * 		Flags  -> ()
	 */
	void UHeatHazardComponent::OnRevive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.OnRevive");
		
		UHeatHazardComponent_OnRevive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.OnHourChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewHour                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewDay                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHeatHazardComponent::OnHourChanged(int32_t NewHour, int32_t NewDay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.OnHourChanged");
		
		UHeatHazardComponent_OnHourChanged_Params params {};
		params.NewHour = NewHour;
		params.NewDay = NewDay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.OnHeatVolumeEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHeatHazardComponent::OnHeatVolumeEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.OnHeatVolumeEndOverlap");
		
		UHeatHazardComponent_OnHeatVolumeEndOverlap_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.OnHeatVolumeBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHeatHazardComponent::OnHeatVolumeBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.OnHeatVolumeBeginOverlap");
		
		UHeatHazardComponent_OnHeatVolumeBeginOverlap_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.OnHealthStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHealthState                                       NewHealthState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHeatHazardComponent::OnHealthStateChanged(EHealthState NewHealthState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.OnHealthStateChanged");
		
		UHeatHazardComponent_OnHealthStateChanged_Params params {};
		params.NewHealthState = NewHealthState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.GetSummedEmitterValues
	 * 		Flags  -> ()
	 */
	float UHeatHazardComponent::GetSummedEmitterValues()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.GetSummedEmitterValues");
		
		UHeatHazardComponent_GetSummedEmitterValues_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.GetStrongestEmitterValue
	 * 		Flags  -> ()
	 */
	float UHeatHazardComponent::GetStrongestEmitterValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.GetStrongestEmitterValue");
		
		UHeatHazardComponent_GetStrongestEmitterValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.GetStrongestEmitter
	 * 		Flags  -> ()
	 */
	struct FHeatEmitterTraceResult UHeatHazardComponent::GetStrongestEmitter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.GetStrongestEmitter");
		
		UHeatHazardComponent_GetStrongestEmitter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.GetNearestEmitterValue
	 * 		Flags  -> ()
	 */
	float UHeatHazardComponent::GetNearestEmitterValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.GetNearestEmitterValue");
		
		UHeatHazardComponent_GetNearestEmitterValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.GetNearbyHeatEmitters
	 * 		Flags  -> ()
	 */
	TArray<struct FHeatEmitterTraceResult> UHeatHazardComponent::GetNearbyHeatEmitters()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.GetNearbyHeatEmitters");
		
		UHeatHazardComponent_GetNearbyHeatEmitters_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.GetHazardStateDuration
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHeatHazardCondition                               Condition                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UHeatHazardComponent::GetHazardStateDuration(EHeatHazardCondition Condition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.GetHazardStateDuration");
		
		UHeatHazardComponent_GetHazardStateDuration_Params params {};
		params.Condition = Condition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.GetHazardStateActive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHeatHazardCondition                               Condition                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UHeatHazardComponent::GetHazardStateActive(EHeatHazardCondition Condition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.GetHazardStateActive");
		
		UHeatHazardComponent_GetHazardStateActive_Params params {};
		params.Condition = Condition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.GetCurrentSizzleRatio
	 * 		Flags  -> ()
	 */
	float UHeatHazardComponent::GetCurrentSizzleRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.GetCurrentSizzleRatio");
		
		UHeatHazardComponent_GetCurrentSizzleRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardComponent.GetCurrentSizzle
	 * 		Flags  -> ()
	 */
	float UHeatHazardComponent::GetCurrentSizzle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardComponent.GetCurrentSizzle");
		
		UHeatHazardComponent_GetCurrentSizzle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHeatHazardComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHeatHazardComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HeatHazardComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardVolume.GetDamageData
	 * 		Flags  -> ()
	 */
	struct FDamageData AHeatHazardVolume::GetDamageData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardVolume.GetDamageData");
		
		AHeatHazardVolume_GetDamageData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HeatHazardVolume.EvaluateHeatHazard
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHeatHazardComponent*                        HazardComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AHeatHazardVolume::EvaluateHeatHazard(class UHeatHazardComponent* HazardComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HeatHazardVolume.EvaluateHeatHazard");
		
		AHeatHazardVolume_EvaluateHeatHazard_Params params {};
		params.HazardComponent = HazardComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHeatHazardVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHeatHazardVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HeatHazardVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPersistentObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPersistentObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PersistentObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HotBarQuickSlot.OnRep_PropertyChanged
	 * 		Flags  -> ()
	 */
	void UHotBarQuickSlot::OnRep_PropertyChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HotBarQuickSlot.OnRep_PropertyChanged");
		
		UHotBarQuickSlot_OnRep_PropertyChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HotBarQuickSlot.ChangeQuickSlotType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHotBarQuickSlotType                               NewSlotType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHotBarQuickSlot::ChangeQuickSlotType(EHotBarQuickSlotType NewSlotType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HotBarQuickSlot.ChangeQuickSlotType");
		
		UHotBarQuickSlot_ChangeQuickSlotType_Params params {};
		params.NewSlotType = NewSlotType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HotBarQuickSlot.AssignItemKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHotBarQuickSlotItemTypeKey                 ItemKey                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UHotBarQuickSlot::AssignItemKey(const struct FHotBarQuickSlotItemTypeKey& ItemKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HotBarQuickSlot.AssignItemKey");
		
		UHotBarQuickSlot_AssignItemKey_Params params {};
		params.ItemKey = ItemKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HotBarQuickSlot.AssignItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHotBarQuickSlot::AssignItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HotBarQuickSlot.AssignItem");
		
		UHotBarQuickSlot_AssignItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHotBarQuickSlot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHotBarQuickSlot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HotBarQuickSlot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HotBarWidget.OnSelectedItemChanged
	 * 		Flags  -> ()
	 */
	void UHotBarWidget::OnSelectedItemChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HotBarWidget.OnSelectedItemChanged");
		
		UHotBarWidget_OnSelectedItemChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HotBarWidget.NewSelectedItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       NewItem                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHotBarWidget::NewSelectedItem(class UItem* NewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HotBarWidget.NewSelectedItem");
		
		UHotBarWidget_NewSelectedItem_Params params {};
		params.NewItem = NewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHotBarWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHotBarWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HotBarWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDArmorWidget.OnEquipmentChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FArmorEquipmentSlot                         EquipmentSlot                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UHUDArmorWidget::OnEquipmentChanged(const struct FArmorEquipmentSlot& EquipmentSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDArmorWidget.OnEquipmentChanged");
		
		UHUDArmorWidget_OnEquipmentChanged_Params params {};
		params.EquipmentSlot = EquipmentSlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDArmorWidget.OnDurabilityChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FArmorEquipmentSlot                         SlotStruct                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UHUDArmorWidget::OnDurabilityChanged(const struct FArmorEquipmentSlot& SlotStruct)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDArmorWidget.OnDurabilityChanged");
		
		UHUDArmorWidget_OnDurabilityChanged_Params params {};
		params.SlotStruct = SlotStruct;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDArmorWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDArmorWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HUDArmorWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDCrosshairWidget.UpdateCursorBrush
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EAttackResolutionType                              AttackResolution                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDCrosshairWidget::UpdateCursorBrush(EAttackResolutionType AttackResolution)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDCrosshairWidget.UpdateCursorBrush");
		
		UHUDCrosshairWidget_UpdateCursorBrush_Params params {};
		params.AttackResolution = AttackResolution;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDCrosshairWidget.OnPlayerAttackTargetChanged
	 * 		Flags  -> ()
	 */
	void UHUDCrosshairWidget::OnPlayerAttackTargetChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDCrosshairWidget.OnPlayerAttackTargetChanged");
		
		UHUDCrosshairWidget_OnPlayerAttackTargetChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDCrosshairWidget.OnCameraModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECameraDisplayMode                                 DisplayMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDCrosshairWidget::OnCameraModeChanged(ECameraDisplayMode DisplayMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDCrosshairWidget.OnCameraModeChanged");
		
		UHUDCrosshairWidget_OnCameraModeChanged_Params params {};
		params.DisplayMode = DisplayMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDCrosshairWidget.OnAttackResolutionChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EAttackResolutionType                              AttackResolution                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDCrosshairWidget::OnAttackResolutionChanged(EAttackResolutionType AttackResolution)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDCrosshairWidget.OnAttackResolutionChanged");
		
		UHUDCrosshairWidget_OnAttackResolutionChanged_Params params {};
		params.AttackResolution = AttackResolution;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDCrosshairWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDCrosshairWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HUDCrosshairWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDDestroyStructureWidget.NativeUpdateData
	 * 		Flags  -> ()
	 */
	void UHUDDestroyStructureWidget::NativeUpdateData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDDestroyStructureWidget.NativeUpdateData");
		
		UHUDDestroyStructureWidget_NativeUpdateData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDDestroyStructureWidget.InitSupportTextColors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSlateColor                                 NormalColor                                                (Parm, NativeAccessSpecifierPublic)
	 * 		struct FSlateColor                                 WarningColor                                               (Parm, NativeAccessSpecifierPublic)
	 */
	void UHUDDestroyStructureWidget::InitSupportTextColors(const struct FSlateColor& NormalColor, const struct FSlateColor& WarningColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDDestroyStructureWidget.InitSupportTextColors");
		
		UHUDDestroyStructureWidget_InitSupportTextColors_Params params {};
		params.NormalColor = NormalColor;
		params.WarningColor = WarningColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDDestroyStructureWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDDestroyStructureWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HUDDestroyStructureWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDGasMaskWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDGasMaskWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HUDGasMaskWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDInteractableWidget.UpdateInteractionTargetChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     NewTarget                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDInteractableWidget::UpdateInteractionTargetChanged(class UObject* NewTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDInteractableWidget.UpdateInteractionTargetChanged");
		
		UHUDInteractableWidget_UpdateInteractionTargetChanged_Params params {};
		params.NewTarget = NewTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDInteractableWidget.UpdateAttackResolutionChanged
	 * 		Flags  -> ()
	 */
	void UHUDInteractableWidget::UpdateAttackResolutionChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDInteractableWidget.UpdateAttackResolutionChanged");
		
		UHUDInteractableWidget_UpdateAttackResolutionChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDInteractableWidget.OnPlayerInteractableChanged
	 * 		Flags  -> ()
	 */
	void UHUDInteractableWidget::OnPlayerInteractableChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDInteractableWidget.OnPlayerInteractableChanged");
		
		UHUDInteractableWidget_OnPlayerInteractableChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDInteractableWidget.OnPlayerAttackTargetChanged
	 * 		Flags  -> ()
	 */
	void UHUDInteractableWidget::OnPlayerAttackTargetChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDInteractableWidget.OnPlayerAttackTargetChanged");
		
		UHUDInteractableWidget_OnPlayerAttackTargetChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDInteractableWidget.OnEquipmentChanged
	 * 		Flags  -> ()
	 */
	void UHUDInteractableWidget::OnEquipmentChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDInteractableWidget.OnEquipmentChanged");
		
		UHUDInteractableWidget_OnEquipmentChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDInteractableWidget.OnAttackResolutionChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EAttackResolutionType                              AttackResolution                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDInteractableWidget::OnAttackResolutionChanged(EAttackResolutionType AttackResolution)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDInteractableWidget.OnAttackResolutionChanged");
		
		UHUDInteractableWidget_OnAttackResolutionChanged_Params params {};
		params.AttackResolution = AttackResolution;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDInteractableWidget.GetCurrentTargetHealth
	 * 		Flags  -> ()
	 */
	class UHealthComponent* UHUDInteractableWidget::GetCurrentTargetHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDInteractableWidget.GetCurrentTargetHealth");
		
		UHUDInteractableWidget_GetCurrentTargetHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDInteractableWidget.GetCurrentAttackResolution
	 * 		Flags  -> ()
	 */
	EAttackResolutionType UHUDInteractableWidget::GetCurrentAttackResolution()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDInteractableWidget.GetCurrentAttackResolution");
		
		UHUDInteractableWidget_GetCurrentAttackResolution_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDInteractableWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDInteractableWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HUDInteractableWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.SetIconVariant
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Variant                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerData::SetIconVariant(int32_t Variant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.SetIconVariant");
		
		UHUDMarkerData_SetIconVariant_Params params {};
		params.Variant = Variant;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.SetDisplayName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      NewName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerData::SetDisplayName(const class FString& NewName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.SetDisplayName");
		
		UHUDMarkerData_SetDisplayName_Params params {};
		params.NewName = NewName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.SetColorVariant
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Variant                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerData::SetColorVariant(int32_t Variant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.SetColorVariant");
		
		UHUDMarkerData_SetColorVariant_Params params {};
		params.Variant = Variant;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.SetColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FColor                                      NewColor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerData::SetColor(const struct FColor& NewColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.SetColor");
		
		UHUDMarkerData_SetColor_Params params {};
		params.NewColor = NewColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.HandleLODActorConvertedToProxy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               Sender                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerData::HandleLODActorConvertedToProxy(class UBaseLODActor* Sender)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.HandleLODActorConvertedToProxy");
		
		UHUDMarkerData_HandleLODActorConvertedToProxy_Params params {};
		params.Sender = Sender;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.HandleLODActorConvertedToFull
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               Sender                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerData::HandleLODActorConvertedToFull(class UBaseLODActor* Sender)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.HandleLODActorConvertedToFull");
		
		UHUDMarkerData_HandleLODActorConvertedToFull_Params params {};
		params.Sender = Sender;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.HandleHUDMarkerChanged
	 * 		Flags  -> ()
	 */
	void UHUDMarkerData::HandleHUDMarkerChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.HandleHUDMarkerChanged");
		
		UHUDMarkerData_HandleHUDMarkerChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.GetShowDistance
	 * 		Flags  -> ()
	 */
	bool UHUDMarkerData::GetShowDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.GetShowDistance");
		
		UHUDMarkerData_GetShowDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.GetShouldShow
	 * 		Flags  -> ()
	 */
	bool UHUDMarkerData::GetShouldShow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.GetShouldShow");
		
		UHUDMarkerData_GetShouldShow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.GetReferencedLODActor
	 * 		Flags  -> ()
	 */
	class UBaseLODActor* UHUDMarkerData::GetReferencedLODActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.GetReferencedLODActor");
		
		UHUDMarkerData_GetReferencedLODActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.GetReferencedActor
	 * 		Flags  -> ()
	 */
	class AActor* UHUDMarkerData::GetReferencedActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.GetReferencedActor");
		
		UHUDMarkerData_GetReferencedActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.GetQuestData
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UHUDMarkerData::GetQuestData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.GetQuestData");
		
		UHUDMarkerData_GetQuestData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.GetMarkerVariant
	 * 		Flags  -> ()
	 */
	int32_t UHUDMarkerData::GetMarkerVariant()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.GetMarkerVariant");
		
		UHUDMarkerData_GetMarkerVariant_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.GetMarkerType
	 * 		Flags  -> ()
	 */
	EHUDMarkerType UHUDMarkerData::GetMarkerType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.GetMarkerType");
		
		UHUDMarkerData_GetMarkerType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.GetMarkerColorVariant
	 * 		Flags  -> ()
	 */
	int32_t UHUDMarkerData::GetMarkerColorVariant()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.GetMarkerColorVariant");
		
		UHUDMarkerData_GetMarkerColorVariant_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.GetLocation
	 * 		Flags  -> ()
	 */
	struct FVector UHUDMarkerData::GetLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.GetLocation");
		
		UHUDMarkerData_GetLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.GetLifeTimeRemaining
	 * 		Flags  -> ()
	 */
	float UHUDMarkerData::GetLifeTimeRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.GetLifeTimeRemaining");
		
		UHUDMarkerData_GetLifeTimeRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.GetDisplayName
	 * 		Flags  -> ()
	 */
	class FString UHUDMarkerData::GetDisplayName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.GetDisplayName");
		
		UHUDMarkerData_GetDisplayName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.GetColor
	 * 		Flags  -> ()
	 */
	struct FColor UHUDMarkerData::GetColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.GetColor");
		
		UHUDMarkerData_GetColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerData.GetAdditionalData
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UHUDMarkerData::GetAdditionalData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerData.GetAdditionalData");
		
		UHUDMarkerData_GetAdditionalData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDMarkerData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDMarkerData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HUDMarkerData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalGameStateComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalGameStateComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalGameStateComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerManagerComponent.ToggleShowFarHUDMarkers
	 * 		Flags  -> ()
	 */
	void UHUDMarkerManagerComponent::ToggleShowFarHUDMarkers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerManagerComponent.ToggleShowFarHUDMarkers");
		
		UHUDMarkerManagerComponent_ToggleShowFarHUDMarkers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerManagerComponent.RegisterPlayerWaypointMarker
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerState*                                OwningPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ShowDistance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Lifetime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerManagerComponent::RegisterPlayerWaypointMarker(class APlayerState* OwningPlayer, const struct FVector& Location, bool ShowDistance, float Lifetime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerManagerComponent.RegisterPlayerWaypointMarker");
		
		UHUDMarkerManagerComponent_RegisterPlayerWaypointMarker_Params params {};
		params.OwningPlayer = OwningPlayer;
		params.Location = Location;
		params.ShowDistance = ShowDistance;
		params.Lifetime = Lifetime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerManagerComponent.RegisterPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalPlayerCharacter*                    Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerManagerComponent::RegisterPlayer(class ASurvivalPlayerCharacter* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerManagerComponent.RegisterPlayer");
		
		UHUDMarkerManagerComponent_RegisterPlayer_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerManagerComponent.RegisterLocationMarker
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MarkerTag                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         Quest                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EHUDMarkerType                                     MarkerType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ShowDistance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Lifetime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerManagerComponent::RegisterLocationMarker(const class FString& MarkerTag, const struct FDataTableRowHandle& Quest, const struct FVector& Location, EHUDMarkerType MarkerType, bool ShowDistance, float Lifetime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerManagerComponent.RegisterLocationMarker");
		
		UHUDMarkerManagerComponent_RegisterLocationMarker_Params params {};
		params.MarkerTag = MarkerTag;
		params.Quest = Quest;
		params.Location = Location;
		params.MarkerType = MarkerType;
		params.ShowDistance = ShowDistance;
		params.Lifetime = Lifetime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerManagerComponent.RegisterItemObjectiveMarker
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemDataRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         Quest                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               ShowDistance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Lifetime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerManagerComponent::RegisterItemObjectiveMarker(const struct FDataTableRowHandle& ItemDataRowHandle, const struct FDataTableRowHandle& Quest, bool ShowDistance, float Lifetime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerManagerComponent.RegisterItemObjectiveMarker");
		
		UHUDMarkerManagerComponent_RegisterItemObjectiveMarker_Params params {};
		params.ItemDataRowHandle = ItemDataRowHandle;
		params.Quest = Quest;
		params.ShowDistance = ShowDistance;
		params.Lifetime = Lifetime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerManagerComponent.RefreshActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerManagerComponent::RefreshActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerManagerComponent.RefreshActor");
		
		UHUDMarkerManagerComponent_RefreshActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerManagerComponent.K2_RegisterLODActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         Quest                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         AdditionalData                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EHUDMarkerType                                     MarkerType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            IconVariant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ColorVariant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ShowDistance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Lifetime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerManagerComponent::K2_RegisterLODActor(class UBaseLODActor* Actor, const struct FDataTableRowHandle& Quest, const struct FDataTableRowHandle& AdditionalData, EHUDMarkerType MarkerType, int32_t IconVariant, int32_t ColorVariant, bool ShowDistance, float Lifetime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerManagerComponent.K2_RegisterLODActor");
		
		UHUDMarkerManagerComponent_K2_RegisterLODActor_Params params {};
		params.Actor = Actor;
		params.Quest = Quest;
		params.AdditionalData = AdditionalData;
		params.MarkerType = MarkerType;
		params.IconVariant = IconVariant;
		params.ColorVariant = ColorVariant;
		params.ShowDistance = ShowDistance;
		params.Lifetime = Lifetime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerManagerComponent.K2_RegisterActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         Quest                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         AdditionalData                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EHUDMarkerType                                     MarkerType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            IconVariant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ColorVariant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ShowDistance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Lifetime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerManagerComponent::K2_RegisterActor(class AActor* Actor, const struct FDataTableRowHandle& Quest, const struct FDataTableRowHandle& AdditionalData, EHUDMarkerType MarkerType, int32_t IconVariant, int32_t ColorVariant, bool ShowDistance, float Lifetime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerManagerComponent.K2_RegisterActor");
		
		UHUDMarkerManagerComponent_K2_RegisterActor_Params params {};
		params.Actor = Actor;
		params.Quest = Quest;
		params.AdditionalData = AdditionalData;
		params.MarkerType = MarkerType;
		params.IconVariant = IconVariant;
		params.ColorVariant = ColorVariant;
		params.ShowDistance = ShowDistance;
		params.Lifetime = Lifetime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerManagerComponent.GetShowFarHUDMarkers
	 * 		Flags  -> ()
	 */
	bool UHUDMarkerManagerComponent::GetShowFarHUDMarkers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerManagerComponent.GetShowFarHUDMarkers");
		
		UHUDMarkerManagerComponent_GetShowFarHUDMarkers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerManagerComponent.DeregisterPlayerWaypointMarker
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerState*                                OwningPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerManagerComponent::DeregisterPlayerWaypointMarker(class APlayerState* OwningPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerManagerComponent.DeregisterPlayerWaypointMarker");
		
		UHUDMarkerManagerComponent_DeregisterPlayerWaypointMarker_Params params {};
		params.OwningPlayer = OwningPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerManagerComponent.DeregisterActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDMarkerManagerComponent::DeregisterActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerManagerComponent.DeregisterActor");
		
		UHUDMarkerManagerComponent_DeregisterActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerManagerComponent.AddStartingMarkers
	 * 		Flags  -> ()
	 */
	void UHUDMarkerManagerComponent::AddStartingMarkers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerManagerComponent.AddStartingMarkers");
		
		UHUDMarkerManagerComponent_AddStartingMarkers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDMarkerManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDMarkerManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HUDMarkerManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerTargetInterface.GetShouldShowHUDMarker
	 * 		Flags  -> ()
	 */
	bool UHUDMarkerTargetInterface::GetShouldShowHUDMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerTargetInterface.GetShouldShowHUDMarker");
		
		UHUDMarkerTargetInterface_GetShouldShowHUDMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDMarkerTargetInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDMarkerTargetInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HUDMarkerTargetInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerWidget.UpdateMarkerPosition
	 * 		Flags  -> ()
	 */
	void UHUDMarkerWidget::UpdateMarkerPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerWidget.UpdateMarkerPosition");
		
		UHUDMarkerWidget_UpdateMarkerPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerWidget.UpdateMarkerFade
	 * 		Flags  -> ()
	 */
	void UHUDMarkerWidget::UpdateMarkerFade()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerWidget.UpdateMarkerFade");
		
		UHUDMarkerWidget_UpdateMarkerFade_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerWidget.UpdateMarkerDistance
	 * 		Flags  -> ()
	 */
	void UHUDMarkerWidget::UpdateMarkerDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerWidget.UpdateMarkerDistance");
		
		UHUDMarkerWidget_UpdateMarkerDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerWidget.UpdateBuildingMarkerHealth
	 * 		Flags  -> ()
	 */
	void UHUDMarkerWidget::UpdateBuildingMarkerHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerWidget.UpdateBuildingMarkerHealth");
		
		UHUDMarkerWidget_UpdateBuildingMarkerHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerWidget.ShouldShowMarkerTimer
	 * 		Flags  -> ()
	 */
	bool UHUDMarkerWidget::ShouldShowMarkerTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerWidget.ShouldShowMarkerTimer");
		
		UHUDMarkerWidget_ShouldShowMarkerTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerWidget.ShouldShowMarkerArrow
	 * 		Flags  -> ()
	 */
	bool UHUDMarkerWidget::ShouldShowMarkerArrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerWidget.ShouldShowMarkerArrow");
		
		UHUDMarkerWidget_ShouldShowMarkerArrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerWidget.ShouldMarkerLockToScreen
	 * 		Flags  -> ()
	 */
	bool UHUDMarkerWidget::ShouldMarkerLockToScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerWidget.ShouldMarkerLockToScreen");
		
		UHUDMarkerWidget_ShouldMarkerLockToScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerWidget.ShouldFadeMarkerAtEdge
	 * 		Flags  -> ()
	 */
	bool UHUDMarkerWidget::ShouldFadeMarkerAtEdge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerWidget.ShouldFadeMarkerAtEdge");
		
		UHUDMarkerWidget_ShouldFadeMarkerAtEdge_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerWidget.HandleStickiedQuestChanged
	 * 		Flags  -> ()
	 */
	void UHUDMarkerWidget::HandleStickiedQuestChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerWidget.HandleStickiedQuestChanged");
		
		UHUDMarkerWidget_HandleStickiedQuestChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerWidget.GetMarkerScreenEdgeAlpha
	 * 		Flags  -> ()
	 */
	float UHUDMarkerWidget::GetMarkerScreenEdgeAlpha()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerWidget.GetMarkerScreenEdgeAlpha");
		
		UHUDMarkerWidget_GetMarkerScreenEdgeAlpha_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDMarkerWidget.GetMarkerLifetimeFade
	 * 		Flags  -> ()
	 */
	float UHUDMarkerWidget::GetMarkerLifetimeFade()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDMarkerWidget.GetMarkerLifetimeFade");
		
		UHUDMarkerWidget_GetMarkerLifetimeFade_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDMarkerWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDMarkerWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HUDMarkerWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDSCABFoodWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDSCABFoodWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HUDSCABFoodWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDSCABWaterWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDSCABWaterWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HUDSCABWaterWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDSCABWidget.UpdateTimeOfDay
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewHour                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewDay                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDSCABWidget::UpdateTimeOfDay(int32_t NewHour, int32_t NewDay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDSCABWidget.UpdateTimeOfDay");
		
		UHUDSCABWidget_UpdateTimeOfDay_Params params {};
		params.NewHour = NewHour;
		params.NewDay = NewDay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDSCABWidget.UpdateThirstRatio
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewRatio                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDSCABWidget::UpdateThirstRatio(float NewRatio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDSCABWidget.UpdateThirstRatio");
		
		UHUDSCABWidget_UpdateThirstRatio_Params params {};
		params.NewRatio = NewRatio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDSCABWidget.UpdateStaminaRatio
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewRatio                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDSCABWidget::UpdateStaminaRatio(float NewRatio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDSCABWidget.UpdateStaminaRatio");
		
		UHUDSCABWidget_UpdateStaminaRatio_Params params {};
		params.NewRatio = NewRatio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDSCABWidget.UpdateRadarVisuals
	 * 		Flags  -> ()
	 */
	void UHUDSCABWidget::UpdateRadarVisuals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDSCABWidget.UpdateRadarVisuals");
		
		UHUDSCABWidget_UpdateRadarVisuals_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDSCABWidget.UpdateHungerRatio
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewRatio                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDSCABWidget::UpdateHungerRatio(float NewRatio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDSCABWidget.UpdateHungerRatio");
		
		UHUDSCABWidget_UpdateHungerRatio_Params params {};
		params.NewRatio = NewRatio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDSCABWidget.UpdateHealthRatio
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewHealthRatio                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDSCABWidget::UpdateHealthRatio(float NewHealthRatio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDSCABWidget.UpdateHealthRatio");
		
		UHUDSCABWidget_UpdateHealthRatio_Params params {};
		params.NewHealthRatio = NewHealthRatio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDSCABWidget.OnHourChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewHour                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewDay                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDSCABWidget::OnHourChange(int32_t NewHour, int32_t NewDay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDSCABWidget.OnHourChange");
		
		UHUDSCABWidget_OnHourChange_Params params {};
		params.NewHour = NewHour;
		params.NewDay = NewDay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDSCABWidget.CheckWaterChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USurvivalComponent*                          Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDSCABWidget::CheckWaterChange(class USurvivalComponent* Sender, float OldValue, float NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDSCABWidget.CheckWaterChange");
		
		UHUDSCABWidget_CheckWaterChange_Params params {};
		params.Sender = Sender;
		params.OldValue = OldValue;
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDSCABWidget.CheckHealthChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHealthComponent*                            SourceHealthComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OldHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDSCABWidget::CheckHealthChange(class UHealthComponent* SourceHealthComponent, float NewHealth, float OldHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDSCABWidget.CheckHealthChange");
		
		UHUDSCABWidget_CheckHealthChange_Params params {};
		params.SourceHealthComponent = SourceHealthComponent;
		params.NewHealth = NewHealth;
		params.OldHealth = OldHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDSCABWidget.CheckFoodChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USurvivalComponent*                          Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDSCABWidget::CheckFoodChange(class USurvivalComponent* Sender, float OldValue, float NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDSCABWidget.CheckFoodChange");
		
		UHUDSCABWidget_CheckFoodChange_Params params {};
		params.Sender = Sender;
		params.OldValue = OldValue;
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDSCABWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDSCABWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HUDSCABWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWeaponInfoWidget.OnPowerChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewRatio                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWeaponInfoWidget::OnPowerChanged(float NewRatio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWeaponInfoWidget.OnPowerChanged");
		
		UHUDWeaponInfoWidget_OnPowerChanged_Params params {};
		params.NewRatio = NewRatio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWeaponInfoWidget.OnMainHandChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       ChangedItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWeaponInfoWidget::OnMainHandChanged(class UItem* ChangedItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWeaponInfoWidget.OnMainHandChanged");
		
		UHUDWeaponInfoWidget_OnMainHandChanged_Params params {};
		params.ChangedItem = ChangedItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWeaponInfoWidget.OnItemCountChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ItemCount                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWeaponInfoWidget::OnItemCountChanged(int32_t ItemCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWeaponInfoWidget.OnItemCountChanged");
		
		UHUDWeaponInfoWidget_OnItemCountChanged_Params params {};
		params.ItemCount = ItemCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWeaponInfoWidget.OnEnhancementLevelChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewEnhancementLevel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWeaponInfoWidget::OnEnhancementLevelChanged(int32_t NewEnhancementLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWeaponInfoWidget.OnEnhancementLevelChanged");
		
		UHUDWeaponInfoWidget_OnEnhancementLevelChanged_Params params {};
		params.NewEnhancementLevel = NewEnhancementLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWeaponInfoWidget.OnDurabilityChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewRatio                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWeaponInfoWidget::OnDurabilityChanged(float NewRatio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWeaponInfoWidget.OnDurabilityChanged");
		
		UHUDWeaponInfoWidget_OnDurabilityChanged_Params params {};
		params.NewRatio = NewRatio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWeaponInfoWidget.OnAmmoTypeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWeaponInfoWidget::OnAmmoTypeChanged(const class FName& ItemName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWeaponInfoWidget.OnAmmoTypeChanged");
		
		UHUDWeaponInfoWidget_OnAmmoTypeChanged_Params params {};
		params.ItemName = ItemName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWeaponInfoWidget.OnAmmoCountChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ItemCount                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWeaponInfoWidget::OnAmmoCountChanged(int32_t ItemCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWeaponInfoWidget.OnAmmoCountChanged");
		
		UHUDWeaponInfoWidget_OnAmmoCountChanged_Params params {};
		params.ItemCount = ItemCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDWeaponInfoWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDWeaponInfoWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HUDWeaponInfoWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.SetSpyGlassOverlayVisibility
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Visible                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::SetSpyGlassOverlayVisibility(bool Visible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.SetSpyGlassOverlayVisibility");
		
		UHUDWidget_SetSpyGlassOverlayVisibility_Params params {};
		params.Visible = Visible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.RemovePlayerNameplateWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHUDMarkerData*                              HUDMarkerData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::RemovePlayerNameplateWidget(class UHUDMarkerData* HUDMarkerData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.RemovePlayerNameplateWidget");
		
		UHUDWidget_RemovePlayerNameplateWidget_Params params {};
		params.HUDMarkerData = HUDMarkerData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.RemoveHUDMarkerWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHUDMarkerData*                              HUDMarkerData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::RemoveHUDMarkerWidget(class UHUDMarkerData* HUDMarkerData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.RemoveHUDMarkerWidget");
		
		UHUDWidget_RemoveHUDMarkerWidget_Params params {};
		params.HUDMarkerData = HUDMarkerData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnZiplineMovementModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsZiplining                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnZiplineMovementModeChanged(bool bIsZiplining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnZiplineMovementModeChanged");
		
		UHUDWidget_OnZiplineMovementModeChanged_Params params {};
		params.bIsZiplining = bIsZiplining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnZiplineModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AZiplineSelectorPawn*                        Selector                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnZiplineModeChanged(class AZiplineSelectorPawn* Selector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnZiplineModeChanged");
		
		UHUDWidget_OnZiplineModeChanged_Params params {};
		params.Selector = Selector;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnSizzlingChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsSizzling                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnSizzlingChanged(bool bIsSizzling, class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnSizzlingChanged");
		
		UHUDWidget_OnSizzlingChanged_Params params {};
		params.bIsSizzling = bIsSizzling;
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnSizzleCountdownChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewRatio                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsLocalPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnSizzleCountdownChanged(float NewRatio, bool bIsLocalPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnSizzleCountdownChanged");
		
		UHUDWidget_OnSizzleCountdownChanged_Params params {};
		params.NewRatio = NewRatio;
		params.bIsLocalPlayer = bIsLocalPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnSittingChangedImpl
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsSitting                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnSittingChangedImpl(bool bIsSitting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnSittingChangedImpl");
		
		UHUDWidget_OnSittingChangedImpl_Params params {};
		params.bIsSitting = bIsSitting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnSittingChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsSitting                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnSittingChanged(bool bIsSitting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnSittingChanged");
		
		UHUDWidget_OnSittingChanged_Params params {};
		params.bIsSitting = bIsSitting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnRevived
	 * 		Flags  -> ()
	 */
	void UHUDWidget::OnRevived()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnRevived");
		
		UHUDWidget_OnRevived_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnPlayerNewPawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnPlayerNewPawn(class APawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnPlayerNewPawn");
		
		UHUDWidget_OnPlayerNewPawn_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnPlayerDeathOrIncap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnPlayerDeathOrIncap(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnPlayerDeathOrIncap");
		
		UHUDWidget_OnPlayerDeathOrIncap_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnPerfectBlock
	 * 		Flags  -> ()
	 */
	void UHUDWidget::OnPerfectBlock()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnPerfectBlock");
		
		UHUDWidget_OnPerfectBlock_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnOffHandChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnOffHandChanged(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnOffHandChanged");
		
		UHUDWidget_OnOffHandChanged_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnMainHandChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnMainHandChanged(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnMainHandChanged");
		
		UHUDWidget_OnMainHandChanged_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnHUDShowChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowHUD                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnHUDShowChange(bool bShowHUD)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnHUDShowChange");
		
		UHUDWidget_OnHUDShowChange_Params params {};
		params.bShowHUD = bShowHUD;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnHaulingChangedImpl
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHaulingComponent*                           Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnHaulingChangedImpl(class UHaulingComponent* Sender)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnHaulingChangedImpl");
		
		UHUDWidget_OnHaulingChangedImpl_Params params {};
		params.Sender = Sender;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnHaulingChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsHauling                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnHaulingChanged(bool bIsHauling)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnHaulingChanged");
		
		UHUDWidget_OnHaulingChanged_Params params {};
		params.bIsHauling = bIsHauling;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnGliderMovementModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsGliding                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnGliderMovementModeChanged(bool bIsGliding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnGliderMovementModeChanged");
		
		UHUDWidget_OnGliderMovementModeChanged_Params params {};
		params.bIsGliding = bIsGliding;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnGliderChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnGliderChanged(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnGliderChanged");
		
		UHUDWidget_OnGliderChanged_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnFullBreathChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFullBreath                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnFullBreathChanged(bool bFullBreath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnFullBreathChanged");
		
		UHUDWidget_OnFullBreathChanged_Params params {};
		params.bFullBreath = bFullBreath;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnDeathCountdownChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bDeathCountdown                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnDeathCountdownChanged(bool bDeathCountdown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnDeathCountdownChanged");
		
		UHUDWidget_OnDeathCountdownChanged_Params params {};
		params.bDeathCountdown = bDeathCountdown;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnClimbMovementModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsClimbing                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnClimbMovementModeChanged(bool bIsClimbing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnClimbMovementModeChanged");
		
		UHUDWidget_OnClimbMovementModeChanged_Params params {};
		params.bIsClimbing = bIsClimbing;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnBuildingModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsPlacingBuilding                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnBuildingModeChanged(bool bIsPlacingBuilding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnBuildingModeChanged");
		
		UHUDWidget_OnBuildingModeChanged_Params params {};
		params.bIsPlacingBuilding = bIsPlacingBuilding;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnBuildingFragileChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABuilding*                                   Sender                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsFragile                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnBuildingFragileChanged(class ABuilding* Sender, bool IsFragile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnBuildingFragileChanged");
		
		UHUDWidget_OnBuildingFragileChanged_Params params {};
		params.Sender = Sender;
		params.IsFragile = IsFragile;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.OnBlockChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsBlocking                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::OnBlockChanged(bool bIsBlocking)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.OnBlockChanged");
		
		UHUDWidget_OnBlockChanged_Params params {};
		params.bIsBlocking = bIsBlocking;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.IsPlayerNameplateDataActive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHUDMarkerData*                              HUDMarkerData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UHUDWidget::IsPlayerNameplateDataActive(class UHUDMarkerData* HUDMarkerData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.IsPlayerNameplateDataActive");
		
		UHUDWidget_IsPlayerNameplateDataActive_Params params {};
		params.HUDMarkerData = HUDMarkerData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.IsHUDMarkerDataActive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHUDMarkerData*                              HUDMarkerData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UHUDWidget::IsHUDMarkerDataActive(class UHUDMarkerData* HUDMarkerData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.IsHUDMarkerDataActive");
		
		UHUDWidget_IsHUDMarkerDataActive_Params params {};
		params.HUDMarkerData = HUDMarkerData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.HandleGenericMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  MessageIcon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::HandleGenericMessage(const class FString& Message, class UTexture2D* MessageIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.HandleGenericMessage");
		
		UHUDWidget_HandleGenericMessage_Params params {};
		params.Message = Message;
		params.MessageIcon = MessageIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.AddPlayerNameplateWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPlayerNameplateWidget*                      PlayerNameplateWidget                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::AddPlayerNameplateWidget(class UPlayerNameplateWidget* PlayerNameplateWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.AddPlayerNameplateWidget");
		
		UHUDWidget_AddPlayerNameplateWidget_Params params {};
		params.PlayerNameplateWidget = PlayerNameplateWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HUDWidget.AddHUDMarkerWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHUDMarkerWidget*                            HUDMarkerWidget                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidget::AddHUDMarkerWidget(class UHUDMarkerWidget* HUDMarkerWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HUDWidget.AddHUDMarkerWidget");
		
		UHUDWidget_AddHUDMarkerWidget_Params params {};
		params.HUDMarkerWidget = HUDMarkerWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HUDWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HungerReadoutWidget.UpdateHungerAnim
	 * 		Flags  -> ()
	 */
	void UHungerReadoutWidget::UpdateHungerAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HungerReadoutWidget.UpdateHungerAnim");
		
		UHungerReadoutWidget_UpdateHungerAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.HungerReadoutWidget.CheckFoodChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USurvivalComponent*                          Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHungerReadoutWidget::CheckFoodChange(class USurvivalComponent* Sender, float OldValue, float NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.HungerReadoutWidget.CheckFoodChange");
		
		UHungerReadoutWidget_CheckFoodChange_Params params {};
		params.Sender = Sender;
		params.OldValue = OldValue;
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHungerReadoutWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHungerReadoutWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.HungerReadoutWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.IconKeyItem.SetIconKeyHeader
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         CategoryRow                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UIconKeyItem::SetIconKeyHeader(const struct FDataTableRowHandle& CategoryRow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.IconKeyItem.SetIconKeyHeader");
		
		UIconKeyItem_SetIconKeyHeader_Params params {};
		params.CategoryRow = CategoryRow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.IconKeyItem.SetIconKeyData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         IconRow                                                    (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UIconKeyItem::SetIconKeyData(const struct FDataTableRowHandle& IconRow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.IconKeyItem.SetIconKeyData");
		
		UIconKeyItem_SetIconKeyData_Params params {};
		params.IconRow = IconRow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UIconKeyItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UIconKeyItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.IconKeyItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UIconKeyItemPopulator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UIconKeyItemPopulator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.IconKeyItemPopulator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.IncapacitateWindowWidget.EnableChatLog
	 * 		Flags  -> ()
	 */
	void UIncapacitateWindowWidget::EnableChatLog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.IncapacitateWindowWidget.EnableChatLog");
		
		UIncapacitateWindowWidget_EnableChatLog_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UIncapacitateWindowWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UIncapacitateWindowWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.IncapacitateWindowWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInGameMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInGameMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.InGameMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInstancedBuildingClassUserData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInstancedBuildingClassUserData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.InstancedBuildingClassUserData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InstancedStaticMeshFunctionLibrary.GetClosestInstanceInRadius
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInstancedStaticMeshComponent*               Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Center                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UInstancedStaticMeshFunctionLibrary::GetClosestInstanceInRadius(class UInstancedStaticMeshComponent* Component, const struct FVector& Center, float Radius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InstancedStaticMeshFunctionLibrary.GetClosestInstanceInRadius");
		
		UInstancedStaticMeshFunctionLibrary_GetClosestInstanceInRadius_Params params {};
		params.Component = Component;
		params.Center = Center;
		params.Radius = Radius;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InstancedStaticMeshFunctionLibrary.GatherInstancesInRadius
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInstancedStaticMeshComponent*               Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Center                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<int32_t>                                    OutInstances                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UInstancedStaticMeshFunctionLibrary::GatherInstancesInRadius(class UInstancedStaticMeshComponent* Component, const struct FVector& Center, float Radius, TArray<int32_t>* OutInstances)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InstancedStaticMeshFunctionLibrary.GatherInstancesInRadius");
		
		UInstancedStaticMeshFunctionLibrary_GatherInstancesInRadius_Params params {};
		params.Component = Component;
		params.Center = Center;
		params.Radius = Radius;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutInstances != nullptr)
			*OutInstances = params.OutInstances;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInstancedStaticMeshFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInstancedStaticMeshFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.InstancedStaticMeshFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.UpdateInteractionPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableInterface::UpdateInteractionPosition(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.UpdateInteractionPosition");
		
		UInteractableInterface_UpdateInteractionPosition_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.IsLockingAnim
	 * 		Flags  -> ()
	 */
	bool UInteractableInterface::IsLockingAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.IsLockingAnim");
		
		UInteractableInterface_IsLockingAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.IsInteractionEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EInteractionState UInteractableInterface::IsInteractionEnabled(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.IsInteractionEnabled");
		
		UInteractableInterface_IsInteractionEnabled_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.Interact
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableInterface::Interact(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.Interact");
		
		UInteractableInterface_Interact_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.HideHUDCursorWhenInRange
	 * 		Flags  -> ()
	 */
	bool UInteractableInterface::HideHUDCursorWhenInRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.HideHUDCursorWhenInRange");
		
		UInteractableInterface_HideHUDCursorWhenInRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.GetRequiredItemCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UInteractableInterface::GetRequiredItemCount(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.GetRequiredItemCount");
		
		UInteractableInterface_GetRequiredItemCount_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.GetRequiredItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle UInteractableInterface::GetRequiredItem(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.GetRequiredItem");
		
		UInteractableInterface_GetRequiredItem_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.GetOverrideInteractionTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UInteractableInterface::GetOverrideInteractionTime(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.GetOverrideInteractionTime");
		
		UInteractableInterface_GetOverrideInteractionTime_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.GetOverrideInteractIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EInteractionType UInteractableInterface::GetOverrideInteractIcon(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.GetOverrideInteractIcon");
		
		UInteractableInterface_GetOverrideInteractIcon_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.GetInteractionType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EInteractionType UInteractableInterface::GetInteractionType(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.GetInteractionType");
		
		UInteractableInterface_GetInteractionType_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.GetInteractionText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OutText                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableInterface::GetInteractionText(EInteractionChannel Channel, class AActor* InstigatedBy, class FString* OutText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.GetInteractionText");
		
		UInteractableInterface_GetInteractionText_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutText != nullptr)
			*OutText = params.OutText;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.GetInteractionPriority
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EInteractionPriority UInteractableInterface::GetInteractionPriority(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.GetInteractionPriority");
		
		UInteractableInterface_GetInteractionPriority_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.GetInteractHoldAnimType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EInteractAnimType UInteractableInterface::GetInteractHoldAnimType(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.GetInteractHoldAnimType");
		
		UInteractableInterface_GetInteractHoldAnimType_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.GetInteractHighlightLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EInteractHighlightLevel UInteractableInterface::GetInteractHighlightLevel(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.GetInteractHighlightLevel");
		
		UInteractableInterface_GetInteractHighlightLevel_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.GetInteractableName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      OutText                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableInterface::GetInteractableName(class FString* OutText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.GetInteractableName");
		
		UInteractableInterface_GetInteractableName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutText != nullptr)
			*OutText = params.OutText;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.GetInteractableAnimType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EInteractAnimType UInteractableInterface::GetInteractableAnimType(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.GetInteractableAnimType");
		
		UInteractableInterface_GetInteractableAnimType_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.GetInteractableAnimProp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* UInteractableInterface::GetInteractableAnimProp(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.GetInteractableAnimProp");
		
		UInteractableInterface_GetInteractableAnimProp_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.GetCustomInteractAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimMontage* UInteractableInterface::GetCustomInteractAnim(EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.GetCustomInteractAnim");
		
		UInteractableInterface_GetCustomInteractAnim_Params params {};
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.EndInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableInterface::EndInteraction(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.EndInteraction");
		
		UInteractableInterface_EndInteraction_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.EndInteractHold
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInteractHoldHandleType                            HoldInteractType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableInterface::EndInteractHold(class AActor* InstigatedBy, EInteractHoldHandleType HoldInteractType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.EndInteractHold");
		
		UInteractableInterface_EndInteractHold_Params params {};
		params.InstigatedBy = InstigatedBy;
		params.HoldInteractType = HoldInteractType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableInterface.BeginInteractHold
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableInterface::BeginInteractHold(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableInterface.BeginInteractHold");
		
		UInteractableInterface_BeginInteractHold_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInteractableInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInteractableInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.InteractableInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableFunctionLibrary.ShowInteractionInterface
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInteractableFunctionLibrary::ShowInteractionInterface(class UObject* Interactable, EInteractionChannel Channel, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableFunctionLibrary.ShowInteractionInterface");
		
		UInteractableFunctionLibrary_ShowInteractionInterface_Params params {};
		params.Interactable = Interactable;
		params.Channel = Channel;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableFunctionLibrary.ShouldShowAnyInteractionInterface
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInteractableFunctionLibrary::ShouldShowAnyInteractionInterface(class UObject* Interactable, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableFunctionLibrary.ShouldShowAnyInteractionInterface");
		
		UInteractableFunctionLibrary_ShouldShowAnyInteractionInterface_Params params {};
		params.Interactable = Interactable;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableFunctionLibrary.SendInteractError
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        Warning                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UInteractableFunctionLibrary::SendInteractError(class UObject* Source, class AActor* InstigatedBy, const class FText& Warning)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableFunctionLibrary.SendInteractError");
		
		UInteractableFunctionLibrary_SendInteractError_Params params {};
		params.Source = Source;
		params.InstigatedBy = InstigatedBy;
		params.Warning = Warning;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableFunctionLibrary.IsAnyInteractionEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInteractableFunctionLibrary::IsAnyInteractionEnabled(class UObject* Interactable, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableFunctionLibrary.IsAnyInteractionEnabled");
		
		UInteractableFunctionLibrary_IsAnyInteractionEnabled_Params params {};
		params.Interactable = Interactable;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableFunctionLibrary.GetInteractItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UInteractableFunctionLibrary::GetInteractItem(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableFunctionLibrary.GetInteractItem");
		
		UInteractableFunctionLibrary_GetInteractItem_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteractableFunctionLibrary.GetFirstEnabledPrimaryInteractionType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EInteractionType UInteractableFunctionLibrary::GetFirstEnabledPrimaryInteractionType(class UObject* Interactable, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteractableFunctionLibrary.GetFirstEnabledPrimaryInteractionType");
		
		UInteractableFunctionLibrary_GetFirstEnabledPrimaryInteractionType_Params params {};
		params.Interactable = Interactable;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInteractableFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInteractableFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.InteractableFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.ShouldTrackDesiredTarget
	 * 		Flags  -> ()
	 */
	bool UInterestCore::ShouldTrackDesiredTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.ShouldTrackDesiredTarget");
		
		UInterestCore_ShouldTrackDesiredTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.ShouldInteractWithFace
	 * 		Flags  -> ()
	 */
	bool UInterestCore::ShouldInteractWithFace()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.ShouldInteractWithFace");
		
		UInterestCore_ShouldInteractWithFace_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.SetVitalValueBySemantic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                Tag                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInterestCore::SetVitalValueBySemantic(const struct FGameplayTag& Tag, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.SetVitalValueBySemantic");
		
		UInterestCore_SetVitalValueBySemantic_Params params {};
		params.Tag = Tag;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.SetActivityMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECreatureActivityMode                              Mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterestCore::SetActivityMode(ECreatureActivityMode Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.SetActivityMode");
		
		UInterestCore_SetActivityMode_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.HasInterest
	 * 		Flags  -> ()
	 */
	bool UInterestCore::HasInterest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.HasInterest");
		
		UInterestCore_HasInterest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.HasDesiredBreadcrumb
	 * 		Flags  -> ()
	 */
	bool UInterestCore::HasDesiredBreadcrumb()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.HasDesiredBreadcrumb");
		
		UInterestCore_HasDesiredBreadcrumb_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetVitalValueBySemantic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                Tag                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInterestCore::GetVitalValueBySemantic(const struct FGameplayTag& Tag, float* Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetVitalValueBySemantic");
		
		UInterestCore_GetVitalValueBySemantic_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Value != nullptr)
			*Value = params.Value;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetVitalValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UVitalStat*                                  Stat                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInterestCore::GetVitalValue(class UVitalStat* Stat, float* Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetVitalValue");
		
		UInterestCore_GetVitalValue_Params params {};
		params.Stat = Stat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Value != nullptr)
			*Value = params.Value;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetVitalState
	 * 		Flags  -> ()
	 */
	struct FVitalState UInterestCore::GetVitalState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetVitalState");
		
		UInterestCore_GetVitalState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetVitals
	 * 		Flags  -> ()
	 */
	TMap<class UVitalStat*, struct FVitalStatValue> UInterestCore::GetVitals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetVitals");
		
		UInterestCore_GetVitals_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetTirednessTag
	 * 		Flags  -> ()
	 */
	struct FGameplayTag UInterestCore::GetTirednessTag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetTirednessTag");
		
		UInterestCore_GetTirednessTag_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetState
	 * 		Flags  -> ()
	 */
	struct FRealInterestState UInterestCore::GetState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetState");
		
		UInterestCore_GetState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetShouldDropBreadcrumbs
	 * 		Flags  -> ()
	 */
	bool UInterestCore::GetShouldDropBreadcrumbs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetShouldDropBreadcrumbs");
		
		UInterestCore_GetShouldDropBreadcrumbs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetPetHappinessNormalized
	 * 		Flags  -> ()
	 */
	float UInterestCore::GetPetHappinessNormalized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetPetHappinessNormalized");
		
		UInterestCore_GetPetHappinessNormalized_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetMustLand
	 * 		Flags  -> ()
	 */
	bool UInterestCore::GetMustLand()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetMustLand");
		
		UInterestCore_GetMustLand_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetFoodTags
	 * 		Flags  -> ()
	 */
	struct FGameplayTagContainer UInterestCore::GetFoodTags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetFoodTags");
		
		UInterestCore_GetFoodTags_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetFacingBehavior
	 * 		Flags  -> ()
	 */
	EFaceTargetType UInterestCore::GetFacingBehavior()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetFacingBehavior");
		
		UInterestCore_GetFacingBehavior_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetDesiredTargetRotation
	 * 		Flags  -> ()
	 */
	struct FRotator UInterestCore::GetDesiredTargetRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetDesiredTargetRotation");
		
		UInterestCore_GetDesiredTargetRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetDesiredTargetLocation
	 * 		Flags  -> ()
	 */
	struct FVector UInterestCore::GetDesiredTargetLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetDesiredTargetLocation");
		
		UInterestCore_GetDesiredTargetLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetDesiredTarget
	 * 		Flags  -> ()
	 */
	class UAttractionComponent* UInterestCore::GetDesiredTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetDesiredTarget");
		
		UInterestCore_GetDesiredTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetBreadcrumbActionLocation
	 * 		Flags  -> ()
	 */
	struct FVector UInterestCore::GetBreadcrumbActionLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetBreadcrumbActionLocation");
		
		UInterestCore_GetBreadcrumbActionLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetBreadcrumbAction
	 * 		Flags  -> ()
	 */
	struct FGoapActionInstance UInterestCore::GetBreadcrumbAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetBreadcrumbAction");
		
		UInterestCore_GetBreadcrumbAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.GetActivityMode
	 * 		Flags  -> ()
	 */
	ECreatureActivityMode UInterestCore::GetActivityMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.GetActivityMode");
		
		UInterestCore_GetActivityMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.AdjustVitalValueBySemantic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                Tag                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Adjustment                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterestCore::AdjustVitalValueBySemantic(const struct FGameplayTag& Tag, float Adjustment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.AdjustVitalValueBySemantic");
		
		UInterestCore_AdjustVitalValueBySemantic_Params params {};
		params.Tag = Tag;
		params.Adjustment = Adjustment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestCore.AdjustVitalValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UVitalStat*                                  Stat                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Adjustment                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterestCore::AdjustVitalValue(class UVitalStat* Stat, float Adjustment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestCore.AdjustVitalValue");
		
		UInterestCore_AdjustVitalValue_Params params {};
		params.Stat = Stat;
		params.Adjustment = Adjustment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterestCore.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterestCore::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.InterestCore");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.VisitBreadcrumb
	 * 		Flags  -> ()
	 */
	void UInterestComponent::VisitBreadcrumb()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.VisitBreadcrumb");
		
		UInterestComponent_VisitBreadcrumb_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.HasInterest
	 * 		Flags  -> ()
	 */
	bool UInterestComponent::HasInterest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.HasInterest");
		
		UInterestComponent_HasInterest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.HasDesiredBreadcrumb
	 * 		Flags  -> ()
	 */
	bool UInterestComponent::HasDesiredBreadcrumb()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.HasDesiredBreadcrumb");
		
		UInterestComponent_HasDesiredBreadcrumb_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetWorldEvaluators
	 * 		Flags  -> ()
	 */
	TArray<class UGoapWorldStateEvaluator*> UInterestComponent::GetWorldEvaluators()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetWorldEvaluators");
		
		UInterestComponent_GetWorldEvaluators_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetVitalValueBySemantic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                Tag                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInterestComponent::GetVitalValueBySemantic(const struct FGameplayTag& Tag, float* Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetVitalValueBySemantic");
		
		UInterestComponent_GetVitalValueBySemantic_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Value != nullptr)
			*Value = params.Value;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetVitalValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UVitalStat*                                  Stat                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInterestComponent::GetVitalValue(class UVitalStat* Stat, float* Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetVitalValue");
		
		UInterestComponent_GetVitalValue_Params params {};
		params.Stat = Stat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Value != nullptr)
			*Value = params.Value;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetVitalState
	 * 		Flags  -> ()
	 */
	struct FVitalState UInterestComponent::GetVitalState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetVitalState");
		
		UInterestComponent_GetVitalState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetVitals
	 * 		Flags  -> ()
	 */
	TMap<class UVitalStat*, struct FVitalStatValue> UInterestComponent::GetVitals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetVitals");
		
		UInterestComponent_GetVitals_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetTirednessTag
	 * 		Flags  -> ()
	 */
	struct FGameplayTag UInterestComponent::GetTirednessTag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetTirednessTag");
		
		UInterestComponent_GetTirednessTag_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetState
	 * 		Flags  -> ()
	 */
	struct FRealInterestState UInterestComponent::GetState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetState");
		
		UInterestComponent_GetState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetShouldDropBreadcrumbs
	 * 		Flags  -> ()
	 */
	bool UInterestComponent::GetShouldDropBreadcrumbs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetShouldDropBreadcrumbs");
		
		UInterestComponent_GetShouldDropBreadcrumbs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetFoodTags
	 * 		Flags  -> ()
	 */
	struct FGameplayTagContainer UInterestComponent::GetFoodTags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetFoodTags");
		
		UInterestComponent_GetFoodTags_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetFleeBreadcrumbAction
	 * 		Flags  -> ()
	 */
	class UGoapAction* UInterestComponent::GetFleeBreadcrumbAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetFleeBreadcrumbAction");
		
		UInterestComponent_GetFleeBreadcrumbAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetDesiredTargetRotation
	 * 		Flags  -> ()
	 */
	struct FRotator UInterestComponent::GetDesiredTargetRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetDesiredTargetRotation");
		
		UInterestComponent_GetDesiredTargetRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetDesiredTargetLocation
	 * 		Flags  -> ()
	 */
	struct FVector UInterestComponent::GetDesiredTargetLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetDesiredTargetLocation");
		
		UInterestComponent_GetDesiredTargetLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetDesiredTargetActor
	 * 		Flags  -> ()
	 */
	class AActor* UInterestComponent::GetDesiredTargetActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetDesiredTargetActor");
		
		UInterestComponent_GetDesiredTargetActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetDesiredTarget
	 * 		Flags  -> ()
	 */
	class UAttractionComponent* UInterestComponent::GetDesiredTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetDesiredTarget");
		
		UInterestComponent_GetDesiredTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetBreadcrumbActionLocation
	 * 		Flags  -> ()
	 */
	struct FVector UInterestComponent::GetBreadcrumbActionLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetBreadcrumbActionLocation");
		
		UInterestComponent_GetBreadcrumbActionLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetBreadcrumbAction
	 * 		Flags  -> ()
	 */
	struct FGoapActionInstance UInterestComponent::GetBreadcrumbAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetBreadcrumbAction");
		
		UInterestComponent_GetBreadcrumbAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetBaselineAction
	 * 		Flags  -> ()
	 */
	class UGoapAction* UInterestComponent::GetBaselineAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetBaselineAction");
		
		UInterestComponent_GetBaselineAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.GetActivityMode
	 * 		Flags  -> ()
	 */
	ECreatureActivityMode UInterestComponent::GetActivityMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.GetActivityMode");
		
		UInterestComponent_GetActivityMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.AdjustVitalValueBySemantic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                Tag                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Adjustment                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterestComponent::AdjustVitalValueBySemantic(const struct FGameplayTag& Tag, float Adjustment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.AdjustVitalValueBySemantic");
		
		UInterestComponent_AdjustVitalValueBySemantic_Params params {};
		params.Tag = Tag;
		params.Adjustment = Adjustment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InterestComponent.AdjustVitalValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UVitalStat*                                  Stat                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Adjustment                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterestComponent::AdjustVitalValue(class UVitalStat* Stat, float Adjustment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InterestComponent.AdjustVitalValue");
		
		UInterestComponent_AdjustVitalValue_Params params {};
		params.Stat = Stat;
		params.Adjustment = Adjustment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterestComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterestComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.InterestComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterestManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterestManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.InterestManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameInterfaceNarrationLibrary.GetFirstChordHelper
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ActionName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAxisPositive                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUsingGamepad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FInputChord UGameInterfaceNarrationLibrary::GetFirstChordHelper(const class FName& ActionName, bool bAxisPositive, bool bUsingGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameInterfaceNarrationLibrary.GetFirstChordHelper");
		
		UGameInterfaceNarrationLibrary_GetFirstChordHelper_Params params {};
		params.ActionName = ActionName;
		params.bAxisPositive = bAxisPositive;
		params.bUsingGamepad = bUsingGamepad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameInterfaceNarrationLibrary.AddDoubleControlChunk
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FNarrationChunk>                     Chunks                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class UWidget*                                     Widget                                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ActionName1                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAxisPositive1                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ActionName2                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAxisPositive2                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ActionDisplayName                                          (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyIfChanged                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bVerbose                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameInterfaceNarrationLibrary::AddDoubleControlChunk(TArray<struct FNarrationChunk>* Chunks, class UWidget* Widget, const class FName& ActionName1, bool bAxisPositive1, const class FName& ActionName2, bool bAxisPositive2, const class FString& ActionDisplayName, bool bOnlyIfChanged, bool bVerbose)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameInterfaceNarrationLibrary.AddDoubleControlChunk");
		
		UGameInterfaceNarrationLibrary_AddDoubleControlChunk_Params params {};
		params.Widget = Widget;
		params.ActionName1 = ActionName1;
		params.bAxisPositive1 = bAxisPositive1;
		params.ActionName2 = ActionName2;
		params.bAxisPositive2 = bAxisPositive2;
		params.ActionDisplayName = ActionDisplayName;
		params.bOnlyIfChanged = bOnlyIfChanged;
		params.bVerbose = bVerbose;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Chunks != nullptr)
			*Chunks = params.Chunks;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.GameInterfaceNarrationLibrary.AddControlChunk
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FNarrationChunk>                     Chunks                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class UWidget*                                     Widget                                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ActionName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAxisPositive                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ActionDisplayName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyIfChanged                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bVerbose                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsHold                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameInterfaceNarrationLibrary::AddControlChunk(TArray<struct FNarrationChunk>* Chunks, class UWidget* Widget, const class FName& ActionName, bool bAxisPositive, const class FString& ActionDisplayName, bool bOnlyIfChanged, bool bVerbose, bool bIsHold)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.GameInterfaceNarrationLibrary.AddControlChunk");
		
		UGameInterfaceNarrationLibrary_AddControlChunk_Params params {};
		params.Widget = Widget;
		params.ActionName = ActionName;
		params.bAxisPositive = bAxisPositive;
		params.ActionDisplayName = ActionDisplayName;
		params.bOnlyIfChanged = bOnlyIfChanged;
		params.bVerbose = bVerbose;
		params.bIsHold = bIsHold;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Chunks != nullptr)
			*Chunks = params.Chunks;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameInterfaceNarrationLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameInterfaceNarrationLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.GameInterfaceNarrationLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteriorTrigger.OnTriggerEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AInteriorTrigger::OnTriggerEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteriorTrigger.OnTriggerEndOverlap");
		
		AInteriorTrigger_OnTriggerEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InteriorTrigger.OnTriggerBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AInteriorTrigger::OnTriggerBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InteriorTrigger.OnTriggerBeginOverlap");
		
		AInteriorTrigger_OnTriggerBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AInteriorTrigger.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AInteriorTrigger::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.InteriorTrigger");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.TryCraftItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bEquip                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CraftCount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::TryCraftItem(const struct FDataTableRowHandle& RecipeRowHandle, bool bEquip, int32_t CraftCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.TryCraftItem");
		
		UInventoryComponent_TryCraftItem_Params params {};
		params.RecipeRowHandle = RecipeRowHandle;
		params.bEquip = bEquip;
		params.CraftCount = CraftCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerTransferItemTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInventoryComponent*                         ToInventory                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerTransferItemTo(class UItem* Item, class UInventoryComponent* ToInventory, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerTransferItemTo");
		
		UInventoryComponent_ServerTransferItemTo_Params params {};
		params.Item = Item;
		params.ToInventory = ToInventory;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerTransferItemFrom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInventoryComponent*                         FromInventory                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerTransferItemFrom(class UItem* Item, class UInventoryComponent* FromInventory, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerTransferItemFrom");
		
		UInventoryComponent_ServerTransferItemFrom_Params params {};
		params.Item = Item;
		params.FromInventory = FromInventory;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerTransferAllTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInventoryComponent*                         ToInventory                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsNewItem                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerTransferAllTo(class UInventoryComponent* ToInventory, bool IsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerTransferAllTo");
		
		UInventoryComponent_ServerTransferAllTo_Params params {};
		params.ToInventory = ToInventory;
		params.IsNewItem = IsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerTransferAllFrom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInventoryComponent*                         FromInventory                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsNewItem                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerTransferAllFrom(class UInventoryComponent* FromInventory, bool IsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerTransferAllFrom");
		
		UInventoryComponent_ServerTransferAllFrom_Params params {};
		params.FromInventory = FromInventory;
		params.IsNewItem = IsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerSwapItemSlotsBetweenInventories
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item1                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInventoryComponent*                         Inventory2                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item2                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerSwapItemSlotsBetweenInventories(class UItem* Item1, int32_t Index1, class UInventoryComponent* Inventory2, class UItem* Item2, int32_t Index2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerSwapItemSlotsBetweenInventories");
		
		UInventoryComponent_ServerSwapItemSlotsBetweenInventories_Params params {};
		params.Item1 = Item1;
		params.Index1 = Index1;
		params.Inventory2 = Inventory2;
		params.Item2 = Item2;
		params.Index2 = Index2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerSwapItemSlots
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInventoryComponent*                         SourceInventory                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item1                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item2                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerSwapItemSlots(class UInventoryComponent* SourceInventory, class UItem* Item1, int32_t Index1, class UItem* Item2, int32_t Index2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerSwapItemSlots");
		
		UInventoryComponent_ServerSwapItemSlots_Params params {};
		params.SourceInventory = SourceInventory;
		params.Item1 = Item1;
		params.Index1 = Index1;
		params.Item2 = Item2;
		params.Index2 = Index2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerRemoveItemMatchingItemData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemDataRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerRemoveItemMatchingItemData(const struct FDataTableRowHandle& ItemDataRowHandle, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerRemoveItemMatchingItemData");
		
		UInventoryComponent_ServerRemoveItemMatchingItemData_Params params {};
		params.ItemDataRowHandle = ItemDataRowHandle;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerRemoveItemAtIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerRemoveItemAtIndex(int32_t Index, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerRemoveItemAtIndex");
		
		UInventoryComponent_ServerRemoveItemAtIndex_Params params {};
		params.Index = Index;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerRemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerRemoveItem(class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerRemoveItem");
		
		UInventoryComponent_ServerRemoveItem_Params params {};
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerRemoveAllItems
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::ServerRemoveAllItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerRemoveAllItems");
		
		UInventoryComponent_ServerRemoveAllItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerMergeItemStacks
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInventoryComponent*                         SourceInventory                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       SourceItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       DestinationItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerMergeItemStacks(class UInventoryComponent* SourceInventory, class UItem* SourceItem, class UItem* DestinationItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerMergeItemStacks");
		
		UInventoryComponent_ServerMergeItemStacks_Params params {};
		params.SourceInventory = SourceInventory;
		params.SourceItem = SourceItem;
		params.DestinationItem = DestinationItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerDropItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerDropItem(class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerDropItem");
		
		UInventoryComponent_ServerDropItem_Params params {};
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerDefragInventory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               SingleItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerDefragInventory(bool SingleItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerDefragInventory");
		
		UInventoryComponent_ServerDefragInventory_Params params {};
		params.SingleItem = SingleItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerCreateAndDropItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerCreateAndDropItem(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerCreateAndDropItem");
		
		UInventoryComponent_ServerCreateAndDropItem_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerCreateAndAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerCreateAndAddItem(const struct FDataTableRowHandle& ItemRowHandle, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerCreateAndAddItem");
		
		UInventoryComponent_ServerCreateAndAddItem_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerCraftRecipeForInventory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UInventoryComponent*                         DestinationInventory                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       RecipeModItem                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerCraftRecipeForInventory(const struct FDataTableRowHandle& RecipeRowHandle, class UInventoryComponent* DestinationInventory, class UItem* RecipeModItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerCraftRecipeForInventory");
		
		UInventoryComponent_ServerCraftRecipeForInventory_Params params {};
		params.RecipeRowHandle = RecipeRowHandle;
		params.DestinationInventory = DestinationInventory;
		params.RecipeModItem = RecipeModItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerCraftRecipeDataForInventory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UInventoryComponent*                         DestinationInventory                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         RecipeModRowHandle                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerCraftRecipeDataForInventory(const struct FDataTableRowHandle& RecipeRowHandle, class UInventoryComponent* DestinationInventory, const struct FDataTableRowHandle& RecipeModRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerCraftRecipeDataForInventory");
		
		UInventoryComponent_ServerCraftRecipeDataForInventory_Params params {};
		params.RecipeRowHandle = RecipeRowHandle;
		params.DestinationInventory = DestinationInventory;
		params.RecipeModRowHandle = RecipeModRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerCraftRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bEquip                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CraftCount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerCraftRecipe(const struct FDataTableRowHandle& RecipeRowHandle, bool bEquip, int32_t CraftCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerCraftRecipe");
		
		UInventoryComponent_ServerCraftRecipe_Params params {};
		params.RecipeRowHandle = RecipeRowHandle;
		params.bEquip = bEquip;
		params.CraftCount = CraftCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ServerAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsNewItem                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ServerAddItem(class UItem* Item, bool IsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ServerAddItem");
		
		UInventoryComponent_ServerAddItem_Params params {};
		params.Item = Item;
		params.IsNewItem = IsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.RemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UInventoryComponent::RemoveItem(class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.RemoveItem");
		
		UInventoryComponent_RemoveItem_Params params {};
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.PopRandomItem
	 * 		Flags  -> ()
	 */
	class UItem* UInventoryComponent::PopRandomItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.PopRandomItem");
		
		UInventoryComponent_PopRandomItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.PopItem
	 * 		Flags  -> ()
	 */
	class UItem* UInventoryComponent::PopItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.PopItem");
		
		UInventoryComponent_PopItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.OnRep_Items
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UItem*>                               PreviousItems                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::OnRep_Items(TArray<class UItem*> PreviousItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.OnRep_Items");
		
		UInventoryComponent_OnRep_Items_Params params {};
		params.PreviousItems = PreviousItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.OnItemsChanged
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::OnItemsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.OnItemsChanged");
		
		UInventoryComponent_OnItemsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.OnItemChanged
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::OnItemChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.OnItemChanged");
		
		UInventoryComponent_OnItemChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.NotifyItemSpoiled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         OriginalItemHandle                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         SpoiledResultHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::NotifyItemSpoiled(const struct FDataTableRowHandle& OriginalItemHandle, const struct FDataTableRowHandle& SpoiledResultHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.NotifyItemSpoiled");
		
		UInventoryComponent_NotifyItemSpoiled_Params params {};
		params.OriginalItemHandle = OriginalItemHandle;
		params.SpoiledResultHandle = SpoiledResultHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.IsSlotAvailable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            SlotIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::IsSlotAvailable(int32_t SlotIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.IsSlotAvailable");
		
		UInventoryComponent_IsSlotAvailable_Params params {};
		params.SlotIndex = SlotIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.IsInventoryFull
	 * 		Flags  -> ()
	 */
	bool UInventoryComponent::IsInventoryFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.IsInventoryFull");
		
		UInventoryComponent_IsInventoryFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.IsInventoryEmpty
	 * 		Flags  -> ()
	 */
	bool UInventoryComponent::IsInventoryEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.IsInventoryEmpty");
		
		UInventoryComponent_IsInventoryEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.HasRequirements
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRecipeRequirements>                 Requirements                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::HasRequirements(TArray<struct FRecipeRequirements> Requirements)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.HasRequirements");
		
		UInventoryComponent_HasRequirements_Params params {};
		params.Requirements = Requirements;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.HasAnySpaceForItemHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::HasAnySpaceForItemHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.HasAnySpaceForItemHandle");
		
		UInventoryComponent_HasAnySpaceForItemHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.HasAnySpaceForItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::HasAnySpaceForItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.HasAnySpaceForItem");
		
		UInventoryComponent_HasAnySpaceForItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetTotalItemCount
	 * 		Flags  -> ()
	 */
	int32_t UInventoryComponent::GetTotalItemCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetTotalItemCount");
		
		UInventoryComponent_GetTotalItemCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetNextAvailableInventorySlot
	 * 		Flags  -> ()
	 */
	int32_t UInventoryComponent::GetNextAvailableInventorySlot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetNextAvailableInventorySlot");
		
		UInventoryComponent_GetNextAvailableInventorySlot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetMaxSize
	 * 		Flags  -> ()
	 */
	int32_t UInventoryComponent::GetMaxSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetMaxSize");
		
		UInventoryComponent_GetMaxSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetMaxAllowedSpaceForItemHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UInventoryComponent::GetMaxAllowedSpaceForItemHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetMaxAllowedSpaceForItemHandle");
		
		UInventoryComponent_GetMaxAllowedSpaceForItemHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetMaxAllowedSpaceForItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UInventoryComponent::GetMaxAllowedSpaceForItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetMaxAllowedSpaceForItem");
		
		UInventoryComponent_GetMaxAllowedSpaceForItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetItemsIncludingEquipment
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UInventoryComponent::GetItemsIncludingEquipment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetItemsIncludingEquipment");
		
		UInventoryComponent_GetItemsIncludingEquipment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UInventoryComponent::GetItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetItems");
		
		UInventoryComponent_GetItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetItemInSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UInventoryComponent::GetItemInSlot(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetItemInSlot");
		
		UInventoryComponent_GetItemInSlot_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetItemCountMatchingHotBarKeyIncludingEquipment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHotBarQuickSlotItemTypeKey                 ItemKey                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               IncludeBrokenItems                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UInventoryComponent::GetItemCountMatchingHotBarKeyIncludingEquipment(const struct FHotBarQuickSlotItemTypeKey& ItemKey, bool IncludeBrokenItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetItemCountMatchingHotBarKeyIncludingEquipment");
		
		UInventoryComponent_GetItemCountMatchingHotBarKeyIncludingEquipment_Params params {};
		params.ItemKey = ItemKey;
		params.IncludeBrokenItems = IncludeBrokenItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetItemCountIncludingEquipment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               IncludeBrokenItems                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UInventoryComponent::GetItemCountIncludingEquipment(const struct FDataTableRowHandle& ItemRowHandle, bool IncludeBrokenItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetItemCountIncludingEquipment");
		
		UInventoryComponent_GetItemCountIncludingEquipment_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.IncludeBrokenItems = IncludeBrokenItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetItemCountForHotBarKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHotBarQuickSlotItemTypeKey                 ItemKey                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               IncludeBrokenItems                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UInventoryComponent::GetItemCountForHotBarKey(const struct FHotBarQuickSlotItemTypeKey& ItemKey, bool IncludeBrokenItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetItemCountForHotBarKey");
		
		UInventoryComponent_GetItemCountForHotBarKey_Params params {};
		params.ItemKey = ItemKey;
		params.IncludeBrokenItems = IncludeBrokenItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetItemCountByName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UInventoryComponent::GetItemCountByName(const class FName& ItemName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetItemCountByName");
		
		UInventoryComponent_GetItemCountByName_Params params {};
		params.ItemName = ItemName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetItemCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               IncludeBrokenItems                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UInventoryComponent::GetItemCount(const struct FDataTableRowHandle& ItemRowHandle, bool IncludeBrokenItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetItemCount");
		
		UInventoryComponent_GetItemCount_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.IncludeBrokenItems = IncludeBrokenItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UInventoryComponent::GetItem(const class FName& ItemName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetItem");
		
		UInventoryComponent_GetItem_Params params {};
		params.ItemName = ItemName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetExistingStackSpaceForItemHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UInventoryComponent::GetExistingStackSpaceForItemHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetExistingStackSpaceForItemHandle");
		
		UInventoryComponent_GetExistingStackSpaceForItemHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetEmptySlots
	 * 		Flags  -> ()
	 */
	int32_t UInventoryComponent::GetEmptySlots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetEmptySlots");
		
		UInventoryComponent_GetEmptySlots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.GetDropItemTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform UInventoryComponent::GetDropItemTransform(class UItem* Item, const struct FVector& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.GetDropItemTransform");
		
		UInventoryComponent_GetDropItemTransform_Params params {};
		params.Item = Item;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.FindPartialItemStackForItemHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UItem* UInventoryComponent::FindPartialItemStackForItemHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.FindPartialItemStackForItemHandle");
		
		UInventoryComponent_FindPartialItemStackForItemHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.FindPartialItemStackForItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UInventoryComponent::FindPartialItemStackForItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.FindPartialItemStackForItem");
		
		UInventoryComponent_FindPartialItemStackForItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ContainsItemOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UInventoryComponent::ContainsItemOfType(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ContainsItemOfType");
		
		UInventoryComponent_ContainsItemOfType_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ContainsItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::ContainsItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ContainsItem");
		
		UInventoryComponent_ContainsItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ClientOnItemStashFailue
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::ClientOnItemStashFailue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ClientOnItemStashFailue");
		
		UInventoryComponent_ClientOnItemStashFailue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ClientOnItemStashed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ClientOnItemStashed(const struct FDataTableRowHandle& ItemRowHandle, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ClientOnItemStashed");
		
		UInventoryComponent_ClientOnItemStashed_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ClientOnItemSpoiled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         OriginalItemHandle                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         SpoiledResultHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ClientOnItemSpoiled(const struct FDataTableRowHandle& OriginalItemHandle, const struct FDataTableRowHandle& SpoiledResultHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ClientOnItemSpoiled");
		
		UInventoryComponent_ClientOnItemSpoiled_Params params {};
		params.OriginalItemHandle = OriginalItemHandle;
		params.SpoiledResultHandle = SpoiledResultHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ClientOnItemRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ClientOnItemRemoved(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ClientOnItemRemoved");
		
		UInventoryComponent_ClientOnItemRemoved_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ClientOnItemAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               IsNewItem                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewCount                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ClientOnItemAdded(const struct FDataTableRowHandle& ItemRowHandle, bool IsNewItem, int32_t NewCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ClientOnItemAdded");
		
		UInventoryComponent_ClientOnItemAdded_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.IsNewItem = IsNewItem;
		params.NewCount = NewCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.ClientNotifyCraftedWithFullInventory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ClientNotifyCraftedWithFullInventory(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.ClientNotifyCraftedWithFullInventory");
		
		UInventoryComponent_ClientNotifyCraftedWithFullInventory_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.CanTransferAllFrom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInventoryComponent*                         FromInventory                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::CanTransferAllFrom(class UInventoryComponent* FromInventory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.CanTransferAllFrom");
		
		UInventoryComponent_CanTransferAllFrom_Params params {};
		params.FromInventory = FromInventory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.CanCraftRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::CanCraftRecipe(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.CanCraftRecipe");
		
		UInventoryComponent_CanCraftRecipe_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.CanAddItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UItem*>                               InItems                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::CanAddItems(TArray<class UItem*> InItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.CanAddItems");
		
		UInventoryComponent_CanAddItems_Params params {};
		params.InItems = InItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.CanAddItemRowHandles
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 ItemRowHandles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::CanAddItemRowHandles(TArray<struct FDataTableRowHandle> ItemRowHandles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.CanAddItemRowHandles");
		
		UInventoryComponent_CanAddItemRowHandles_Params params {};
		params.ItemRowHandles = ItemRowHandles;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.CanAddItemRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::CanAddItemRowHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.CanAddItemRowHandle");
		
		UInventoryComponent_CanAddItemRowHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.CanAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::CanAddItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.CanAddItem");
		
		UInventoryComponent_CanAddItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryComponent.AddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNewItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::AddItem(class UItem* Item, bool bIsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryComponent.AddItem");
		
		UInventoryComponent_AddItem_Params params {};
		params.Item = Item;
		params.bIsNewItem = bIsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.InventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyInventoryComponent.RemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UProxyInventoryComponent::RemoveItem(class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyInventoryComponent.RemoveItem");
		
		UProxyInventoryComponent_RemoveItem_Params params {};
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyInventoryComponent.IsInventoryFull
	 * 		Flags  -> ()
	 */
	bool UProxyInventoryComponent::IsInventoryFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyInventoryComponent.IsInventoryFull");
		
		UProxyInventoryComponent_IsInventoryFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyInventoryComponent.IsInventoryEmpty
	 * 		Flags  -> ()
	 */
	bool UProxyInventoryComponent::IsInventoryEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyInventoryComponent.IsInventoryEmpty");
		
		UProxyInventoryComponent_IsInventoryEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyInventoryComponent.GetItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UProxyInventoryComponent::GetItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyInventoryComponent.GetItems");
		
		UProxyInventoryComponent_GetItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyInventoryComponent.GetDropItemTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform UProxyInventoryComponent::GetDropItemTransform(class UItem* Item, const struct FVector& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyInventoryComponent.GetDropItemTransform");
		
		UProxyInventoryComponent_GetDropItemTransform_Params params {};
		params.Item = Item;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyInventoryComponent.FindPartialItemStackForItemHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UItem* UProxyInventoryComponent::FindPartialItemStackForItemHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyInventoryComponent.FindPartialItemStackForItemHandle");
		
		UProxyInventoryComponent_FindPartialItemStackForItemHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyInventoryComponent.FindPartialItemStackForItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UProxyInventoryComponent::FindPartialItemStackForItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyInventoryComponent.FindPartialItemStackForItem");
		
		UProxyInventoryComponent_FindPartialItemStackForItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyInventoryComponent.CanAddItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UItem*>                               InItems                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UProxyInventoryComponent::CanAddItems(TArray<class UItem*> InItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyInventoryComponent.CanAddItems");
		
		UProxyInventoryComponent_CanAddItems_Params params {};
		params.InItems = InItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyInventoryComponent.CanAddItemRowHandles
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 ItemRowHandles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UProxyInventoryComponent::CanAddItemRowHandles(TArray<struct FDataTableRowHandle> ItemRowHandles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyInventoryComponent.CanAddItemRowHandles");
		
		UProxyInventoryComponent_CanAddItemRowHandles_Params params {};
		params.ItemRowHandles = ItemRowHandles;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyInventoryComponent.CanAddItemRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UProxyInventoryComponent::CanAddItemRowHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyInventoryComponent.CanAddItemRowHandle");
		
		UProxyInventoryComponent_CanAddItemRowHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyInventoryComponent.CanAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UProxyInventoryComponent::CanAddItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyInventoryComponent.CanAddItem");
		
		UProxyInventoryComponent_CanAddItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyInventoryComponent.AddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNewItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UProxyInventoryComponent::AddItem(class UItem* Item, bool bIsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyInventoryComponent.AddItem");
		
		UProxyInventoryComponent_AddItem_Params params {};
		params.Item = Item;
		params.bIsNewItem = bIsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryLODComponent.RemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UInventoryLODComponent::RemoveItem(class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryLODComponent.RemoveItem");
		
		UInventoryLODComponent_RemoveItem_Params params {};
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryLODComponent.GetItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UInventoryLODComponent::GetItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryLODComponent.GetItems");
		
		UInventoryLODComponent_GetItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryLODComponent.GetDropItemTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform UInventoryLODComponent::GetDropItemTransform(class UItem* Item, const struct FVector& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryLODComponent.GetDropItemTransform");
		
		UInventoryLODComponent_GetDropItemTransform_Params params {};
		params.Item = Item;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryLODComponent.CanAddItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UItem*>                               Items                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UInventoryLODComponent::CanAddItems(TArray<class UItem*> Items)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryLODComponent.CanAddItems");
		
		UInventoryLODComponent_CanAddItems_Params params {};
		params.Items = Items;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryLODComponent.CanAddItemRowHandles
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 ItemRowHandles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UInventoryLODComponent::CanAddItemRowHandles(TArray<struct FDataTableRowHandle> ItemRowHandles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryLODComponent.CanAddItemRowHandles");
		
		UInventoryLODComponent_CanAddItemRowHandles_Params params {};
		params.ItemRowHandles = ItemRowHandles;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryLODComponent.CanAddItemRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UInventoryLODComponent::CanAddItemRowHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryLODComponent.CanAddItemRowHandle");
		
		UInventoryLODComponent_CanAddItemRowHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryLODComponent.CanAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryLODComponent::CanAddItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryLODComponent.CanAddItem");
		
		UInventoryLODComponent_CanAddItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.InventoryLODComponent.AddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNewItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryLODComponent::AddItem(class UItem* Item, bool bIsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.InventoryLODComponent.AddItem");
		
		UInventoryLODComponent_AddItem_Params params {};
		params.Item = Item;
		params.bIsNewItem = bIsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInventoryLODComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInventoryLODComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.InventoryLODComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInventoryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInventoryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.InventoryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.UsesPowerType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                PowerType                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItem::UsesPowerType(const struct FGameplayTag& PowerType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.UsesPowerType");
		
		UItem_UsesPowerType_Params params {};
		params.PowerType = PowerType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.UsesPower
	 * 		Flags  -> ()
	 */
	bool UItem::UsesPower()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.UsesPower");
		
		UItem_UsesPower_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.UsesAmmo
	 * 		Flags  -> ()
	 */
	bool UItem::UsesAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.UsesAmmo");
		
		UItem_UsesAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.TryAddPower
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                PowerType                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Charges                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UItem::TryAddPower(const struct FGameplayTag& PowerType, float Charges, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.TryAddPower");
		
		UItem_TryAddPower_Params params {};
		params.PowerType = PowerType;
		params.Charges = Charges;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.SetStackSize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InStackSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UItem::SetStackSize(int32_t InStackSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.SetStackSize");
		
		UItem_SetStackSize_Params params {};
		params.InStackSize = InStackSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.SetInventorySlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItem::SetInventorySlot(int32_t Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.SetInventorySlot");
		
		UItem_SetInventorySlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.RestoreAllDurability
	 * 		Flags  -> ()
	 */
	void UItem::RestoreAllDurability()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.RestoreAllDurability");
		
		UItem_RestoreAllDurability_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.RemovePowerCharges
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItem::RemovePowerCharges(float Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.RemovePowerCharges");
		
		UItem_RemovePowerCharges_Params params {};
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.RemoveDurability
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItem::RemoveDurability(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.RemoveDurability");
		
		UItem_RemoveDurability_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.OnRep_SelectedAmmoType
	 * 		Flags  -> ()
	 */
	void UItem::OnRep_SelectedAmmoType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.OnRep_SelectedAmmoType");
		
		UItem_OnRep_SelectedAmmoType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.OnRep_PropertyChanged
	 * 		Flags  -> ()
	 */
	void UItem::OnRep_PropertyChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.OnRep_PropertyChanged");
		
		UItem_OnRep_PropertyChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.OnRep_ItemDataRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         PreviousHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UItem::OnRep_ItemDataRowHandle(const struct FDataTableRowHandle& PreviousHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.OnRep_ItemDataRowHandle");
		
		UItem_OnRep_ItemDataRowHandle_Params params {};
		params.PreviousHandle = PreviousHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.OnRep_IsPowerOn
	 * 		Flags  -> ()
	 */
	void UItem::OnRep_IsPowerOn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.OnRep_IsPowerOn");
		
		UItem_OnRep_IsPowerOn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.OnPowerStoredChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                PowerType                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ChargesStored                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItem::OnPowerStoredChanged(const struct FGameplayTag& PowerType, float ChargesStored)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.OnPowerStoredChanged");
		
		UItem_OnPowerStoredChanged_Params params {};
		params.PowerType = PowerType;
		params.ChargesStored = ChargesStored;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.LatentSpawnItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  SpawnTransform                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               DroppedBy                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EItemSpawnType                                     ItemSpawnType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UItem::LatentSpawnItem(class UObject* WorldContextObject, const struct FTransform& SpawnTransform, class UBaseLODActor* DroppedBy, EItemSpawnType ItemSpawnType, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.LatentSpawnItem");
		
		UItem_LatentSpawnItem_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.SpawnTransform = SpawnTransform;
		params.DroppedBy = DroppedBy;
		params.ItemSpawnType = ItemSpawnType;
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsValidBonusEnhancementType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                EnhancementType                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItem::IsValidBonusEnhancementType(const struct FGameplayTag& EnhancementType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsValidBonusEnhancementType");
		
		UItem_IsValidBonusEnhancementType_Params params {};
		params.EnhancementType = EnhancementType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsStackFull
	 * 		Flags  -> ()
	 */
	bool UItem::IsStackFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsStackFull");
		
		UItem_IsStackFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsPowerFull
	 * 		Flags  -> ()
	 */
	bool UItem::IsPowerFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsPowerFull");
		
		UItem_IsPowerFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsPowerEmpty
	 * 		Flags  -> ()
	 */
	bool UItem::IsPowerEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsPowerEmpty");
		
		UItem_IsPowerEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsPersonalKeyItem
	 * 		Flags  -> ()
	 */
	bool UItem::IsPersonalKeyItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsPersonalKeyItem");
		
		UItem_IsPersonalKeyItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsPartyKeyItem
	 * 		Flags  -> ()
	 */
	bool UItem::IsPartyKeyItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsPartyKeyItem");
		
		UItem_IsPartyKeyItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsLightSource
	 * 		Flags  -> ()
	 */
	bool UItem::IsLightSource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsLightSource");
		
		UItem_IsLightSource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsInstanceOf
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         Row                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UItem::IsInstanceOf(const struct FDataTableRowHandle& Row)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsInstanceOf");
		
		UItem_IsInstanceOf_Params params {};
		params.Row = Row;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsFullyCharged
	 * 		Flags  -> ()
	 */
	bool UItem::IsFullyCharged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsFullyCharged");
		
		UItem_IsFullyCharged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsEquipped
	 * 		Flags  -> ()
	 */
	bool UItem::IsEquipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsEquipped");
		
		UItem_IsEquipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsCharged
	 * 		Flags  -> ()
	 */
	bool UItem::IsCharged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsCharged");
		
		UItem_IsCharged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsBusy
	 * 		Flags  -> ()
	 */
	bool UItem::IsBusy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsBusy");
		
		UItem_IsBusy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsBroken
	 * 		Flags  -> ()
	 */
	bool UItem::IsBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsBroken");
		
		UItem_IsBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsAtMaxDurability
	 * 		Flags  -> ()
	 */
	bool UItem::IsAtMaxDurability()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsAtMaxDurability");
		
		UItem_IsAtMaxDurability_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsArmorItem
	 * 		Flags  -> ()
	 */
	bool UItem::IsArmorItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsArmorItem");
		
		UItem_IsArmorItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IsAHaulingItem
	 * 		Flags  -> ()
	 */
	bool UItem::IsAHaulingItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IsAHaulingItem");
		
		UItem_IsAHaulingItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.IncrementStackSize
	 * 		Flags  -> ()
	 */
	int32_t UItem::IncrementStackSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.IncrementStackSize");
		
		UItem_IncrementStackSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.HasTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                Tag                                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItem::HasTag(const struct FGameplayTag& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.HasTag");
		
		UItem_HasTag_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.HasDurability
	 * 		Flags  -> ()
	 */
	bool UItem::HasDurability()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.HasDurability");
		
		UItem_HasDurability_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.HasConversation
	 * 		Flags  -> ()
	 */
	bool UItem::HasConversation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.HasConversation");
		
		UItem_HasConversation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.HasConsumableEffectEver
	 * 		Flags  -> ()
	 */
	bool UItem::HasConsumableEffectEver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.HasConsumableEffectEver");
		
		UItem_HasConsumableEffectEver_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.HasConsumableEffect
	 * 		Flags  -> ()
	 */
	bool UItem::HasConsumableEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.HasConsumableEffect");
		
		UItem_HasConsumableEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.HasAnyTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTagContainer                       Tags                                                       (Parm, NativeAccessSpecifierPublic)
	 */
	bool UItem::HasAnyTag(const struct FGameplayTagContainer& Tags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.HasAnyTag");
		
		UItem_HasAnyTag_Params params {};
		params.Tags = Tags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetValidBonusEnhancementTags
	 * 		Flags  -> ()
	 */
	struct FGameplayTagContainer UItem::GetValidBonusEnhancementTags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetValidBonusEnhancementTags");
		
		UItem_GetValidBonusEnhancementTags_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetValidAmmoTypes
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UItem::GetValidAmmoTypes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetValidAmmoTypes");
		
		UItem_GetValidAmmoTypes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetTypeDisplayName
	 * 		Flags  -> ()
	 */
	struct FLocString UItem::GetTypeDisplayName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetTypeDisplayName");
		
		UItem_GetTypeDisplayName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetTotalSpoilTime
	 * 		Flags  -> ()
	 */
	float UItem::GetTotalSpoilTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetTotalSpoilTime");
		
		UItem_GetTotalSpoilTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetTotalHatchTime
	 * 		Flags  -> ()
	 */
	float UItem::GetTotalHatchTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetTotalHatchTime");
		
		UItem_GetTotalHatchTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetTotalEnhancementLevels
	 * 		Flags  -> ()
	 */
	int32_t UItem::GetTotalEnhancementLevels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetTotalEnhancementLevels");
		
		UItem_GetTotalEnhancementLevels_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetThrowSpeedMultiplierInWater
	 * 		Flags  -> ()
	 */
	float UItem::GetThrowSpeedMultiplierInWater()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetThrowSpeedMultiplierInWater");
		
		UItem_GetThrowSpeedMultiplierInWater_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetThrowSpeedMultiplier
	 * 		Flags  -> ()
	 */
	float UItem::GetThrowSpeedMultiplier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetThrowSpeedMultiplier");
		
		UItem_GetThrowSpeedMultiplier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetThrowAttackType
	 * 		Flags  -> ()
	 */
	EThrowAttackType UItem::GetThrowAttackType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetThrowAttackType");
		
		UItem_GetThrowAttackType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetThrowAttackDelay
	 * 		Flags  -> ()
	 */
	float UItem::GetThrowAttackDelay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetThrowAttackDelay");
		
		UItem_GetThrowAttackDelay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetTechTreeUnlocks
	 * 		Flags  -> ()
	 */
	TArray<struct FDataTableRowHandle> UItem::GetTechTreeUnlocks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetTechTreeUnlocks");
		
		UItem_GetTechTreeUnlocks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetSwimmingAttack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAttack* UItem::GetSwimmingAttack(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetSwimmingAttack");
		
		UItem_GetSwimmingAttack_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetStackSize
	 * 		Flags  -> ()
	 */
	int32_t UItem::GetStackSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetStackSize");
		
		UItem_GetStackSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetSpoilState
	 * 		Flags  -> ()
	 */
	ESpoilState UItem::GetSpoilState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetSpoilState");
		
		UItem_GetSpoilState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetSpoilProgress
	 * 		Flags  -> ()
	 */
	float UItem::GetSpoilProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetSpoilProgress");
		
		UItem_GetSpoilProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetSourceCreatureName
	 * 		Flags  -> ()
	 */
	class FString UItem::GetSourceCreatureName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetSourceCreatureName");
		
		UItem_GetSourceCreatureName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetSelectedAmmoType
	 * 		Flags  -> ()
	 */
	class FName UItem::GetSelectedAmmoType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetSelectedAmmoType");
		
		UItem_GetSelectedAmmoType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetResearchRecipeUnlocks
	 * 		Flags  -> ()
	 */
	TArray<struct FDataTableRowHandle> UItem::GetResearchRecipeUnlocks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetResearchRecipeUnlocks");
		
		UItem_GetResearchRecipeUnlocks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetRepairRequirements
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRecipeRequirements>                 OutRequirements                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UItem::GetRepairRequirements(TArray<struct FRecipeRequirements>* OutRequirements)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetRepairRequirements");
		
		UItem_GetRepairRequirements_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutRequirements != nullptr)
			*OutRequirements = params.OutRequirements;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetRemainingAmmo
	 * 		Flags  -> ()
	 */
	int32_t UItem::GetRemainingAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetRemainingAmmo");
		
		UItem_GetRemainingAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetRecipeUnlocks
	 * 		Flags  -> ()
	 */
	TArray<struct FDataTableRowHandle> UItem::GetRecipeUnlocks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetRecipeUnlocks");
		
		UItem_GetRecipeUnlocks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetProcessedResultItemCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                ProcessingType                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UItem::GetProcessedResultItemCount(const struct FGameplayTag& ProcessingType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetProcessedResultItemCount");
		
		UItem_GetProcessedResultItemCount_Params params {};
		params.ProcessingType = ProcessingType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetProcessedResultItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                ProcessingType                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle UItem::GetProcessedResultItem(const struct FGameplayTag& ProcessingType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetProcessedResultItem");
		
		UItem_GetProcessedResultItem_Params params {};
		params.ProcessingType = ProcessingType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetPowerReservoir
	 * 		Flags  -> ()
	 */
	struct FPowerReservoir UItem::GetPowerReservoir()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetPowerReservoir");
		
		UItem_GetPowerReservoir_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetPowerPercentage
	 * 		Flags  -> ()
	 */
	float UItem::GetPowerPercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetPowerPercentage");
		
		UItem_GetPowerPercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetPickupAudio
	 * 		Flags  -> ()
	 */
	class USoundCue* UItem::GetPickupAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetPickupAudio");
		
		UItem_GetPickupAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetNewResearchRecipeUnlocks
	 * 		Flags  -> ()
	 */
	TArray<struct FDataTableRowHandle> UItem::GetNewResearchRecipeUnlocks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetNewResearchRecipeUnlocks");
		
		UItem_GetNewResearchRecipeUnlocks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetMaxStackSize
	 * 		Flags  -> ()
	 */
	int32_t UItem::GetMaxStackSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetMaxStackSize");
		
		UItem_GetMaxStackSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetMaxHaulingAmount
	 * 		Flags  -> ()
	 */
	int32_t UItem::GetMaxHaulingAmount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetMaxHaulingAmount");
		
		UItem_GetMaxHaulingAmount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetMaxDurability
	 * 		Flags  -> ()
	 */
	float UItem::GetMaxDurability()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetMaxDurability");
		
		UItem_GetMaxDurability_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetLodItemVisuals
	 * 		Flags  -> ()
	 */
	class USpawnedItemLODActor* UItem::GetLodItemVisuals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetLodItemVisuals");
		
		UItem_GetLodItemVisuals_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetItemVisuals
	 * 		Flags  -> ()
	 */
	class ASpawnedItem* UItem::GetItemVisuals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetItemVisuals");
		
		UItem_GetItemVisuals_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetItemType
	 * 		Flags  -> ()
	 */
	EItemType UItem::GetItemType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetItemType");
		
		UItem_GetItemType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetItemRequiredForEnhancement
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UItem::GetItemRequiredForEnhancement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetItemRequiredForEnhancement");
		
		UItem_GetItemRequiredForEnhancement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetItemDataRowHandle
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UItem::GetItemDataRowHandle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetItemDataRowHandle");
		
		UItem_GetItemDataRowHandle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetItemData
	 * 		Flags  -> ()
	 */
	struct FBaseItemData UItem::GetItemData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetItemData");
		
		UItem_GetItemData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetItemCountRequiredForBonusEnhancement
	 * 		Flags  -> ()
	 */
	int32_t UItem::GetItemCountRequiredForBonusEnhancement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetItemCountRequiredForBonusEnhancement");
		
		UItem_GetItemCountRequiredForBonusEnhancement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetItemCountRequiredForBaseEnhancement
	 * 		Flags  -> ()
	 */
	int32_t UItem::GetItemCountRequiredForBaseEnhancement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetItemCountRequiredForBaseEnhancement");
		
		UItem_GetItemCountRequiredForBaseEnhancement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetIsPowerOn
	 * 		Flags  -> ()
	 */
	bool UItem::GetIsPowerOn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetIsPowerOn");
		
		UItem_GetIsPowerOn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetInventorySlot
	 * 		Flags  -> ()
	 */
	int32_t UItem::GetInventorySlot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetInventorySlot");
		
		UItem_GetInventorySlot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetImpactSoundRange
	 * 		Flags  -> ()
	 */
	float UItem::GetImpactSoundRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetImpactSoundRange");
		
		UItem_GetImpactSoundRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetImpactSoundIntensity
	 * 		Flags  -> ()
	 */
	float UItem::GetImpactSoundIntensity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetImpactSoundIntensity");
		
		UItem_GetImpactSoundIntensity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetImpactAttack
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UItem::GetImpactAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetImpactAttack");
		
		UItem_GetImpactAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetHUDMarkerType
	 * 		Flags  -> ()
	 */
	EHUDMarkerType UItem::GetHUDMarkerType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetHUDMarkerType");
		
		UItem_GetHUDMarkerType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetHatchProgress
	 * 		Flags  -> ()
	 */
	float UItem::GetHatchProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetHatchProgress");
		
		UItem_GetHatchProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetGlideTimeRemaining
	 * 		Flags  -> ()
	 */
	float UItem::GetGlideTimeRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetGlideTimeRemaining");
		
		UItem_GetGlideTimeRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetGardenModifierValue
	 * 		Flags  -> ()
	 */
	float UItem::GetGardenModifierValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetGardenModifierValue");
		
		UItem_GetGardenModifierValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetGardenModifierType
	 * 		Flags  -> ()
	 */
	EGardenModifierType UItem::GetGardenModifierType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetGardenModifierType");
		
		UItem_GetGardenModifierType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetEquippedOwner
	 * 		Flags  -> ()
	 */
	class AActor* UItem::GetEquippedOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetEquippedOwner");
		
		UItem_GetEquippedOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetEquipmentSlot
	 * 		Flags  -> ()
	 */
	EEquipmentSlot UItem::GetEquipmentSlot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetEquipmentSlot");
		
		UItem_GetEquipmentSlot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetEquipAudio
	 * 		Flags  -> ()
	 */
	class USoundCue* UItem::GetEquipAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetEquipAudio");
		
		UItem_GetEquipAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetEnhancementLevel
	 * 		Flags  -> ()
	 */
	int32_t UItem::GetEnhancementLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetEnhancementLevel");
		
		UItem_GetEnhancementLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetDurabilityRemaining
	 * 		Flags  -> ()
	 */
	float UItem::GetDurabilityRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetDurabilityRemaining");
		
		UItem_GetDurabilityRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetDurabilityRatio
	 * 		Flags  -> ()
	 */
	float UItem::GetDurabilityRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetDurabilityRatio");
		
		UItem_GetDurabilityRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetDurabilityModifier
	 * 		Flags  -> ()
	 */
	float UItem::GetDurabilityModifier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetDurabilityModifier");
		
		UItem_GetDurabilityModifier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetDisplayName
	 * 		Flags  -> ()
	 */
	class FString UItem::GetDisplayName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetDisplayName");
		
		UItem_GetDisplayName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetDescription
	 * 		Flags  -> ()
	 */
	struct FLocString UItem::GetDescription()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetDescription");
		
		UItem_GetDescription_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetDamageReductionValue
	 * 		Flags  -> ()
	 */
	float UItem::GetDamageReductionValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetDamageReductionValue");
		
		UItem_GetDamageReductionValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetConversationStartNode
	 * 		Flags  -> ()
	 */
	int32_t UItem::GetConversationStartNode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetConversationStartNode");
		
		UItem_GetConversationStartNode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetConversationID
	 * 		Flags  -> ()
	 */
	struct FGuid UItem::GetConversationID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetConversationID");
		
		UItem_GetConversationID_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetConsumeAudio
	 * 		Flags  -> ()
	 */
	class USoundCue* UItem::GetConsumeAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetConsumeAudio");
		
		UItem_GetConsumeAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetBonusEnhancementType
	 * 		Flags  -> ()
	 */
	struct FGameplayTag UItem::GetBonusEnhancementType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetBonusEnhancementType");
		
		UItem_GetBonusEnhancementType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetBonusEnhancementLevel
	 * 		Flags  -> ()
	 */
	int32_t UItem::GetBonusEnhancementLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetBonusEnhancementLevel");
		
		UItem_GetBonusEnhancementLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetBlockStaminaRegenMultiplier
	 * 		Flags  -> ()
	 */
	float UItem::GetBlockStaminaRegenMultiplier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetBlockStaminaRegenMultiplier");
		
		UItem_GetBlockStaminaRegenMultiplier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetBlockStaminaCost
	 * 		Flags  -> ()
	 */
	float UItem::GetBlockStaminaCost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetBlockStaminaCost");
		
		UItem_GetBlockStaminaCost_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetBlockDamageMultiplier
	 * 		Flags  -> ()
	 */
	float UItem::GetBlockDamageMultiplier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetBlockDamageMultiplier");
		
		UItem_GetBlockDamageMultiplier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetAvailableStackSize
	 * 		Flags  -> ()
	 */
	int32_t UItem::GetAvailableStackSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetAvailableStackSize");
		
		UItem_GetAvailableStackSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetAttackSpeedText
	 * 		Flags  -> ()
	 */
	class FString UItem::GetAttackSpeedText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetAttackSpeedText");
		
		UItem_GetAttackSpeedText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetAttackSpeedTag
	 * 		Flags  -> ()
	 */
	struct FGameplayTag UItem::GetAttackSpeedTag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetAttackSpeedTag");
		
		UItem_GetAttackSpeedTag_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetAttackDamageTypeModifier
	 * 		Flags  -> ()
	 */
	class UClass* UItem::GetAttackDamageTypeModifier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetAttackDamageTypeModifier");
		
		UItem_GetAttackDamageTypeModifier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetAttackDamageTypeFlags
	 * 		Flags  -> ()
	 */
	unsigned char UItem::GetAttackDamageTypeFlags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetAttackDamageTypeFlags");
		
		UItem_GetAttackDamageTypeFlags_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetAttackDamageModifier
	 * 		Flags  -> ()
	 */
	float UItem::GetAttackDamageModifier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetAttackDamageModifier");
		
		UItem_GetAttackDamageModifier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.GetAmmoTypes
	 * 		Flags  -> ()
	 */
	TArray<class FName> UItem::GetAmmoTypes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.GetAmmoTypes");
		
		UItem_GetAmmoTypes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.EnablePower
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bPowerEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItem::EnablePower(bool bPowerEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.EnablePower");
		
		UItem_EnablePower_Params params {};
		params.bPowerEnabled = bPowerEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.DumpPower
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Dumper                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItem::DumpPower(class AActor* Dumper)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.DumpPower");
		
		UItem_DumpPower_Params params {};
		params.Dumper = Dumper;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.DestroyOnThrowAttack
	 * 		Flags  -> ()
	 */
	bool UItem::DestroyOnThrowAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.DestroyOnThrowAttack");
		
		UItem_DestroyOnThrowAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.DecrementStackSize
	 * 		Flags  -> ()
	 */
	int32_t UItem::DecrementStackSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.DecrementStackSize");
		
		UItem_DecrementStackSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.ConsumesPowerDuringRest
	 * 		Flags  -> ()
	 */
	bool UItem::ConsumesPowerDuringRest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.ConsumesPowerDuringRest");
		
		UItem_ConsumesPowerDuringRest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.ConsumeCharge
	 * 		Flags  -> ()
	 */
	void UItem::ConsumeCharge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.ConsumeCharge");
		
		UItem_ConsumeCharge_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Instigator                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItem::CanUse(class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanUse");
		
		UItem_CanUse_Params params {};
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanThrowUnderWater
	 * 		Flags  -> ()
	 */
	bool UItem::CanThrowUnderWater()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanThrowUnderWater");
		
		UItem_CanThrowUnderWater_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanThrow
	 * 		Flags  -> ()
	 */
	bool UItem::CanThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanThrow");
		
		UItem_CanThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanStack
	 * 		Flags  -> ()
	 */
	bool UItem::CanStack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanStack");
		
		UItem_CanStack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanSpoil
	 * 		Flags  -> ()
	 */
	bool UItem::CanSpoil()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanSpoil");
		
		UItem_CanSpoil_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanRepairNow
	 * 		Flags  -> ()
	 */
	bool UItem::CanRepairNow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanRepairNow");
		
		UItem_CanRepairNow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanRepair
	 * 		Flags  -> ()
	 */
	bool UItem::CanRepair()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanRepair");
		
		UItem_CanRepair_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanProcess
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                ProcessingType                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItem::CanProcess(const struct FGameplayTag& ProcessingType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanProcess");
		
		UItem_CanProcess_Params params {};
		params.ProcessingType = ProcessingType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanPowerBeUsedInWater
	 * 		Flags  -> ()
	 */
	bool UItem::CanPowerBeUsedInWater()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanPowerBeUsedInWater");
		
		UItem_CanPowerBeUsedInWater_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanHatch
	 * 		Flags  -> ()
	 */
	bool UItem::CanHatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanHatch");
		
		UItem_CanHatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanGetBonusEnhancements
	 * 		Flags  -> ()
	 */
	bool UItem::CanGetBonusEnhancements()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanGetBonusEnhancements");
		
		UItem_CanGetBonusEnhancements_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanEverUse
	 * 		Flags  -> ()
	 */
	bool UItem::CanEverUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanEverUse");
		
		UItem_CanEverUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanEverEnhance
	 * 		Flags  -> ()
	 */
	bool UItem::CanEverEnhance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanEverEnhance");
		
		UItem_CanEverEnhance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanEverDumpPower
	 * 		Flags  -> ()
	 */
	bool UItem::CanEverDumpPower()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanEverDumpPower");
		
		UItem_CanEverDumpPower_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanEquipTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Character                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItem::CanEquipTo(class AActor* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanEquipTo");
		
		UItem_CanEquipTo_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanEquip
	 * 		Flags  -> ()
	 */
	bool UItem::CanEquip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanEquip");
		
		UItem_CanEquip_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanEnhance
	 * 		Flags  -> ()
	 */
	bool UItem::CanEnhance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanEnhance");
		
		UItem_CanEnhance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanDumpPower
	 * 		Flags  -> ()
	 */
	bool UItem::CanDumpPower()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanDumpPower");
		
		UItem_CanDumpPower_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanBlock
	 * 		Flags  -> ()
	 */
	bool UItem::CanBlock()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanBlock");
		
		UItem_CanBlock_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanAttack
	 * 		Flags  -> ()
	 */
	bool UItem::CanAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanAttack");
		
		UItem_CanAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanAnalyze
	 * 		Flags  -> ()
	 */
	bool UItem::CanAnalyze()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanAnalyze");
		
		UItem_CanAnalyze_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanAddPower
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                PowerType                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Charges                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItem::CanAddPower(const struct FGameplayTag& PowerType, float Charges)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanAddPower");
		
		UItem_CanAddPower_Params params {};
		params.PowerType = PowerType;
		params.Charges = Charges;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.CanAcceptPowerType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                PowerType                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItem::CanAcceptPowerType(const struct FGameplayTag& PowerType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.CanAcceptPowerType");
		
		UItem_CanAcceptPowerType_Params params {};
		params.PowerType = PowerType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.AppliesPositiveSurvivalStatOnConsume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStatusEffectType                                  StatusEffectType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IgnoreNegativeEffects                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItem::AppliesPositiveSurvivalStatOnConsume(EStatusEffectType StatusEffectType, bool IgnoreNegativeEffects)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.AppliesPositiveSurvivalStatOnConsume");
		
		UItem_AppliesPositiveSurvivalStatOnConsume_Params params {};
		params.StatusEffectType = StatusEffectType;
		params.IgnoreNegativeEffects = IgnoreNegativeEffects;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.AlwaysOn
	 * 		Flags  -> ()
	 */
	bool UItem::AlwaysOn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.AlwaysOn");
		
		UItem_AlwaysOn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.AdjustStackSize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            AmountToAdjustBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UItem::AdjustStackSize(int32_t AmountToAdjustBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.AdjustStackSize");
		
		UItem_AdjustStackSize_Params params {};
		params.AmountToAdjustBy = AmountToAdjustBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Item.AddCharges
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                PowerTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ChargesToAdd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItem::AddCharges(const struct FGameplayTag& PowerTag, float ChargesToAdd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Item.AddCharges");
		
		UItem_AddCharges_Params params {};
		params.PowerTag = PowerTag;
		params.ChargesToAdd = ChargesToAdd;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Item");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerFunctionLibrary.FindPartialItemStackForItemHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Container                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UItem* UItemContainerFunctionLibrary::FindPartialItemStackForItemHandle(class UObject* Container, const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerFunctionLibrary.FindPartialItemStackForItemHandle");
		
		UItemContainerFunctionLibrary_FindPartialItemStackForItemHandle_Params params {};
		params.Container = Container;
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerFunctionLibrary.FindPartialItemStackForItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Container                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UItemContainerFunctionLibrary::FindPartialItemStackForItem(class UObject* Container, class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerFunctionLibrary.FindPartialItemStackForItem");
		
		UItemContainerFunctionLibrary_FindPartialItemStackForItem_Params params {};
		params.Container = Container;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerFunctionLibrary.FindItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Container                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ItemData                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               SearchForwards                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UItemContainerFunctionLibrary::FindItem(class UObject* Container, const struct FDataTableRowHandle& ItemData, bool SearchForwards)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerFunctionLibrary.FindItem");
		
		UItemContainerFunctionLibrary_FindItem_Params params {};
		params.Container = Container;
		params.ItemData = ItemData;
		params.SearchForwards = SearchForwards;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerFunctionLibrary.CreateAndAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Container                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FAddItemResult UItemContainerFunctionLibrary::CreateAndAddItem(class UObject* Container, const struct FDataTableRowHandle& ItemRowHandle, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerFunctionLibrary.CreateAndAddItem");
		
		UItemContainerFunctionLibrary_CreateAndAddItem_Params params {};
		params.Container = Container;
		params.ItemRowHandle = ItemRowHandle;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemContainerFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemContainerFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ItemContainerFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerActorFunctionLibrary.RemoveItemMatchingItemData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ItemContainerActor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ItemData                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               SearchForwards                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemContainerActorFunctionLibrary::RemoveItemMatchingItemData(class AActor* ItemContainerActor, const struct FDataTableRowHandle& ItemData, bool SearchForwards)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerActorFunctionLibrary.RemoveItemMatchingItemData");
		
		UItemContainerActorFunctionLibrary_RemoveItemMatchingItemData_Params params {};
		params.ItemContainerActor = ItemContainerActor;
		params.ItemData = ItemData;
		params.SearchForwards = SearchForwards;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerActorFunctionLibrary.RemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ItemContainerActor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               SearchForwards                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemContainerActorFunctionLibrary::RemoveItem(class AActor* ItemContainerActor, class UItem* Item, bool SearchForwards)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerActorFunctionLibrary.RemoveItem");
		
		UItemContainerActorFunctionLibrary_RemoveItem_Params params {};
		params.ItemContainerActor = ItemContainerActor;
		params.Item = Item;
		params.SearchForwards = SearchForwards;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerActorFunctionLibrary.HasRequirements
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ItemContainerActor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FRecipeRequirements>                 Requirements                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UItemContainerActorFunctionLibrary::HasRequirements(class AActor* ItemContainerActor, TArray<struct FRecipeRequirements> Requirements)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerActorFunctionLibrary.HasRequirements");
		
		UItemContainerActorFunctionLibrary_HasRequirements_Params params {};
		params.ItemContainerActor = ItemContainerActor;
		params.Requirements = Requirements;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerActorFunctionLibrary.GetItemDataWithTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ItemContainerActor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ItemTag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FDataTableRowHandle> UItemContainerActorFunctionLibrary::GetItemDataWithTag(class AActor* ItemContainerActor, const struct FGameplayTag& ItemTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerActorFunctionLibrary.GetItemDataWithTag");
		
		UItemContainerActorFunctionLibrary_GetItemDataWithTag_Params params {};
		params.ItemContainerActor = ItemContainerActor;
		params.ItemTag = ItemTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerActorFunctionLibrary.GetItemCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ItemContainerActor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UItemContainerActorFunctionLibrary::GetItemCount(class AActor* ItemContainerActor, const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerActorFunctionLibrary.GetItemCount");
		
		UItemContainerActorFunctionLibrary_GetItemCount_Params params {};
		params.ItemContainerActor = ItemContainerActor;
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerActorFunctionLibrary.GetItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ItemContainerActor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UItem* UItemContainerActorFunctionLibrary::GetItem(class AActor* ItemContainerActor, const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerActorFunctionLibrary.GetItem");
		
		UItemContainerActorFunctionLibrary_GetItem_Params params {};
		params.ItemContainerActor = ItemContainerActor;
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerActorFunctionLibrary.GetAllItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ItemContainerActor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UItem*> UItemContainerActorFunctionLibrary::GetAllItems(class AActor* ItemContainerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerActorFunctionLibrary.GetAllItems");
		
		UItemContainerActorFunctionLibrary_GetAllItems_Params params {};
		params.ItemContainerActor = ItemContainerActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerActorFunctionLibrary.CraftRecipeForInventory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ItemContainerActor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UInventoryComponent*                         DestinationInventory                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemContainerActorFunctionLibrary::CraftRecipeForInventory(class AActor* ItemContainerActor, const struct FDataTableRowHandle& RecipeRowHandle, class UInventoryComponent* DestinationInventory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerActorFunctionLibrary.CraftRecipeForInventory");
		
		UItemContainerActorFunctionLibrary_CraftRecipeForInventory_Params params {};
		params.ItemContainerActor = ItemContainerActor;
		params.RecipeRowHandle = RecipeRowHandle;
		params.DestinationInventory = DestinationInventory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerActorFunctionLibrary.CanCraftRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ItemContainerActor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UItemContainerActorFunctionLibrary::CanCraftRecipe(class AActor* ItemContainerActor, const struct FDataTableRowHandle& RecipeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerActorFunctionLibrary.CanCraftRecipe");
		
		UItemContainerActorFunctionLibrary_CanCraftRecipe_Params params {};
		params.ItemContainerActor = ItemContainerActor;
		params.RecipeRowHandle = RecipeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemContainerActorFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemContainerActorFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ItemContainerActorFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerInterface.RemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UItemContainerInterface::RemoveItem(class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerInterface.RemoveItem");
		
		UItemContainerInterface_RemoveItem_Params params {};
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerInterface.HasItems
	 * 		Flags  -> ()
	 */
	bool UItemContainerInterface::HasItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerInterface.HasItems");
		
		UItemContainerInterface_HasItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerInterface.GetItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UItemContainerInterface::GetItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerInterface.GetItems");
		
		UItemContainerInterface_GetItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerInterface.GetDropItemTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform UItemContainerInterface::GetDropItemTransform(class UItem* Item, const struct FVector& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerInterface.GetDropItemTransform");
		
		UItemContainerInterface_GetDropItemTransform_Params params {};
		params.Item = Item;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerInterface.DropItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemContainerInterface::DropItem(class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerInterface.DropItem");
		
		UItemContainerInterface_DropItem_Params params {};
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerInterface.CanAddItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UItem*>                               Items                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UItemContainerInterface::CanAddItems(TArray<class UItem*> Items)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerInterface.CanAddItems");
		
		UItemContainerInterface_CanAddItems_Params params {};
		params.Items = Items;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerInterface.CanAddItemRowHandles
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 ItemRowHandles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UItemContainerInterface::CanAddItemRowHandles(TArray<struct FDataTableRowHandle> ItemRowHandles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerInterface.CanAddItemRowHandles");
		
		UItemContainerInterface_CanAddItemRowHandles_Params params {};
		params.ItemRowHandles = ItemRowHandles;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerInterface.CanAddItemRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UItemContainerInterface::CanAddItemRowHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerInterface.CanAddItemRowHandle");
		
		UItemContainerInterface_CanAddItemRowHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerInterface.CanAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItemContainerInterface::CanAddItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerInterface.CanAddItem");
		
		UItemContainerInterface_CanAddItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemContainerInterface.AddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNewItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemContainerInterface::AddItem(class UItem* Item, bool bIsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemContainerInterface.AddItem");
		
		UItemContainerInterface_AddItem_Params params {};
		params.Item = Item;
		params.bIsNewItem = bIsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemContainerInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemContainerInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ItemContainerInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemDataFunctionLibrary.IsRepairTool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBaseItemData                               ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UItemDataFunctionLibrary::IsRepairTool(const struct FBaseItemData& ItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemDataFunctionLibrary.IsRepairTool");
		
		UItemDataFunctionLibrary_IsRepairTool_Params params {};
		params.ItemData = ItemData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemDataFunctionLibrary.IsArmorSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItemDataFunctionLibrary::IsArmorSlot(EEquipmentSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemDataFunctionLibrary.IsArmorSlot");
		
		UItemDataFunctionLibrary_IsArmorSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemDataFunctionLibrary.GetItemDataFilterMatches
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBaseItemData                               ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      FilterText                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItemDataFunctionLibrary::GetItemDataFilterMatches(const struct FBaseItemData& ItemData, const class FString& FilterText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemDataFunctionLibrary.GetItemDataFilterMatches");
		
		UItemDataFunctionLibrary_GetItemDataFilterMatches_Params params {};
		params.ItemData = ItemData;
		params.FilterText = FilterText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemDataFunctionLibrary.GetItemDataEquippedActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBaseItemData                               ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Equipper                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemDataFunctionLibrary::GetItemDataEquippedActor(const struct FBaseItemData& ItemData, class AActor* Equipper)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemDataFunctionLibrary.GetItemDataEquippedActor");
		
		UItemDataFunctionLibrary_GetItemDataEquippedActor_Params params {};
		params.ItemData = ItemData;
		params.Equipper = Equipper;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemDataFunctionLibrary.GetEquippableStatusEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBaseItemData                               ItemData                                                   (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDataTableRowHandle>                 StatusEffects                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UItemDataFunctionLibrary::GetEquippableStatusEffects(struct FBaseItemData* ItemData, TArray<struct FDataTableRowHandle>* StatusEffects)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemDataFunctionLibrary.GetEquippableStatusEffects");
		
		UItemDataFunctionLibrary_GetEquippableStatusEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ItemData != nullptr)
			*ItemData = params.ItemData;
		if (StatusEffects != nullptr)
			*StatusEffects = params.StatusEffects;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemDataFunctionLibrary.GetConsumableStatusEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBaseItemData                               ItemData                                                   (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDataTableRowHandle>                 StatusEffects                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UItemDataFunctionLibrary::GetConsumableStatusEffects(struct FBaseItemData* ItemData, TArray<struct FDataTableRowHandle>* StatusEffects)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemDataFunctionLibrary.GetConsumableStatusEffects");
		
		UItemDataFunctionLibrary_GetConsumableStatusEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ItemData != nullptr)
			*ItemData = params.ItemData;
		if (StatusEffects != nullptr)
			*StatusEffects = params.StatusEffects;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemDataFunctionLibrary.GetAverageItemAttackHitStun
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBaseItemData                               ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	float UItemDataFunctionLibrary::GetAverageItemAttackHitStun(const struct FBaseItemData& ItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemDataFunctionLibrary.GetAverageItemAttackHitStun");
		
		UItemDataFunctionLibrary_GetAverageItemAttackHitStun_Params params {};
		params.ItemData = ItemData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemDataFunctionLibrary.GetAverageItemAttackDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBaseItemData                               ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	float UItemDataFunctionLibrary::GetAverageItemAttackDamage(const struct FBaseItemData& ItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemDataFunctionLibrary.GetAverageItemAttackDamage");
		
		UItemDataFunctionLibrary_GetAverageItemAttackDamage_Params params {};
		params.ItemData = ItemData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemDataFunctionLibrary.GetAttackStatusEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBaseItemData                               ItemData                                                   (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDataTableRowHandle>                 StatusEffects                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UItemDataFunctionLibrary::GetAttackStatusEffects(struct FBaseItemData* ItemData, TArray<struct FDataTableRowHandle>* StatusEffects)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemDataFunctionLibrary.GetAttackStatusEffects");
		
		UItemDataFunctionLibrary_GetAttackStatusEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ItemData != nullptr)
			*ItemData = params.ItemData;
		if (StatusEffects != nullptr)
			*StatusEffects = params.StatusEffects;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemDataFunctionLibrary.GetAttackData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBaseItemData                               ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle UItemDataFunctionLibrary::GetAttackData(const struct FBaseItemData& ItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemDataFunctionLibrary.GetAttackData");
		
		UItemDataFunctionLibrary_GetAttackData_Params params {};
		params.ItemData = ItemData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemDataFunctionLibrary.GetAllItemStatusEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBaseItemData                               ItemData                                                   (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDataTableRowHandle>                 StatusEffects                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UItemDataFunctionLibrary::GetAllItemStatusEffects(struct FBaseItemData* ItemData, TArray<struct FDataTableRowHandle>* StatusEffects)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemDataFunctionLibrary.GetAllItemStatusEffects");
		
		UItemDataFunctionLibrary_GetAllItemStatusEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ItemData != nullptr)
			*ItemData = params.ItemData;
		if (StatusEffects != nullptr)
			*StatusEffects = params.StatusEffects;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemDataFunctionLibrary.CanResearch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBaseItemData                               ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UItemDataFunctionLibrary::CanResearch(const struct FBaseItemData& ItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemDataFunctionLibrary.CanResearch");
		
		UItemDataFunctionLibrary_CanResearch_Params params {};
		params.ItemData = ItemData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemDataFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemDataFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ItemDataFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemManagerComponent.OnRest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              RestDuration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemManagerComponent::OnRest(float RestDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemManagerComponent.OnRest");
		
		UItemManagerComponent_OnRest_Params params {};
		params.RestDuration = RestDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ItemManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingDataFunctionLibrary.IsStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemProcessingData                         Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UItemProcessingDataFunctionLibrary::IsStarted(const struct FItemProcessingData& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingDataFunctionLibrary.IsStarted");
		
		UItemProcessingDataFunctionLibrary_IsStarted_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingDataFunctionLibrary.IsProcessingTimeFinished
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemProcessingData                         Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UItemProcessingDataFunctionLibrary::IsProcessingTimeFinished(const struct FItemProcessingData& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingDataFunctionLibrary.IsProcessingTimeFinished");
		
		UItemProcessingDataFunctionLibrary_IsProcessingTimeFinished_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingDataFunctionLibrary.GetTotalProcessingTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemProcessingData                         Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	float UItemProcessingDataFunctionLibrary::GetTotalProcessingTime(const struct FItemProcessingData& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingDataFunctionLibrary.GetTotalProcessingTime");
		
		UItemProcessingDataFunctionLibrary_GetTotalProcessingTime_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingDataFunctionLibrary.GetRemainingProcessingTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemProcessingData                         Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	float UItemProcessingDataFunctionLibrary::GetRemainingProcessingTime(const struct FItemProcessingData& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingDataFunctionLibrary.GetRemainingProcessingTime");
		
		UItemProcessingDataFunctionLibrary_GetRemainingProcessingTime_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingDataFunctionLibrary.GetProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemProcessingData                         Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	float UItemProcessingDataFunctionLibrary::GetProgress(const struct FItemProcessingData& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingDataFunctionLibrary.GetProgress");
		
		UItemProcessingDataFunctionLibrary_GetProgress_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingDataFunctionLibrary.GetProcessingType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemProcessingData                         Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	struct FGameplayTag UItemProcessingDataFunctionLibrary::GetProcessingType(const struct FItemProcessingData& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingDataFunctionLibrary.GetProcessingType");
		
		UItemProcessingDataFunctionLibrary_GetProcessingType_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingDataFunctionLibrary.GetProcessingState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemProcessingData                         Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	EItemProcessingState UItemProcessingDataFunctionLibrary::GetProcessingState(const struct FItemProcessingData& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingDataFunctionLibrary.GetProcessingState");
		
		UItemProcessingDataFunctionLibrary_GetProcessingState_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingDataFunctionLibrary.GetElapsedProcessingTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemProcessingData                         Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	float UItemProcessingDataFunctionLibrary::GetElapsedProcessingTime(const struct FItemProcessingData& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingDataFunctionLibrary.GetElapsedProcessingTime");
		
		UItemProcessingDataFunctionLibrary_GetElapsedProcessingTime_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingDataFunctionLibrary.CanProcess
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemProcessingData                         Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UItemProcessingDataFunctionLibrary::CanProcess(const struct FItemProcessingData& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingDataFunctionLibrary.CanProcess");
		
		UItemProcessingDataFunctionLibrary_CanProcess_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemProcessingDataFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemProcessingDataFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ItemProcessingDataFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.WillQueueProcessingItems
	 * 		Flags  -> ()
	 */
	bool AItemProcessingBuilding::WillQueueProcessingItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.WillQueueProcessingItems");
		
		AItemProcessingBuilding_WillQueueProcessingItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.TickVisuals
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemProcessingBuilding::TickVisuals(float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.TickVisuals");
		
		AItemProcessingBuilding_TickVisuals_Params params {};
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.TickProcessing
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemProcessingBuilding::TickProcessing(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.TickProcessing");
		
		AItemProcessingBuilding_TickProcessing_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.RemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InInstigator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemProcessingBuilding::RemoveItem(class UItem* Item, class AActor* InInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.RemoveItem");
		
		AItemProcessingBuilding_RemoveItem_Params params {};
		params.Item = Item;
		params.InInstigator = InInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.OnRep_ProcessingItemsChanged
	 * 		Flags  -> ()
	 */
	void AItemProcessingBuilding::OnRep_ProcessingItemsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.OnRep_ProcessingItemsChanged");
		
		AItemProcessingBuilding_OnRep_ProcessingItemsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.NotifyWorldItemTake
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemProcessingBuilding::NotifyWorldItemTake(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.NotifyWorldItemTake");
		
		AItemProcessingBuilding_NotifyWorldItemTake_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.NotifyProcessingStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                NewProcessingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CookingSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemProcessingBuilding::NotifyProcessingStateChanged(const struct FGameplayTag& NewProcessingType, int32_t CookingSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.NotifyProcessingStateChanged");
		
		AItemProcessingBuilding_NotifyProcessingStateChanged_Params params {};
		params.NewProcessingType = NewProcessingType;
		params.CookingSlot = CookingSlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.MulticastNotifyProcessingStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                NewProcessingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CookingSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemProcessingBuilding::MulticastNotifyProcessingStateChanged(const struct FGameplayTag& NewProcessingType, int32_t CookingSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.MulticastNotifyProcessingStateChanged");
		
		AItemProcessingBuilding_MulticastNotifyProcessingStateChanged_Params params {};
		params.NewProcessingType = NewProcessingType;
		params.CookingSlot = CookingSlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.IsProcessingAnything
	 * 		Flags  -> ()
	 */
	bool AItemProcessingBuilding::IsProcessingAnything()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.IsProcessingAnything");
		
		AItemProcessingBuilding_IsProcessingAnything_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.IsItemFinished
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AItemProcessingBuilding::IsItemFinished(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.IsItemFinished");
		
		AItemProcessingBuilding_IsItemFinished_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.IsFull
	 * 		Flags  -> ()
	 */
	bool AItemProcessingBuilding::IsFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.IsFull");
		
		AItemProcessingBuilding_IsFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.GetResultItemType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle AItemProcessingBuilding::GetResultItemType(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.GetResultItemType");
		
		AItemProcessingBuilding_GetResultItemType_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.GetProcessingType
	 * 		Flags  -> ()
	 */
	struct FGameplayTag AItemProcessingBuilding::GetProcessingType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.GetProcessingType");
		
		AItemProcessingBuilding_GetProcessingType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.GetProcessingState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EItemProcessingState AItemProcessingBuilding::GetProcessingState(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.GetProcessingState");
		
		AItemProcessingBuilding_GetProcessingState_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.GetProcessingSocketForItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FName AItemProcessingBuilding::GetProcessingSocketForItem(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.GetProcessingSocketForItem");
		
		AItemProcessingBuilding_GetProcessingSocketForItem_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.GetProcessingItems
	 * 		Flags  -> ()
	 */
	TArray<struct FItemProcessingData> AItemProcessingBuilding::GetProcessingItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.GetProcessingItems");
		
		AItemProcessingBuilding_GetProcessingItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.GetProcessingItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* AItemProcessingBuilding::GetProcessingItem(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.GetProcessingItem");
		
		AItemProcessingBuilding_GetProcessingItem_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.GetOutputSocketForItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FName AItemProcessingBuilding::GetOutputSocketForItem(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.GetOutputSocketForItem");
		
		AItemProcessingBuilding_GetOutputSocketForItem_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.GetItemProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AItemProcessingBuilding::GetItemProgress(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.GetItemProgress");
		
		AItemProcessingBuilding_GetItemProgress_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.GetCurrentProcessingItemIndex
	 * 		Flags  -> ()
	 */
	int32_t AItemProcessingBuilding::GetCurrentProcessingItemIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.GetCurrentProcessingItemIndex");
		
		AItemProcessingBuilding_GetCurrentProcessingItemIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.GetCurrentItemCount
	 * 		Flags  -> ()
	 */
	int32_t AItemProcessingBuilding::GetCurrentItemCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.GetCurrentItemCount");
		
		AItemProcessingBuilding_GetCurrentItemCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.GetComponentForSocket
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        SocketName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USceneComponent* AItemProcessingBuilding::GetComponentForSocket(const class FName& SocketName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.GetComponentForSocket");
		
		AItemProcessingBuilding_GetComponentForSocket_Params params {};
		params.SocketName = SocketName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.CanProcessItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AItemProcessingBuilding::CanProcessItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.CanProcessItem");
		
		AItemProcessingBuilding_CanProcessItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.CanAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AItemProcessingBuilding::CanAddItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.CanAddItem");
		
		AItemProcessingBuilding_CanAddItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemProcessingBuilding.AddItemToProcess
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalCharacter*                          InInstigator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SlotToUse                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemProcessingBuilding::AddItemToProcess(class UItem* Item, class ASurvivalCharacter* InInstigator, int32_t SlotToUse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemProcessingBuilding.AddItemToProcess");
		
		AItemProcessingBuilding_AddItemToProcess_Params params {};
		params.Item = Item;
		params.InInstigator = InInstigator;
		params.SlotToUse = SlotToUse;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemProcessingBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemProcessingBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ItemProcessingBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemSource.IsSourceForItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemType                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UItemSource::IsSourceForItem(const struct FDataTableRowHandle& ItemType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemSource.IsSourceForItem");
		
		UItemSource_IsSourceForItem_Params params {};
		params.ItemType = ItemType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemSource.GetItemSourceWorldLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemType                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FVector UItemSource::GetItemSourceWorldLocation(const struct FDataTableRowHandle& ItemType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemSource.GetItemSourceWorldLocation");
		
		UItemSource_GetItemSourceWorldLocation_Params params {};
		params.ItemType = ItemType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemSource.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemSource::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ItemSource");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemSpawnData.GetPossibleActors
	 * 		Flags  -> ()
	 */
	TArray<class UClass*> UItemSpawnData::GetPossibleActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemSpawnData.GetPossibleActors");
		
		UItemSpawnData_GetPossibleActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemSpawnData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemSpawnData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ItemSpawnData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemSpawnGroupData.HasGlobalVariableCondition
	 * 		Flags  -> ()
	 */
	bool UItemSpawnGroupData::HasGlobalVariableCondition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemSpawnGroupData.HasGlobalVariableCondition");
		
		UItemSpawnGroupData_HasGlobalVariableCondition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemSpawnGroupData.HasEventInterval
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESpawnIntervalBehavior                             Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItemSpawnGroupData::HasEventInterval(ESpawnIntervalBehavior Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemSpawnGroupData.HasEventInterval");
		
		UItemSpawnGroupData_HasEventInterval_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemSpawnGroupData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemSpawnGroupData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ItemSpawnGroupData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemSpawnManager.OnRep_ReplicatedSpawnData
	 * 		Flags  -> ()
	 */
	void AItemSpawnManager::OnRep_ReplicatedSpawnData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemSpawnManager.OnRep_ReplicatedSpawnData");
		
		AItemSpawnManager_OnRep_ReplicatedSpawnData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemSpawnManager.AddSpawnGroupHelper
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InOwner                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItemSpawnGroupData*                         Group                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FItemSpawnGroup                             SpawnGroup                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTrackedItemSpawnGroup* AItemSpawnManager::AddSpawnGroupHelper(class AActor* InOwner, class UItemSpawnGroupData* Group, const struct FItemSpawnGroup& SpawnGroup, bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemSpawnManager.AddSpawnGroupHelper");
		
		AItemSpawnManager_AddSpawnGroupHelper_Params params {};
		params.InOwner = InOwner;
		params.Group = Group;
		params.SpawnGroup = SpawnGroup;
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ItemSpawnManager.AddSpawnGroup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InOwner                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItemSpawnGroupData*                         Group                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTrackedItemSpawnGroup* AItemSpawnManager::AddSpawnGroup(class AActor* InOwner, class UItemSpawnGroupData* Group, bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ItemSpawnManager.AddSpawnGroup");
		
		AItemSpawnManager_AddSpawnGroup_Params params {};
		params.InOwner = InOwner;
		params.Group = Group;
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemSpawnManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemSpawnManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ItemSpawnManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemSpawnPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemSpawnPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ItemSpawnPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.KeybindingDisplay.UpdateText
	 * 		Flags  -> ()
	 */
	void UKeybindingDisplay::UpdateText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.KeybindingDisplay.UpdateText");
		
		UKeybindingDisplay_UpdateText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.KeybindingDisplay.UpdateControl
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAnyControlMapping                          Control                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UKeybindingDisplay::UpdateControl(const struct FAnyControlMapping& Control)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.KeybindingDisplay.UpdateControl");
		
		UKeybindingDisplay_UpdateControl_Params params {};
		params.Control = Control;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.KeybindingDisplay.UnsetKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNotify                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKeybindingDisplay::UnsetKey(bool bNotify)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.KeybindingDisplay.UnsetKey");
		
		UKeybindingDisplay_UnsetKey_Params params {};
		params.bNotify = bNotify;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.KeybindingDisplay.SetControl
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAnyControlMapping                          Control                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bInGamepadControls                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNotify                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKeybindingDisplay::SetControl(const struct FAnyControlMapping& Control, bool bInGamepadControls, bool bNotify)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.KeybindingDisplay.SetControl");
		
		UKeybindingDisplay_SetControl_Params params {};
		params.Control = Control;
		params.bInGamepadControls = bInGamepadControls;
		params.bNotify = bNotify;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.KeybindingDisplay.SetAxis
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputAxisKeyMapping                        Axis                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bInGamepadControls                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNotify                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKeybindingDisplay::SetAxis(const struct FInputAxisKeyMapping& Axis, bool bInGamepadControls, bool bNotify)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.KeybindingDisplay.SetAxis");
		
		UKeybindingDisplay_SetAxis_Params params {};
		params.Axis = Axis;
		params.bInGamepadControls = bInGamepadControls;
		params.bNotify = bNotify;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.KeybindingDisplay.SetAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputActionKeyMapping                      Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bInGamepadControls                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNotify                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKeybindingDisplay::SetAction(const struct FInputActionKeyMapping& Key, bool bInGamepadControls, bool bNotify)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.KeybindingDisplay.SetAction");
		
		UKeybindingDisplay_SetAction_Params params {};
		params.Key = Key;
		params.bInGamepadControls = bInGamepadControls;
		params.bNotify = bNotify;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKeybindingDisplay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKeybindingDisplay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.KeybindingDisplay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabeledDropdownWidget.OnSelectionChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SelectedItem                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESelectInfo                                        SelectionType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULabeledDropdownWidget::OnSelectionChanged(const class FString& SelectedItem, ESelectInfo SelectionType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabeledDropdownWidget.OnSelectionChanged");
		
		ULabeledDropdownWidget_OnSelectionChanged_Params params {};
		params.SelectedItem = SelectedItem;
		params.SelectionType = SelectionType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabeledDropdownWidget.InitManual
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            SelectedIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULabeledDropdownWidget::InitManual(int32_t SelectedIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabeledDropdownWidget.InitManual");
		
		ULabeledDropdownWidget_InitManual_Params params {};
		params.SelectedIndex = SelectedIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabeledDropdownWidget.Init
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FString>                              Options                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SelectedIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULabeledDropdownWidget::Init(TArray<class FString> Options, int32_t SelectedIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabeledDropdownWidget.Init");
		
		ULabeledDropdownWidget_Init_Params params {};
		params.Options = Options;
		params.SelectedIndex = SelectedIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULabeledDropdownWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULabeledDropdownWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LabeledDropdownWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabeledKeybinding.SetMappingKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAnyControlMappingKey                       Key                                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInGamepadControls                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULabeledKeybinding::SetMappingKey(const struct FAnyControlMappingKey& Key, bool bInGamepadControls)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabeledKeybinding.SetMappingKey");
		
		ULabeledKeybinding_SetMappingKey_Params params {};
		params.Key = Key;
		params.bInGamepadControls = bInGamepadControls;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabeledKeybinding.OnControlMapping1Changed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAnyControlMapping                          Mapping                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void ULabeledKeybinding::OnControlMapping1Changed(const struct FAnyControlMapping& Mapping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabeledKeybinding.OnControlMapping1Changed");
		
		ULabeledKeybinding_OnControlMapping1Changed_Params params {};
		params.Mapping = Mapping;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabeledKeybinding.OnControlMapping0Changed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAnyControlMapping                          Mapping                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void ULabeledKeybinding::OnControlMapping0Changed(const struct FAnyControlMapping& Mapping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabeledKeybinding.OnControlMapping0Changed");
		
		ULabeledKeybinding_OnControlMapping0Changed_Params params {};
		params.Mapping = Mapping;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabeledKeybinding.Init
	 * 		Flags  -> ()
	 */
	void ULabeledKeybinding::Init()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabeledKeybinding.Init");
		
		ULabeledKeybinding_Init_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULabeledKeybinding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULabeledKeybinding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LabeledKeybinding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabeledToggle.SetIsChecked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInIsChecked                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULabeledToggle::SetIsChecked(bool bInIsChecked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabeledToggle.SetIsChecked");
		
		ULabeledToggle_SetIsChecked_Params params {};
		params.bInIsChecked = bInIsChecked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabeledToggle.OnToggleStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsToggled                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULabeledToggle::OnToggleStateChanged(bool bIsToggled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabeledToggle.OnToggleStateChanged");
		
		ULabeledToggle_OnToggleStateChanged_Params params {};
		params.bIsToggled = bIsToggled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULabeledToggle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULabeledToggle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LabeledToggle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabledSliderWidget.ValueToNormalized
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ULabledSliderWidget::ValueToNormalized(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabledSliderWidget.ValueToNormalized");
		
		ULabledSliderWidget_ValueToNormalized_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabledSliderWidget.OnSliderValueChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ChangedValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULabledSliderWidget::OnSliderValueChanged(float ChangedValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabledSliderWidget.OnSliderValueChanged");
		
		ULabledSliderWidget_OnSliderValueChanged_Params params {};
		params.ChangedValue = ChangedValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabledSliderWidget.OnSliderMouseCaptureEnd
	 * 		Flags  -> ()
	 */
	void ULabledSliderWidget::OnSliderMouseCaptureEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabledSliderWidget.OnSliderMouseCaptureEnd");
		
		ULabledSliderWidget_OnSliderMouseCaptureEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabledSliderWidget.NormalizedToValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Normalized                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ULabledSliderWidget::NormalizedToValue(float Normalized)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabledSliderWidget.NormalizedToValue");
		
		ULabledSliderWidget_NormalizedToValue_Params params {};
		params.Normalized = Normalized;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULabledSliderWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULabledSliderWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LabledSliderWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabMachineBase.GetInfo
	 * 		Flags  -> ()
	 */
	struct FLabMachineBlueprintableInfo ALabMachineBase::GetInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabMachineBase.GetInfo");
		
		ALabMachineBase_GetInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALabMachineBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALabMachineBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LabMachineBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALabMachineA.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALabMachineA::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LabMachineA");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabMachineFullBase.SetupMeshesOnReplacementActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ALabMachineBase*                             NewActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ALabMachineFullBase::SetupMeshesOnReplacementActor(class ALabMachineBase* NewActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabMachineFullBase.SetupMeshesOnReplacementActor");
		
		ALabMachineFullBase_SetupMeshesOnReplacementActor_Params params {};
		params.NewActor = NewActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabMachineFullBase.SetLabMachineInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLabMachineBlueprintableInfo                InInfo                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ALabMachineFullBase::SetLabMachineInfo(const struct FLabMachineBlueprintableInfo& InInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabMachineFullBase.SetLabMachineInfo");
		
		ALabMachineFullBase_SetLabMachineInfo_Params params {};
		params.InInfo = InInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LabMachineFullBase.GetLabMachineInfo
	 * 		Flags  -> ()
	 */
	struct FLabMachineBlueprintableInfo ALabMachineFullBase::GetLabMachineInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LabMachineFullBase.GetLabMachineInfo");
		
		ALabMachineFullBase_GetLabMachineInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALabMachineFullBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALabMachineFullBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LabMachineFullBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LadderBuilding.OnRep_CombinedSpline
	 * 		Flags  -> ()
	 */
	void ALadderBuilding::OnRep_CombinedSpline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LadderBuilding.OnRep_CombinedSpline");
		
		ALadderBuilding_OnRep_CombinedSpline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALadderBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALadderBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LadderBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LandscapeRTManager.HasAnyActors
	 * 		Flags  -> ()
	 */
	bool ALandscapeRTManager::HasAnyActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LandscapeRTManager.HasAnyActors");
		
		ALandscapeRTManager_HasAnyActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALandscapeRTManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALandscapeRTManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LandscapeRTManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LatencyWidget.OnPingChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Ping                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULatencyWidget::OnPingChanged(int32_t Ping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LatencyWidget.OnPingChanged");
		
		ULatencyWidget_OnPingChanged_Params params {};
		params.Ping = Ping;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULatencyWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULatencyWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LatencyWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULiteBuildingGridObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULiteBuildingGridObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LiteBuildingGridObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LocalizedTextBlock.SetLocalizedString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLocString                                  LocString                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULocalizedTextBlock::SetLocalizedString(const struct FLocString& LocString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LocalizedTextBlock.SetLocalizedString");
		
		ULocalizedTextBlock_SetLocalizedString_Params params {};
		params.LocString = LocString;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULocalizedTextBlock.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULocalizedTextBlock::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LocalizedTextBlock");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODableActorInterface.TransferBlueprintInstanceDataToProxy
	 * 		Flags  -> ()
	 */
	void ULODableActorInterface::TransferBlueprintInstanceDataToProxy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODableActorInterface.TransferBlueprintInstanceDataToProxy");
		
		ULODableActorInterface_TransferBlueprintInstanceDataToProxy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODableActorInterface.ShowLODActorDebug
	 * 		Flags  -> ()
	 */
	bool ULODableActorInterface::ShowLODActorDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODableActorInterface.ShowLODActorDebug");
		
		ULODableActorInterface_ShowLODActorDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODableActorInterface.ShouldRestoreTransform
	 * 		Flags  -> ()
	 */
	bool ULODableActorInterface::ShouldRestoreTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODableActorInterface.ShouldRestoreTransform");
		
		ULODableActorInterface_ShouldRestoreTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODableActorInterface.RestoreBlueprintInstanceDataToFullActor
	 * 		Flags  -> ()
	 */
	void ULODableActorInterface::RestoreBlueprintInstanceDataToFullActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODableActorInterface.RestoreBlueprintInstanceDataToFullActor");
		
		ULODableActorInterface_RestoreBlueprintInstanceDataToFullActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODableActorInterface.HasBlueprintInstanceData
	 * 		Flags  -> ()
	 */
	bool ULODableActorInterface::HasBlueprintInstanceData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODableActorInterface.HasBlueprintInstanceData");
		
		ULODableActorInterface_HasBlueprintInstanceData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODableActorInterface.GetLODActorClass
	 * 		Flags  -> ()
	 */
	class UClass* ULODableActorInterface::GetLODActorClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODableActorInterface.GetLODActorClass");
		
		ULODableActorInterface_GetLODActorClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODableActorInterface.GetLifetimeDespawnWhenProxyOnly
	 * 		Flags  -> ()
	 */
	bool ULODableActorInterface::GetLifetimeDespawnWhenProxyOnly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODableActorInterface.GetLifetimeDespawnWhenProxyOnly");
		
		ULODableActorInterface_GetLifetimeDespawnWhenProxyOnly_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODableActorInterface.GetGameLifetimeHours
	 * 		Flags  -> ()
	 */
	float ULODableActorInterface::GetGameLifetimeHours()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODableActorInterface.GetGameLifetimeHours");
		
		ULODableActorInterface_GetGameLifetimeHours_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODableActorInterface.CanActorProxy
	 * 		Flags  -> ()
	 */
	bool ULODableActorInterface::CanActorProxy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODableActorInterface.CanActorProxy");
		
		ULODableActorInterface_CanActorProxy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULODableActorInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULODableActorInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LODableActorInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODableComponentInterface.GetLODComponentClass
	 * 		Flags  -> ()
	 */
	class UClass* ULODableComponentInterface::GetLODComponentClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODableComponentInterface.GetLODComponentClass");
		
		ULODableComponentInterface_GetLODComponentClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULODableComponentInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULODableComponentInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LODableComponentInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.OnLODActorDestroyed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               LODActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULODActorManagerComponent::OnLODActorDestroyed(class UBaseLODActor* LODActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.OnLODActorDestroyed");
		
		ULODActorManagerComponent_OnLODActorDestroyed_Params params {};
		params.LODActor = LODActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.GetTrackedActorClassTree
	 * 		Flags  -> ()
	 */
	struct FClassTreeNode ULODActorManagerComponent::GetTrackedActorClassTree()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.GetTrackedActorClassTree");
		
		ULODActorManagerComponent_GetTrackedActorClassTree_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.GetLODActorsOfExactlyLODActorClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UBaseLODActor*> ULODActorManagerComponent::GetLODActorsOfExactlyLODActorClass(class UClass* Class)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.GetLODActorsOfExactlyLODActorClass");
		
		ULODActorManagerComponent_GetLODActorsOfExactlyLODActorClass_Params params {};
		params.Class = Class;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.GetLODActorsOfExactlyClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UBaseLODActor*> ULODActorManagerComponent::GetLODActorsOfExactlyClass(class UClass* Class)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.GetLODActorsOfExactlyClass");
		
		ULODActorManagerComponent_GetLODActorsOfExactlyClass_Params params {};
		params.Class = Class;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.GetLODActorsImplementingLODActorClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UBaseLODActor*> ULODActorManagerComponent::GetLODActorsImplementingLODActorClass(class UClass* Class)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.GetLODActorsImplementingLODActorClass");
		
		ULODActorManagerComponent_GetLODActorsImplementingLODActorClass_Params params {};
		params.Class = Class;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.GetLODActorsImplementingClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UBaseLODActor*> ULODActorManagerComponent::GetLODActorsImplementingClass(class UClass* Class)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.GetLODActorsImplementingClass");
		
		ULODActorManagerComponent_GetLODActorsImplementingClass_Params params {};
		params.Class = Class;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.GetAllTrackedLODActorClasses
	 * 		Flags  -> ()
	 */
	TArray<class UClass*> ULODActorManagerComponent::GetAllTrackedLODActorClasses()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.GetAllTrackedLODActorClasses");
		
		ULODActorManagerComponent_GetAllTrackedLODActorClasses_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.GetAllTrackedActorClasses
	 * 		Flags  -> ()
	 */
	TArray<class UClass*> ULODActorManagerComponent::GetAllTrackedActorClasses()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.GetAllTrackedActorClasses");
		
		ULODActorManagerComponent_GetAllTrackedActorClasses_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.GetAllLODActors
	 * 		Flags  -> ()
	 */
	TArray<class UBaseLODActor*> ULODActorManagerComponent::GetAllLODActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.GetAllLODActors");
		
		ULODActorManagerComponent_GetAllLODActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.FinishSpawningLODActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               LODActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULODActorManagerComponent::FinishSpawningLODActor(class UBaseLODActor* LODActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.FinishSpawningLODActor");
		
		ULODActorManagerComponent_FinishSpawningLODActor_Params params {};
		params.LODActor = LODActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.FindLODComponentForComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UActorComponent*                             Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseLODComponent* ULODActorManagerComponent::FindLODComponentForComponent(class UActorComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.FindLODComponentForComponent");
		
		ULODActorManagerComponent_FindLODComponentForComponent_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.FindLODActorForComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UActorComponent*                             Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* ULODActorManagerComponent::FindLODActorForComponent(class UActorComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.FindLODActorForComponent");
		
		ULODActorManagerComponent_FindLODActorForComponent_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.FindLODActorForActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* ULODActorManagerComponent::FindLODActorForActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.FindLODActorForActor");
		
		ULODActorManagerComponent_FindLODActorForActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.FindLODActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       Guid                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* ULODActorManagerComponent::FindLODActor(const struct FGuid& Guid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.FindLODActor");
		
		ULODActorManagerComponent_FindLODActor_Params params {};
		params.Guid = Guid;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.CreateLODActorOfTypeDeferred
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ActorClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Transform                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* ULODActorManagerComponent::CreateLODActorOfTypeDeferred(class UClass* ActorClass, const struct FTransform& Transform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.CreateLODActorOfTypeDeferred");
		
		ULODActorManagerComponent_CreateLODActorOfTypeDeferred_Params params {};
		params.ActorClass = ActorClass;
		params.Transform = Transform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorManagerComponent.CreateLODActorOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ActorClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Transform                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* ULODActorManagerComponent::CreateLODActorOfType(class UClass* ActorClass, const struct FTransform& Transform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorManagerComponent.CreateLODActorOfType");
		
		ULODActorManagerComponent_CreateLODActorOfType_Params params {};
		params.ActorClass = ActorClass;
		params.Transform = Transform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULODActorManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULODActorManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LODActorManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorStatics.LODActorSaveBlueprintVectorArray
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FVector>                             inArray                                                    (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void ULODActorStatics::LODActorSaveBlueprintVectorArray(TArray<struct FVector> inArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorStatics.LODActorSaveBlueprintVectorArray");
		
		ULODActorStatics_LODActorSaveBlueprintVectorArray_Params params {};
		params.inArray = inArray;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorStatics.LODActorSaveBlueprintVector
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     InVector                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULODActorStatics::LODActorSaveBlueprintVector(const struct FVector& InVector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorStatics.LODActorSaveBlueprintVector");
		
		ULODActorStatics_LODActorSaveBlueprintVector_Params params {};
		params.InVector = InVector;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorStatics.LODActorSaveBlueprintInt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            inInt                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULODActorStatics::LODActorSaveBlueprintInt(int32_t inInt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorStatics.LODActorSaveBlueprintInt");
		
		ULODActorStatics_LODActorSaveBlueprintInt_Params params {};
		params.inInt = inInt;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorStatics.LODActorSaveBlueprintFloat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InFloat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULODActorStatics::LODActorSaveBlueprintFloat(float InFloat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorStatics.LODActorSaveBlueprintFloat");
		
		ULODActorStatics_LODActorSaveBlueprintFloat_Params params {};
		params.InFloat = InFloat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorStatics.LODActorSaveBlueprintBool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULODActorStatics::LODActorSaveBlueprintBool(bool InBool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorStatics.LODActorSaveBlueprintBool");
		
		ULODActorStatics_LODActorSaveBlueprintBool_Params params {};
		params.InBool = InBool;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorStatics.LODActorRestoreBlueprintVectorArray
	 * 		Flags  -> ()
	 */
	TArray<struct FVector> ULODActorStatics::LODActorRestoreBlueprintVectorArray()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorStatics.LODActorRestoreBlueprintVectorArray");
		
		ULODActorStatics_LODActorRestoreBlueprintVectorArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorStatics.LODActorRestoreBlueprintVector
	 * 		Flags  -> ()
	 */
	struct FVector ULODActorStatics::LODActorRestoreBlueprintVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorStatics.LODActorRestoreBlueprintVector");
		
		ULODActorStatics_LODActorRestoreBlueprintVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorStatics.LODActorRestoreBlueprintInt
	 * 		Flags  -> ()
	 */
	int32_t ULODActorStatics::LODActorRestoreBlueprintInt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorStatics.LODActorRestoreBlueprintInt");
		
		ULODActorStatics_LODActorRestoreBlueprintInt_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorStatics.LODActorRestoreBlueprintFloat
	 * 		Flags  -> ()
	 */
	float ULODActorStatics::LODActorRestoreBlueprintFloat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorStatics.LODActorRestoreBlueprintFloat");
		
		ULODActorStatics_LODActorRestoreBlueprintFloat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LODActorStatics.LODActorRestoreBlueprintBool
	 * 		Flags  -> ()
	 */
	bool ULODActorStatics::LODActorRestoreBlueprintBool()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LODActorStatics.LODActorRestoreBlueprintBool");
		
		ULODActorStatics_LODActorRestoreBlueprintBool_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULODActorStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULODActorStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LODActorStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LookTriggerComponent.OnGlobalVariableChangedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       GlobalVariableID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            VariableValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULookTriggerComponent::OnGlobalVariableChangedEvent(const struct FGuid& GlobalVariableID, int32_t VariableValue, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LookTriggerComponent.OnGlobalVariableChangedEvent");
		
		ULookTriggerComponent_OnGlobalVariableChangedEvent_Params params {};
		params.GlobalVariableID = GlobalVariableID;
		params.VariableValue = VariableValue;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULookTriggerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULookTriggerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LookTriggerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LootableInterface.CheckLootConditionals
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemDataRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool ULootableInterface::CheckLootConditionals(const struct FDataTableRowHandle& ItemDataRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LootableInterface.CheckLootConditionals");
		
		ULootableInterface_CheckLootConditionals_Params params {};
		params.ItemDataRowHandle = ItemDataRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULootableInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULootableInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LootableInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LootBag.TickBuoyancy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ALootBag::TickBuoyancy(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LootBag.TickBuoyancy");
		
		ALootBag_TickBuoyancy_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LootBag.ResyncReplicationTransform
	 * 		Flags  -> ()
	 */
	void ALootBag::ResyncReplicationTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LootBag.ResyncReplicationTransform");
		
		ALootBag_ResyncReplicationTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LootBag.GetShouldShowHUDMarker
	 * 		Flags  -> ()
	 */
	bool ALootBag::GetShouldShowHUDMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LootBag.GetShouldShowHUDMarker");
		
		ALootBag_GetShouldShowHUDMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALootBag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALootBag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LootBag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LootComponent.StartCacheSpawnPointVelocities
	 * 		Flags  -> ()
	 */
	void ULootComponent::StartCacheSpawnPointVelocities()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LootComponent.StartCacheSpawnPointVelocities");
		
		ULootComponent_StartCacheSpawnPointVelocities_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LootComponent.SetSpawnPointForItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             SpawnPoint                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ItemIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULootComponent::SetSpawnPointForItem(class USceneComponent* SpawnPoint, int32_t ItemIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LootComponent.SetSpawnPointForItem");
		
		ULootComponent_SetSpawnPointForItem_Params params {};
		params.SpawnPoint = SpawnPoint;
		params.ItemIndex = ItemIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LootComponent.SetAllDropChanceMultipliers
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULootComponent::SetAllDropChanceMultipliers(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LootComponent.SetAllDropChanceMultipliers");
		
		ULootComponent_SetAllDropChanceMultipliers_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LootComponent.ServerSpawnLoot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Looter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ELootSpawnType                                     SpawnType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULootComponent::ServerSpawnLoot(class AActor* Looter, ELootSpawnType SpawnType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LootComponent.ServerSpawnLoot");
		
		ULootComponent_ServerSpawnLoot_Params params {};
		params.Looter = Looter;
		params.SpawnType = SpawnType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LootComponent.OnDeath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ULootComponent::OnDeath(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LootComponent.OnDeath");
		
		ULootComponent_OnDeath_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LootComponent.OnDamaged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsKillingBlow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULootComponent::OnDamaged(float Damage, const struct FDamageInfo& DamageInfo, class AController* InstigatedBy, class UBaseLODActor* DamageCauser, bool IsKillingBlow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LootComponent.OnDamaged");
		
		ULootComponent_OnDamaged_Params params {};
		params.Damage = Damage;
		params.DamageInfo = DamageInfo;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		params.IsKillingBlow = IsKillingBlow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.LootComponent.AllocateGOAPActions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USurvivalGameInstance*                       GameInstance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InOwner                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UGoapAction*> ULootComponent::AllocateGOAPActions(class USurvivalGameInstance* GameInstance, class UObject* InOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.LootComponent.AllocateGOAPActions");
		
		ULootComponent_AllocateGOAPActions_Params params {};
		params.GameInstance = GameInstance;
		params.InOwner = InOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULootComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULootComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LootComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyLootComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyLootComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyLootComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULootLODComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULootLODComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.LootLODComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineAIPerceptionComponent.OnActivityModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalAIController*                       Sender                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECreatureActivityMode                              ActivityMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineAIPerceptionComponent::OnActivityModeChanged(class ASurvivalAIController* Sender, ECreatureActivityMode ActivityMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineAIPerceptionComponent.OnActivityModeChanged");
		
		UMaineAIPerceptionComponent_OnActivityModeChanged_Params params {};
		params.Sender = Sender;
		params.ActivityMode = ActivityMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaineAIPerceptionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaineAIPerceptionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineAIPerceptionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaineAISystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaineAISystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineAISystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaineAnalyticsManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaineAnalyticsManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineAnalyticsManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.Unperch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDetachSplineReason                                Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineCharMovementComponent::Unperch(EDetachSplineReason Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.Unperch");
		
		UMaineCharMovementComponent_Unperch_Params params {};
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.ToggleSprint
	 * 		Flags  -> ()
	 */
	bool UMaineCharMovementComponent::ToggleSprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.ToggleSprint");
		
		UMaineCharMovementComponent_ToggleSprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.ToggleGlide
	 * 		Flags  -> ()
	 */
	bool UMaineCharMovementComponent::ToggleGlide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.ToggleGlide");
		
		UMaineCharMovementComponent_ToggleGlide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.ToggleAutorun
	 * 		Flags  -> ()
	 */
	bool UMaineCharMovementComponent::ToggleAutorun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.ToggleAutorun");
		
		UMaineCharMovementComponent_ToggleAutorun_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.SetStandingInWater
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInWater                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineCharMovementComponent::SetStandingInWater(bool bInWater)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.SetStandingInWater");
		
		UMaineCharMovementComponent_SetStandingInWater_Params params {};
		params.bInWater = bInWater;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.SetIsSitting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSitting                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineCharMovementComponent::SetIsSitting(bool bSitting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.SetIsSitting");
		
		UMaineCharMovementComponent_SetIsSitting_Params params {};
		params.bSitting = bSitting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.SetAutorun
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineCharMovementComponent::SetAutorun(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.SetAutorun");
		
		UMaineCharMovementComponent_SetAutorun_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.Perch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAttractionComponentKey                     Target                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UMaineCharMovementComponent::Perch(const struct FAttractionComponentKey& Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.Perch");
		
		UMaineCharMovementComponent_Perch_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.OnFoliageDamaged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Sender                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UMaineCharMovementComponent::OnFoliageDamaged(class AActor* Sender, float Damage, const struct FDamageEvent& DamageEvent, const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.OnFoliageDamaged");
		
		UMaineCharMovementComponent_OnFoliageDamaged_Params params {};
		params.Sender = Sender;
		params.Damage = Damage;
		params.DamageEvent = DamageEvent;
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.IsZiplining
	 * 		Flags  -> ()
	 */
	bool UMaineCharMovementComponent::IsZiplining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.IsZiplining");
		
		UMaineCharMovementComponent_IsZiplining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.IsUnderwater
	 * 		Flags  -> ()
	 */
	bool UMaineCharMovementComponent::IsUnderwater()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.IsUnderwater");
		
		UMaineCharMovementComponent_IsUnderwater_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.IsStandingInWater
	 * 		Flags  -> ()
	 */
	bool UMaineCharMovementComponent::IsStandingInWater()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.IsStandingInWater");
		
		UMaineCharMovementComponent_IsStandingInWater_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.IsSprinting
	 * 		Flags  -> ()
	 */
	bool UMaineCharMovementComponent::IsSprinting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.IsSprinting");
		
		UMaineCharMovementComponent_IsSprinting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.IsSitting
	 * 		Flags  -> ()
	 */
	bool UMaineCharMovementComponent::IsSitting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.IsSitting");
		
		UMaineCharMovementComponent_IsSitting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.IsPerched
	 * 		Flags  -> ()
	 */
	bool UMaineCharMovementComponent::IsPerched()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.IsPerched");
		
		UMaineCharMovementComponent_IsPerched_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.IsGliding
	 * 		Flags  -> ()
	 */
	bool UMaineCharMovementComponent::IsGliding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.IsGliding");
		
		UMaineCharMovementComponent_IsGliding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.IsClimbing
	 * 		Flags  -> ()
	 */
	bool UMaineCharMovementComponent::IsClimbing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.IsClimbing");
		
		UMaineCharMovementComponent_IsClimbing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.IsAutorunning
	 * 		Flags  -> ()
	 */
	bool UMaineCharMovementComponent::IsAutorunning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.IsAutorunning");
		
		UMaineCharMovementComponent_IsAutorunning_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.GetZiplineReattachTime
	 * 		Flags  -> ()
	 */
	float UMaineCharMovementComponent::GetZiplineReattachTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.GetZiplineReattachTime");
		
		UMaineCharMovementComponent_GetZiplineReattachTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.GetZiplinePosition
	 * 		Flags  -> ()
	 */
	float UMaineCharMovementComponent::GetZiplinePosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.GetZiplinePosition");
		
		UMaineCharMovementComponent_GetZiplinePosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.GetPreviousZiplineChangeTime
	 * 		Flags  -> ()
	 */
	float UMaineCharMovementComponent::GetPreviousZiplineChangeTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.GetPreviousZiplineChangeTime");
		
		UMaineCharMovementComponent_GetPreviousZiplineChangeTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.GetPreviousZipline
	 * 		Flags  -> ()
	 */
	class AZiplineLine* UMaineCharMovementComponent::GetPreviousZipline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.GetPreviousZipline");
		
		UMaineCharMovementComponent_GetPreviousZipline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.GetMotionEater
	 * 		Flags  -> ()
	 */
	class UCharacterMotionEaterComponent* UMaineCharMovementComponent::GetMotionEater()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.GetMotionEater");
		
		UMaineCharMovementComponent_GetMotionEater_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.GetMaxGroundSpeed
	 * 		Flags  -> ()
	 */
	float UMaineCharMovementComponent::GetMaxGroundSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.GetMaxGroundSpeed");
		
		UMaineCharMovementComponent_GetMaxGroundSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.GetGlidingStyle
	 * 		Flags  -> ()
	 */
	EGlidingStyle UMaineCharMovementComponent::GetGlidingStyle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.GetGlidingStyle");
		
		UMaineCharMovementComponent_GetGlidingStyle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.GetCameraDisplayMode
	 * 		Flags  -> ()
	 */
	ECameraDisplayMode UMaineCharMovementComponent::GetCameraDisplayMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.GetCameraDisplayMode");
		
		UMaineCharMovementComponent_GetCameraDisplayMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.GetAttachedZipline
	 * 		Flags  -> ()
	 */
	class AZiplineLine* UMaineCharMovementComponent::GetAttachedZipline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.GetAttachedZipline");
		
		UMaineCharMovementComponent_GetAttachedZipline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineCharMovementComponent.DetachFromSpline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDetachSplineReason                                Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineCharMovementComponent::DetachFromSpline(EDetachSplineReason Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineCharMovementComponent.DetachFromSpline");
		
		UMaineCharMovementComponent_DetachFromSpline_Params params {};
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaineCharMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaineCharMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineCharMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMaineFreeCamPhotoPawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMaineFreeCamPhotoPawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineFreeCamPhotoPawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMaineGameModeBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMaineGameModeBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineGameModeBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetYAxisInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetYAxisInverted(bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetYAxisInverted");
		
		UMaineGameUserSettings_SetYAxisInverted_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetXAxisInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetXAxisInverted(bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetXAxisInverted");
		
		UMaineGameUserSettings_SetXAxisInverted_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetVSyncWrapper
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetVSyncWrapper(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetVSyncWrapper");
		
		UMaineGameUserSettings_SetVSyncWrapper_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetVoiceSoundVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetVoiceSoundVolume(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetVoiceSoundVolume");
		
		UMaineGameUserSettings_SetVoiceSoundVolume_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetVoiceChatSoundVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetVoiceChatSoundVolume(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetVoiceChatSoundVolume");
		
		UMaineGameUserSettings_SetVoiceChatSoundVolume_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetVoiceChatActivation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EVoiceChatActivation                               Quality                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetVoiceChatActivation(EVoiceChatActivation Quality)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetVoiceChatActivation");
		
		UMaineGameUserSettings_SetVoiceChatActivation_Params params {};
		params.Quality = Quality;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetUISoundVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetUISoundVolume(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetUISoundVolume");
		
		UMaineGameUserSettings_SetUISoundVolume_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetSubtitleSize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESubtitleSizeSettings                              Setting                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetSubtitleSize(ESubtitleSizeSettings Setting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetSubtitleSize");
		
		UMaineGameUserSettings_SetSubtitleSize_Params params {};
		params.Setting = Setting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetSubtitleMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESubtitleVerbositySettings                         Setting                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetSubtitleMode(ESubtitleVerbositySettings Setting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetSubtitleMode");
		
		UMaineGameUserSettings_SetSubtitleMode_Params params {};
		params.Setting = Setting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetSubtitleBackground
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Setting                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetSubtitleBackground(bool Setting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetSubtitleBackground");
		
		UMaineGameUserSettings_SetSubtitleBackground_Params params {};
		params.Setting = Setting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetShowTutorial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               NewShowTutorial                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetShowTutorial(bool NewShowTutorial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetShowTutorial");
		
		UMaineGameUserSettings_SetShowTutorial_Params params {};
		params.NewShowTutorial = NewShowTutorial;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetReadToMeSpeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Setting                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetReadToMeSpeed(float Setting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetReadToMeSpeed");
		
		UMaineGameUserSettings_SetReadToMeSpeed_Params params {};
		params.Setting = Setting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetReadToMe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Setting                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetReadToMe(bool Setting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetReadToMe");
		
		UMaineGameUserSettings_SetReadToMe_Params params {};
		params.Setting = Setting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetQualitySettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScalabilitySettings                               Quality                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetQualitySettings(EScalabilitySettings Quality)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetQualitySettings");
		
		UMaineGameUserSettings_SetQualitySettings_Params params {};
		params.Quality = Quality;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetPartyDistance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Setting                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetPartyDistance(bool Setting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetPartyDistance");
		
		UMaineGameUserSettings_SetPartyDistance_Params params {};
		params.Setting = Setting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetNarrationSoundVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetNarrationSoundVolume(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetNarrationSoundVolume");
		
		UMaineGameUserSettings_SetNarrationSoundVolume_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetMusicSoundVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetMusicSoundVolume(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetMusicSoundVolume");
		
		UMaineGameUserSettings_SetMusicSoundVolume_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetMouseToggleSprintEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetMouseToggleSprintEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetMouseToggleSprintEnabled");
		
		UMaineGameUserSettings_SetMouseToggleSprintEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetMouseToggleCrouchEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetMouseToggleCrouchEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetMouseToggleCrouchEnabled");
		
		UMaineGameUserSettings_SetMouseToggleCrouchEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetMouseSensitivityY
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetMouseSensitivityY(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetMouseSensitivityY");
		
		UMaineGameUserSettings_SetMouseSensitivityY_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetMouseSensitivityX
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetMouseSensitivityX(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetMouseSensitivityX");
		
		UMaineGameUserSettings_SetMouseSensitivityX_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetMotionBlurScale
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewMotionBlurScale                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetMotionBlurScale(float NewMotionBlurScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetMotionBlurScale");
		
		UMaineGameUserSettings_SetMotionBlurScale_Params params {};
		params.NewMotionBlurScale = NewMotionBlurScale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetMasterSoundVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetMasterSoundVolume(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetMasterSoundVolume");
		
		UMaineGameUserSettings_SetMasterSoundVolume_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetLargeText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Setting                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetLargeText(bool Setting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetLargeText");
		
		UMaineGameUserSettings_SetLargeText_Params params {};
		params.Setting = Setting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetLanguage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELanguageSetting                                   NewLanguage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetLanguage(ELanguageSetting NewLanguage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetLanguage");
		
		UMaineGameUserSettings_SetLanguage_Params params {};
		params.NewLanguage = NewLanguage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetKeyboardLevelViewOnSprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetKeyboardLevelViewOnSprint(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetKeyboardLevelViewOnSprint");
		
		UMaineGameUserSettings_SetKeyboardLevelViewOnSprint_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetInteractHighlightLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractHighlightLevel                            NewInteractHighlightLevel                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetInteractHighlightLevel(EInteractHighlightLevel NewInteractHighlightLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetInteractHighlightLevel");
		
		UMaineGameUserSettings_SetInteractHighlightLevel_Params params {};
		params.NewInteractHighlightLevel = NewInteractHighlightLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetHDRUIContrast
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Contrast                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetHDRUIContrast(float Contrast)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetHDRUIContrast");
		
		UMaineGameUserSettings_SetHDRUIContrast_Params params {};
		params.Contrast = Contrast;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetHDRUIBrightness
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Brightness                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetHDRUIBrightness(float Brightness)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetHDRUIBrightness");
		
		UMaineGameUserSettings_SetHDRUIBrightness_Params params {};
		params.Brightness = Brightness;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetHDRMaxBrightness
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              MaxBrightness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetHDRMaxBrightness(float MaxBrightness)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetHDRMaxBrightness");
		
		UMaineGameUserSettings_SetHDRMaxBrightness_Params params {};
		params.MaxBrightness = MaxBrightness;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetHDRContrast
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Contrast                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetHDRContrast(float Contrast)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetHDRContrast");
		
		UMaineGameUserSettings_SetHDRContrast_Params params {};
		params.Contrast = Contrast;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetHasSeenEarlyAccessMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetHasSeenEarlyAccessMessage(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetHasSeenEarlyAccessMessage");
		
		UMaineGameUserSettings_SetHasSeenEarlyAccessMessage_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetHasSeenArachnophobiaMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetHasSeenArachnophobiaMessage(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetHasSeenArachnophobiaMessage");
		
		UMaineGameUserSettings_SetHasSeenArachnophobiaMessage_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetHasSeenAccessibilityMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetHasSeenAccessibilityMessage(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetHasSeenAccessibilityMessage");
		
		UMaineGameUserSettings_SetHasSeenAccessibilityMessage_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetGammaLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              GammaLevelIn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetGammaLevel(float GammaLevelIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetGammaLevel");
		
		UMaineGameUserSettings_SetGammaLevel_Params params {};
		params.GammaLevelIn = GammaLevelIn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetFSRQuality
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Quality                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetFSRQuality(int32_t Quality)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetFSRQuality");
		
		UMaineGameUserSettings_SetFSRQuality_Params params {};
		params.Quality = Quality;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetFPSLimit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EFPSLimit                                          FPSLimitIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetFPSLimit(EFPSLimit FPSLimitIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetFPSLimit");
		
		UMaineGameUserSettings_SetFPSLimit_Params params {};
		params.FPSLimitIn = FPSLimitIn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetFOV
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              FOVIn                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetFOV(float FOVIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetFOV");
		
		UMaineGameUserSettings_SetFOV_Params params {};
		params.FOVIn = FOVIn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetExtraWideInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               NewExtraWideInteract                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetExtraWideInteract(bool NewExtraWideInteract)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetExtraWideInteract");
		
		UMaineGameUserSettings_SetExtraWideInteract_Params params {};
		params.NewExtraWideInteract = NewExtraWideInteract;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetEffectsSoundVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetEffectsSoundVolume(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetEffectsSoundVolume");
		
		UMaineGameUserSettings_SetEffectsSoundVolume_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetControllerToggleSprintEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetControllerToggleSprintEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetControllerToggleSprintEnabled");
		
		UMaineGameUserSettings_SetControllerToggleSprintEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetControllerToggleCrouchEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetControllerToggleCrouchEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetControllerToggleCrouchEnabled");
		
		UMaineGameUserSettings_SetControllerToggleCrouchEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetControllerSensitivityY
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetControllerSensitivityY(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetControllerSensitivityY");
		
		UMaineGameUserSettings_SetControllerSensitivityY_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetControllerSensitivityX
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetControllerSensitivityX(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetControllerSensitivityX");
		
		UMaineGameUserSettings_SetControllerSensitivityX_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetControllerRumbleEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetControllerRumbleEnabled(bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetControllerRumbleEnabled");
		
		UMaineGameUserSettings_SetControllerRumbleEnabled_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetControllerRightOuterDeadZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetControllerRightOuterDeadZone(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetControllerRightOuterDeadZone");
		
		UMaineGameUserSettings_SetControllerRightOuterDeadZone_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetControllerRightInnerDeadZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetControllerRightInnerDeadZone(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetControllerRightInnerDeadZone");
		
		UMaineGameUserSettings_SetControllerRightInnerDeadZone_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetControllerMoveYInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetControllerMoveYInverted(bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetControllerMoveYInverted");
		
		UMaineGameUserSettings_SetControllerMoveYInverted_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetControllerMoveXInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetControllerMoveXInverted(bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetControllerMoveXInverted");
		
		UMaineGameUserSettings_SetControllerMoveXInverted_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetControllerLookYInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetControllerLookYInverted(bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetControllerLookYInverted");
		
		UMaineGameUserSettings_SetControllerLookYInverted_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetControllerLookXInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetControllerLookXInverted(bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetControllerLookXInverted");
		
		UMaineGameUserSettings_SetControllerLookXInverted_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetControllerLevelViewOnSprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetControllerLevelViewOnSprint(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetControllerLevelViewOnSprint");
		
		UMaineGameUserSettings_SetControllerLevelViewOnSprint_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetControllerLeftOuterDeadZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetControllerLeftOuterDeadZone(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetControllerLeftOuterDeadZone");
		
		UMaineGameUserSettings_SetControllerLeftOuterDeadZone_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetControllerLeftInnerDeadZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetControllerLeftInnerDeadZone(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetControllerLeftInnerDeadZone");
		
		UMaineGameUserSettings_SetControllerLeftInnerDeadZone_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetColorblindMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EColorBlindModeSettings                            Setting                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetColorblindMode(EColorBlindModeSettings Setting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetColorblindMode");
		
		UMaineGameUserSettings_SetColorblindMode_Params params {};
		params.Setting = Setting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetChromaticAberration
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               NewChromaticAberration                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetChromaticAberration(bool NewChromaticAberration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetChromaticAberration");
		
		UMaineGameUserSettings_SetChromaticAberration_Params params {};
		params.NewChromaticAberration = NewChromaticAberration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetChatTextToSpeech
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Setting                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetChatTextToSpeech(bool Setting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetChatTextToSpeech");
		
		UMaineGameUserSettings_SetChatTextToSpeech_Params params {};
		params.Setting = Setting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetChatSpeechToText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Setting                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetChatSpeechToText(bool Setting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetChatSpeechToText");
		
		UMaineGameUserSettings_SetChatSpeechToText_Params params {};
		params.Setting = Setting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetChatBackground
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Setting                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetChatBackground(bool Setting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetChatBackground");
		
		UMaineGameUserSettings_SetChatBackground_Params params {};
		params.Setting = Setting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetAxisKeyBinds
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FInputAxisKeyMapping>                OldValues                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		TArray<struct FInputAxisKeyMapping>                NewValues                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetAxisKeyBinds(TArray<struct FInputAxisKeyMapping> OldValues, TArray<struct FInputAxisKeyMapping> NewValues)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetAxisKeyBinds");
		
		UMaineGameUserSettings_SetAxisKeyBinds_Params params {};
		params.OldValues = OldValues;
		params.NewValues = NewValues;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetAutosavesNumber
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewAutosavesNumber                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetAutosavesNumber(float NewAutosavesNumber)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetAutosavesNumber");
		
		UMaineGameUserSettings_SetAutosavesNumber_Params params {};
		params.NewAutosavesNumber = NewAutosavesNumber;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetAutosaveInterval
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewAutosaveInterval                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetAutosaveInterval(float NewAutosaveInterval)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetAutosaveInterval");
		
		UMaineGameUserSettings_SetAutosaveInterval_Params params {};
		params.NewAutosaveInterval = NewAutosaveInterval;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetArachnophobiaSafeMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Setting                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetArachnophobiaSafeMode(float Setting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetArachnophobiaSafeMode");
		
		UMaineGameUserSettings_SetArachnophobiaSafeMode_Params params {};
		params.Setting = Setting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetAmbienceSoundVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetAmbienceSoundVolume(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetAmbienceSoundVolume");
		
		UMaineGameUserSettings_SetAmbienceSoundVolume_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.SetActionKeyBinds
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FInputActionKeyMapping>              OldValues                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		TArray<struct FInputActionKeyMapping>              NewValues                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::SetActionKeyBinds(TArray<struct FInputActionKeyMapping> OldValues, TArray<struct FInputActionKeyMapping> NewValues)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.SetActionKeyBinds");
		
		UMaineGameUserSettings_SetActionKeyBinds_Params params {};
		params.OldValues = OldValues;
		params.NewValues = NewValues;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.Set3DResolution
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ResolutionIn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::Set3DResolution(float ResolutionIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.Set3DResolution");
		
		UMaineGameUserSettings_Set3DResolution_Params params {};
		params.ResolutionIn = ResolutionIn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.ResetAllKeyBinds
	 * 		Flags  -> ()
	 */
	void UMaineGameUserSettings::ResetAllKeyBinds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.ResetAllKeyBinds");
		
		UMaineGameUserSettings_ResetAllKeyBinds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.RemoveMappings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FAnyControlMapping>                  Bindings                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::RemoveMappings(TArray<struct FAnyControlMapping> Bindings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.RemoveMappings");
		
		UMaineGameUserSettings_RemoveMappings_Params params {};
		params.Bindings = Bindings;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.RemoveActionMappings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FInputActionKeyMapping>              Bindings                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UMaineGameUserSettings::RemoveActionMappings(TArray<struct FInputActionKeyMapping> Bindings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.RemoveActionMappings");
		
		UMaineGameUserSettings_RemoveActionMappings_Params params {};
		params.Bindings = Bindings;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetYAxisInverted
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetYAxisInverted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetYAxisInverted");
		
		UMaineGameUserSettings_GetYAxisInverted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetXAxisInverted
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetXAxisInverted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetXAxisInverted");
		
		UMaineGameUserSettings_GetXAxisInverted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetVSyncWrapper
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetVSyncWrapper()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetVSyncWrapper");
		
		UMaineGameUserSettings_GetVSyncWrapper_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetVoiceSoundVolume
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetVoiceSoundVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetVoiceSoundVolume");
		
		UMaineGameUserSettings_GetVoiceSoundVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetVoiceChatSoundVolume
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetVoiceChatSoundVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetVoiceChatSoundVolume");
		
		UMaineGameUserSettings_GetVoiceChatSoundVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetVoiceChatActivation
	 * 		Flags  -> ()
	 */
	EVoiceChatActivation UMaineGameUserSettings::GetVoiceChatActivation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetVoiceChatActivation");
		
		UMaineGameUserSettings_GetVoiceChatActivation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetUISoundVolume
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetUISoundVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetUISoundVolume");
		
		UMaineGameUserSettings_GetUISoundVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetSubtitleSize
	 * 		Flags  -> ()
	 */
	ESubtitleSizeSettings UMaineGameUserSettings::GetSubtitleSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetSubtitleSize");
		
		UMaineGameUserSettings_GetSubtitleSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetSubtitleMode
	 * 		Flags  -> ()
	 */
	ESubtitleVerbositySettings UMaineGameUserSettings::GetSubtitleMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetSubtitleMode");
		
		UMaineGameUserSettings_GetSubtitleMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetSubtitleBackground
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetSubtitleBackground()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetSubtitleBackground");
		
		UMaineGameUserSettings_GetSubtitleBackground_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetShowTutorial
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetShowTutorial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetShowTutorial");
		
		UMaineGameUserSettings_GetShowTutorial_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetReadToMeSpeed
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetReadToMeSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetReadToMeSpeed");
		
		UMaineGameUserSettings_GetReadToMeSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetReadToMe
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetReadToMe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetReadToMe");
		
		UMaineGameUserSettings_GetReadToMe_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetQualitySettings
	 * 		Flags  -> ()
	 */
	EScalabilitySettings UMaineGameUserSettings::GetQualitySettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetQualitySettings");
		
		UMaineGameUserSettings_GetQualitySettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetPartyDistance
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetPartyDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetPartyDistance");
		
		UMaineGameUserSettings_GetPartyDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetNarrationSoundVolume
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetNarrationSoundVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetNarrationSoundVolume");
		
		UMaineGameUserSettings_GetNarrationSoundVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetMusicSoundVolume
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetMusicSoundVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetMusicSoundVolume");
		
		UMaineGameUserSettings_GetMusicSoundVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetMouseToggleSprintEnabled
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetMouseToggleSprintEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetMouseToggleSprintEnabled");
		
		UMaineGameUserSettings_GetMouseToggleSprintEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetMouseToggleCrouchEnabled
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetMouseToggleCrouchEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetMouseToggleCrouchEnabled");
		
		UMaineGameUserSettings_GetMouseToggleCrouchEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetMouseSensitivityY
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetMouseSensitivityY()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetMouseSensitivityY");
		
		UMaineGameUserSettings_GetMouseSensitivityY_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetMouseSensitivityX
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetMouseSensitivityX()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetMouseSensitivityX");
		
		UMaineGameUserSettings_GetMouseSensitivityX_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetMotionBlurScale
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetMotionBlurScale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetMotionBlurScale");
		
		UMaineGameUserSettings_GetMotionBlurScale_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetMasterSoundVolume
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetMasterSoundVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetMasterSoundVolume");
		
		UMaineGameUserSettings_GetMasterSoundVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetLargeText
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetLargeText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetLargeText");
		
		UMaineGameUserSettings_GetLargeText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetLanguage
	 * 		Flags  -> ()
	 */
	ELanguageSetting UMaineGameUserSettings::GetLanguage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetLanguage");
		
		UMaineGameUserSettings_GetLanguage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetKeyboardLevelViewOnSprint
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetKeyboardLevelViewOnSprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetKeyboardLevelViewOnSprint");
		
		UMaineGameUserSettings_GetKeyboardLevelViewOnSprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetInteractHighlightLevel
	 * 		Flags  -> ()
	 */
	EInteractHighlightLevel UMaineGameUserSettings::GetInteractHighlightLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetInteractHighlightLevel");
		
		UMaineGameUserSettings_GetInteractHighlightLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetHDRUIContrast
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetHDRUIContrast()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetHDRUIContrast");
		
		UMaineGameUserSettings_GetHDRUIContrast_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetHDRUIBrightness
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetHDRUIBrightness()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetHDRUIBrightness");
		
		UMaineGameUserSettings_GetHDRUIBrightness_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetHDRMaxBrightness
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetHDRMaxBrightness()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetHDRMaxBrightness");
		
		UMaineGameUserSettings_GetHDRMaxBrightness_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetHDRContrast
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetHDRContrast()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetHDRContrast");
		
		UMaineGameUserSettings_GetHDRContrast_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetHasSeenEarlyAccessMessage
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetHasSeenEarlyAccessMessage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetHasSeenEarlyAccessMessage");
		
		UMaineGameUserSettings_GetHasSeenEarlyAccessMessage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetHasSeenArachnophobiaMessage
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetHasSeenArachnophobiaMessage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetHasSeenArachnophobiaMessage");
		
		UMaineGameUserSettings_GetHasSeenArachnophobiaMessage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetHasSeenAccessibilityMessage
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetHasSeenAccessibilityMessage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetHasSeenAccessibilityMessage");
		
		UMaineGameUserSettings_GetHasSeenAccessibilityMessage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetGammaLevel
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetGammaLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetGammaLevel");
		
		UMaineGameUserSettings_GetGammaLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetFSRQuality
	 * 		Flags  -> ()
	 */
	int32_t UMaineGameUserSettings::GetFSRQuality()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetFSRQuality");
		
		UMaineGameUserSettings_GetFSRQuality_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetFPSLimit
	 * 		Flags  -> ()
	 */
	EFPSLimit UMaineGameUserSettings::GetFPSLimit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetFPSLimit");
		
		UMaineGameUserSettings_GetFPSLimit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetFOV
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetFOV()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetFOV");
		
		UMaineGameUserSettings_GetFOV_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetExtraWideInteract
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetExtraWideInteract()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetExtraWideInteract");
		
		UMaineGameUserSettings_GetExtraWideInteract_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetEffectsSoundVolume
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetEffectsSoundVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetEffectsSoundVolume");
		
		UMaineGameUserSettings_GetEffectsSoundVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetControllerToggleSprintEnabled
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetControllerToggleSprintEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetControllerToggleSprintEnabled");
		
		UMaineGameUserSettings_GetControllerToggleSprintEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetControllerToggleCrouchEnabled
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetControllerToggleCrouchEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetControllerToggleCrouchEnabled");
		
		UMaineGameUserSettings_GetControllerToggleCrouchEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetControllerSensitivityY
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetControllerSensitivityY()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetControllerSensitivityY");
		
		UMaineGameUserSettings_GetControllerSensitivityY_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetControllerSensitivityX
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetControllerSensitivityX()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetControllerSensitivityX");
		
		UMaineGameUserSettings_GetControllerSensitivityX_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetControllerRumbleEnabled
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetControllerRumbleEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetControllerRumbleEnabled");
		
		UMaineGameUserSettings_GetControllerRumbleEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetControllerRightOuterDeadZone
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetControllerRightOuterDeadZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetControllerRightOuterDeadZone");
		
		UMaineGameUserSettings_GetControllerRightOuterDeadZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetControllerRightInnerDeadZone
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetControllerRightInnerDeadZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetControllerRightInnerDeadZone");
		
		UMaineGameUserSettings_GetControllerRightInnerDeadZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetControllerMoveYInverted
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetControllerMoveYInverted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetControllerMoveYInverted");
		
		UMaineGameUserSettings_GetControllerMoveYInverted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetControllerMoveXInverted
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetControllerMoveXInverted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetControllerMoveXInverted");
		
		UMaineGameUserSettings_GetControllerMoveXInverted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetControllerLookYInverted
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetControllerLookYInverted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetControllerLookYInverted");
		
		UMaineGameUserSettings_GetControllerLookYInverted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetControllerLookXInverted
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetControllerLookXInverted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetControllerLookXInverted");
		
		UMaineGameUserSettings_GetControllerLookXInverted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetControllerLevelViewOnSprint
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetControllerLevelViewOnSprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetControllerLevelViewOnSprint");
		
		UMaineGameUserSettings_GetControllerLevelViewOnSprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetControllerLeftOuterDeadZone
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetControllerLeftOuterDeadZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetControllerLeftOuterDeadZone");
		
		UMaineGameUserSettings_GetControllerLeftOuterDeadZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetControllerLeftInnerDeadZone
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetControllerLeftInnerDeadZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetControllerLeftInnerDeadZone");
		
		UMaineGameUserSettings_GetControllerLeftInnerDeadZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetColorblindModeEnabled
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetColorblindModeEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetColorblindModeEnabled");
		
		UMaineGameUserSettings_GetColorblindModeEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetColorblindMode
	 * 		Flags  -> ()
	 */
	EColorBlindModeSettings UMaineGameUserSettings::GetColorblindMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetColorblindMode");
		
		UMaineGameUserSettings_GetColorblindMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetChromaticAberration
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetChromaticAberration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetChromaticAberration");
		
		UMaineGameUserSettings_GetChromaticAberration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetChatTextToSpeech
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetChatTextToSpeech()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetChatTextToSpeech");
		
		UMaineGameUserSettings_GetChatTextToSpeech_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetChatSpeechToText
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetChatSpeechToText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetChatSpeechToText");
		
		UMaineGameUserSettings_GetChatSpeechToText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetChatBackground
	 * 		Flags  -> ()
	 */
	bool UMaineGameUserSettings::GetChatBackground()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetChatBackground");
		
		UMaineGameUserSettings_GetChatBackground_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetAxisKeyBinds
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        AxisName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPositive                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FInputAxisKeyMapping> UMaineGameUserSettings::GetAxisKeyBinds(const class FName& AxisName, bool bPositive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetAxisKeyBinds");
		
		UMaineGameUserSettings_GetAxisKeyBinds_Params params {};
		params.AxisName = AxisName;
		params.bPositive = bPositive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetAutosavesNumber
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetAutosavesNumber()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetAutosavesNumber");
		
		UMaineGameUserSettings_GetAutosavesNumber_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetAutosaveInterval
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetAutosaveInterval()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetAutosaveInterval");
		
		UMaineGameUserSettings_GetAutosaveInterval_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetArachnophobiaSafeMode
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetArachnophobiaSafeMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetArachnophobiaSafeMode");
		
		UMaineGameUserSettings_GetArachnophobiaSafeMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetAmbienceSoundVolume
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::GetAmbienceSoundVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetAmbienceSoundVolume");
		
		UMaineGameUserSettings_GetAmbienceSoundVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetAllKeyBinds
	 * 		Flags  -> ()
	 */
	TArray<struct FInputActionKeyMapping> UMaineGameUserSettings::GetAllKeyBinds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetAllKeyBinds");
		
		UMaineGameUserSettings_GetAllKeyBinds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetAllAxisMappings
	 * 		Flags  -> ()
	 */
	TArray<struct FInputAxisKeyMapping> UMaineGameUserSettings::GetAllAxisMappings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetAllAxisMappings");
		
		UMaineGameUserSettings_GetAllAxisMappings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetActionKeyboardKeyBinds
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ActionName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FInputActionKeyMapping> UMaineGameUserSettings::GetActionKeyboardKeyBinds(const class FName& ActionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetActionKeyboardKeyBinds");
		
		UMaineGameUserSettings_GetActionKeyboardKeyBinds_Params params {};
		params.ActionName = ActionName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetActionKeyBinds
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ActionName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FInputActionKeyMapping> UMaineGameUserSettings::GetActionKeyBinds(const class FName& ActionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetActionKeyBinds");
		
		UMaineGameUserSettings_GetActionKeyBinds_Params params {};
		params.ActionName = ActionName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.GetActionGamepadKeyBinds
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ActionName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FInputActionKeyMapping> UMaineGameUserSettings::GetActionGamepadKeyBinds(const class FName& ActionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.GetActionGamepadKeyBinds");
		
		UMaineGameUserSettings_GetActionGamepadKeyBinds_Params params {};
		params.ActionName = ActionName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineGameUserSettings.Get3DResolution
	 * 		Flags  -> ()
	 */
	float UMaineGameUserSettings::Get3DResolution()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineGameUserSettings.Get3DResolution");
		
		UMaineGameUserSettings_Get3DResolution_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaineGameUserSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaineGameUserSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineGameUserSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMainePathFollowingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMainePathFollowingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MainePathFollowingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainePhotoModeComponent.UIEnterPhotoMode
	 * 		Flags  -> ()
	 */
	void UMainePhotoModeComponent::UIEnterPhotoMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainePhotoModeComponent.UIEnterPhotoMode");
		
		UMainePhotoModeComponent_UIEnterPhotoMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainePhotoModeComponent.ServerUIEnterPhotoMode
	 * 		Flags  -> ()
	 */
	void UMainePhotoModeComponent::ServerUIEnterPhotoMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainePhotoModeComponent.ServerUIEnterPhotoMode");
		
		UMainePhotoModeComponent_ServerUIEnterPhotoMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainePhotoModeComponent.ServerNotifyPhotoTaken
	 * 		Flags  -> ()
	 */
	void UMainePhotoModeComponent::ServerNotifyPhotoTaken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainePhotoModeComponent.ServerNotifyPhotoTaken");
		
		UMainePhotoModeComponent_ServerNotifyPhotoTaken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainePhotoModeComponent.ClientUIEnterPhotoMode
	 * 		Flags  -> ()
	 */
	void UMainePhotoModeComponent::ClientUIEnterPhotoMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainePhotoModeComponent.ClientUIEnterPhotoMode");
		
		UMainePhotoModeComponent_ClientUIEnterPhotoMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainePhotoModeComponent.ClientOnPlayerInMenuChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               InPlayerInMenu                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainePhotoModeComponent::ClientOnPlayerInMenuChanged(bool InPlayerInMenu)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainePhotoModeComponent.ClientOnPlayerInMenuChanged");
		
		UMainePhotoModeComponent_ClientOnPlayerInMenuChanged_Params params {};
		params.InPlayerInMenu = InPlayerInMenu;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainePhotoModeComponent.ClientAddNotificationMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainePhotoModeComponent::ClientAddNotificationMessage(const class FString& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainePhotoModeComponent.ClientAddNotificationMessage");
		
		UMainePhotoModeComponent_ClientAddNotificationMessage_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMainePhotoModeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMainePhotoModeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MainePhotoModeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainePhotoModeSettingInput.SetPhotoModeTimeOfDay
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainePhotoModeSettingInput::SetPhotoModeTimeOfDay(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainePhotoModeSettingInput.SetPhotoModeTimeOfDay");
		
		UMainePhotoModeSettingInput_SetPhotoModeTimeOfDay_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainePhotoModeSettingInput.SetAzimuthOffset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainePhotoModeSettingInput::SetAzimuthOffset(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainePhotoModeSettingInput.SetAzimuthOffset");
		
		UMainePhotoModeSettingInput_SetAzimuthOffset_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMainePhotoModeSettingInput.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMainePhotoModeSettingInput::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MainePhotoModeSettingInput");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMainePhotoModeSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMainePhotoModeSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MainePhotoModeSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaineReplicationFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaineReplicationFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineReplicationFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaineReplicationGraph.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaineReplicationGraph::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineReplicationGraph");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineRichTextBlock.OnGlobalColorChanged
	 * 		Flags  -> ()
	 */
	void UMaineRichTextBlock::OnGlobalColorChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineRichTextBlock.OnGlobalColorChanged");
		
		UMaineRichTextBlock_OnGlobalColorChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaineRichTextBlock.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaineRichTextBlock::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineRichTextBlock");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaineStaticMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaineStaticMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineStaticMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaineTelemetryHelper.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaineTelemetryHelper::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineTelemetryHelper");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineTriggerBase.ResetTriggerCount
	 * 		Flags  -> ()
	 */
	void AMaineTriggerBase::ResetTriggerCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineTriggerBase.ResetTriggerCount");
		
		AMaineTriggerBase_ResetTriggerCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineTriggerBase.ReceiveTrigger
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMaineTriggerBase::ReceiveTrigger(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineTriggerBase.ReceiveTrigger");
		
		AMaineTriggerBase_ReceiveTrigger_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineTriggerBase.OnGlobalVariableChangedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       GlobalVariableID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            VariableValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ActorInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMaineTriggerBase::OnGlobalVariableChangedEvent(const struct FGuid& GlobalVariableID, int32_t VariableValue, class AActor* ActorInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineTriggerBase.OnGlobalVariableChangedEvent");
		
		AMaineTriggerBase_OnGlobalVariableChangedEvent_Params params {};
		params.GlobalVariableID = GlobalVariableID;
		params.VariableValue = VariableValue;
		params.ActorInstigator = ActorInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaineTriggerBase.GetTriggerCount
	 * 		Flags  -> ()
	 */
	int32_t AMaineTriggerBase::GetTriggerCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaineTriggerBase.GetTriggerCount");
		
		AMaineTriggerBase_GetTriggerCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMaineTriggerBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMaineTriggerBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineTriggerBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMaineTriggerBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMaineTriggerBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineTriggerBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMaineTriggerSphere.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMaineTriggerSphere::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaineTriggerSphere");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMainMenuButtonWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMainMenuButtonWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MainMenuButtonWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.TransitionToMainMenuState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMainMenuState                                     FromState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMainMenuState                                     ToState                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMainMenuStateTransitionType                       TransitionType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainMenuWidget::TransitionToMainMenuState(EMainMenuState FromState, EMainMenuState ToState, EMainMenuStateTransitionType TransitionType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.TransitionToMainMenuState");
		
		UMainMenuWidget_TransitionToMainMenuState_Params params {};
		params.FromState = FromState;
		params.ToState = ToState;
		params.TransitionType = TransitionType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.StartNewSinglePlayerGame
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::StartNewSinglePlayerGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.StartNewSinglePlayerGame");
		
		UMainMenuWidget_StartNewSinglePlayerGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.SetFocusForCurrentState
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::SetFocusForCurrentState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.SetFocusForCurrentState");
		
		UMainMenuWidget_SetFocusForCurrentState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.PushMainMenuState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMainMenuState                                     NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ReplacePriorState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainMenuWidget::PushMainMenuState(EMainMenuState NewState, bool ReplacePriorState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.PushMainMenuState");
		
		UMainMenuWidget_PushMainMenuState_Params params {};
		params.NewState = NewState;
		params.ReplacePriorState = ReplacePriorState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.PopToState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMainMenuState                                     NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainMenuWidget::PopToState(EMainMenuState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.PopToState");
		
		UMainMenuWidget_PopToState_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.PopMainMenuState
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::PopMainMenuState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.PopMainMenuState");
		
		UMainMenuWidget_PopMainMenuState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.OnSinglePlayerNewGameClicked
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::OnSinglePlayerNewGameClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.OnSinglePlayerNewGameClicked");
		
		UMainMenuWidget_OnSinglePlayerNewGameClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.OnSinglePlayerContinueClicked
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::OnSinglePlayerContinueClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.OnSinglePlayerContinueClicked");
		
		UMainMenuWidget_OnSinglePlayerContinueClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.OnSinglePlayerClicked
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::OnSinglePlayerClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.OnSinglePlayerClicked");
		
		UMainMenuWidget_OnSinglePlayerClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.OnMultiplayerNewGameClicked
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::OnMultiplayerNewGameClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.OnMultiplayerNewGameClicked");
		
		UMainMenuWidget_OnMultiplayerNewGameClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.OnMultiplayerHostClicked
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::OnMultiplayerHostClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.OnMultiplayerHostClicked");
		
		UMainMenuWidget_OnMultiplayerHostClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.OnMultiplayerContinueClicked
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::OnMultiplayerContinueClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.OnMultiplayerContinueClicked");
		
		UMainMenuWidget_OnMultiplayerContinueClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.OnMultiplayerConnectionError
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::OnMultiplayerConnectionError()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.OnMultiplayerConnectionError");
		
		UMainMenuWidget_OnMultiplayerConnectionError_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.OnMultiplayerClicked
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::OnMultiplayerClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.OnMultiplayerClicked");
		
		UMainMenuWidget_OnMultiplayerClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.OnLoadUserGameSettingsComplete
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::OnLoadUserGameSettingsComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.OnLoadUserGameSettingsComplete");
		
		UMainMenuWidget_OnLoadUserGameSettingsComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.OnButtonExitClicked
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::OnButtonExitClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.OnButtonExitClicked");
		
		UMainMenuWidget_OnButtonExitClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.OnBackInput
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::OnBackInput()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.OnBackInput");
		
		UMainMenuWidget_OnBackInput_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.OnActiveUserChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActiveUserChangeType                              ChangeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainMenuWidget::OnActiveUserChanged(EActiveUserChangeType ChangeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.OnActiveUserChanged");
		
		UMainMenuWidget_OnActiveUserChanged_Params params {};
		params.ChangeType = ChangeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.HostMultiplayerLobby
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bPasswordProtected                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainMenuWidget::HostMultiplayerLobby(bool bPasswordProtected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.HostMultiplayerLobby");
		
		UMainMenuWidget_HostMultiplayerLobby_Params params {};
		params.bPasswordProtected = bPasswordProtected;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.HandleShowPressAnyKeyPromptBegin
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::HandleShowPressAnyKeyPromptBegin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.HandleShowPressAnyKeyPromptBegin");
		
		UMainMenuWidget_HandleShowPressAnyKeyPromptBegin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.HandlePlayerInput
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            UserIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainMenuWidget::HandlePlayerInput(int32_t UserIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.HandlePlayerInput");
		
		UMainMenuWidget_HandlePlayerInput_Params params {};
		params.UserIndex = UserIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.GetMainMenuState
	 * 		Flags  -> ()
	 */
	EMainMenuState UMainMenuWidget::GetMainMenuState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.GetMainMenuState");
		
		UMainMenuWidget_GetMainMenuState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MainMenuWidget.CreateSinglePlayerLobby
	 * 		Flags  -> ()
	 */
	void UMainMenuWidget::CreateSinglePlayerLobby()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MainMenuWidget.CreateSinglePlayerLobby");
		
		UMainMenuWidget_CreateSinglePlayerLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMainMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMainMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MainMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UManagedRenderTargetObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UManagedRenderTargetObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ManagedRenderTargetObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapComponent.UnlockPuzzlePieceZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalPlayerState*                        Unlocker                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         PuzzlePieceRegion                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UMapComponent::UnlockPuzzlePieceZone(class ASurvivalPlayerState* Unlocker, const struct FDataTableRowHandle& PuzzlePieceRegion)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapComponent.UnlockPuzzlePieceZone");
		
		UMapComponent_UnlockPuzzlePieceZone_Params params {};
		params.Unlocker = Unlocker;
		params.PuzzlePieceRegion = PuzzlePieceRegion;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapComponent.OnRep_UnlockedMaps
	 * 		Flags  -> ()
	 */
	void UMapComponent::OnRep_UnlockedMaps()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapComponent.OnRep_UnlockedMaps");
		
		UMapComponent_OnRep_UnlockedMaps_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapComponent.MulticastNotifyPuzzlePieceZoneUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalPlayerState*                        Unlocker                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         UnlockedPuzzlePieceZone                                    (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UMapComponent::MulticastNotifyPuzzlePieceZoneUnlocked(class ASurvivalPlayerState* Unlocker, const struct FDataTableRowHandle& UnlockedPuzzlePieceZone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapComponent.MulticastNotifyPuzzlePieceZoneUnlocked");
		
		UMapComponent_MulticastNotifyPuzzlePieceZoneUnlocked_Params params {};
		params.Unlocker = Unlocker;
		params.UnlockedPuzzlePieceZone = UnlockedPuzzlePieceZone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapComponent.IsPuzzlePieceZoneUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         PuzzlePieceRegion                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UMapComponent::IsPuzzlePieceZoneUnlocked(const struct FDataTableRowHandle& PuzzlePieceRegion)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapComponent.IsPuzzlePieceZoneUnlocked");
		
		UMapComponent_IsPuzzlePieceZoneUnlocked_Params params {};
		params.PuzzlePieceRegion = PuzzlePieceRegion;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapComponent.HasSeenMapUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPuzzlePieceZone                                   MapData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UMapComponent::HasSeenMapUnlocked(EPuzzlePieceZone MapData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapComponent.HasSeenMapUnlocked");
		
		UMapComponent_HasSeenMapUnlocked_Params params {};
		params.MapData = MapData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapComponent.GetWorldMapPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector2D UMapComponent::GetWorldMapPosition(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapComponent.GetWorldMapPosition");
		
		UMapComponent_GetWorldMapPosition_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MapComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.UpdateVisibilityControls
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Show                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapLegendEntryWidget::UpdateVisibilityControls(bool Show, bool State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.UpdateVisibilityControls");
		
		UMapLegendEntryWidget_UpdateVisibilityControls_Params params {};
		params.Show = Show;
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.UpdateVisibility
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseMapEntryWidget*                         EntryWidget                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapLegendEntryWidget::UpdateVisibility(class UBaseMapEntryWidget* EntryWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.UpdateVisibility");
		
		UMapLegendEntryWidget_UpdateVisibility_Params params {};
		params.EntryWidget = EntryWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.UpdateCurrentEntryVisibility
	 * 		Flags  -> ()
	 */
	void UMapLegendEntryWidget::UpdateCurrentEntryVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.UpdateCurrentEntryVisibility");
		
		UMapLegendEntryWidget_UpdateCurrentEntryVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.ToggleCurrentEntryVisibility
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsVisible                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapLegendEntryWidget::ToggleCurrentEntryVisibility(bool IsVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.ToggleCurrentEntryVisibility");
		
		UMapLegendEntryWidget_ToggleCurrentEntryVisibility_Params params {};
		params.IsVisible = IsVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.ShowSingleElementControls
	 * 		Flags  -> ()
	 */
	void UMapLegendEntryWidget::ShowSingleElementControls()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.ShowSingleElementControls");
		
		UMapLegendEntryWidget_ShowSingleElementControls_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.ShowArrowControls
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Show                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapLegendEntryWidget::ShowArrowControls(bool Show)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.ShowArrowControls");
		
		UMapLegendEntryWidget_ShowArrowControls_Params params {};
		params.Show = Show;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.SetCustomPlayerVisuals
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerCharacterIdentity                           Identity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapLegendEntryWidget::SetCustomPlayerVisuals(EPlayerCharacterIdentity Identity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.SetCustomPlayerVisuals");
		
		UMapLegendEntryWidget_SetCustomPlayerVisuals_Params params {};
		params.Identity = Identity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.RefreshNumberText
	 * 		Flags  -> ()
	 */
	void UMapLegendEntryWidget::RefreshNumberText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.RefreshNumberText");
		
		UMapLegendEntryWidget_RefreshNumberText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.RefreshEntry
	 * 		Flags  -> ()
	 */
	void UMapLegendEntryWidget::RefreshEntry()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.RefreshEntry");
		
		UMapLegendEntryWidget_RefreshEntry_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.OnPreviousButtonClicked
	 * 		Flags  -> ()
	 */
	void UMapLegendEntryWidget::OnPreviousButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.OnPreviousButtonClicked");
		
		UMapLegendEntryWidget_OnPreviousButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.OnNextButtonClicked
	 * 		Flags  -> ()
	 */
	void UMapLegendEntryWidget::OnNextButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.OnNextButtonClicked");
		
		UMapLegendEntryWidget_OnNextButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.GotoPreviousEntry
	 * 		Flags  -> ()
	 */
	void UMapLegendEntryWidget::GotoPreviousEntry()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.GotoPreviousEntry");
		
		UMapLegendEntryWidget_GotoPreviousEntry_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.GotoNextEntry
	 * 		Flags  -> ()
	 */
	void UMapLegendEntryWidget::GotoNextEntry()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.GotoNextEntry");
		
		UMapLegendEntryWidget_GotoNextEntry_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.GotoEntry
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseMapEntryWidget*                         EntryWidget                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapLegendEntryWidget::GotoEntry(class UBaseMapEntryWidget* EntryWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.GotoEntry");
		
		UMapLegendEntryWidget_GotoEntry_Params params {};
		params.EntryWidget = EntryWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.GotoCurrentEntry
	 * 		Flags  -> ()
	 */
	void UMapLegendEntryWidget::GotoCurrentEntry()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.GotoCurrentEntry");
		
		UMapLegendEntryWidget_GotoCurrentEntry_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.GetNumEntries
	 * 		Flags  -> ()
	 */
	int32_t UMapLegendEntryWidget::GetNumEntries()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.GetNumEntries");
		
		UMapLegendEntryWidget_GetNumEntries_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.GetMapEntryType
	 * 		Flags  -> ()
	 */
	EMapEntryType UMapLegendEntryWidget::GetMapEntryType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.GetMapEntryType");
		
		UMapLegendEntryWidget_GetMapEntryType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapLegendEntryWidget.GetEntryWidgets
	 * 		Flags  -> ()
	 */
	TArray<class UBaseMapEntryWidget*> UMapLegendEntryWidget::GetEntryWidgets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapLegendEntryWidget.GetEntryWidgets");
		
		UMapLegendEntryWidget_GetEntryWidgets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapLegendEntryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapLegendEntryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MapLegendEntryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapMarkerWidget.HandleHUDMarkerDataChanged
	 * 		Flags  -> ()
	 */
	void UMapMarkerWidget::HandleHUDMarkerDataChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapMarkerWidget.HandleHUDMarkerDataChanged");
		
		UMapMarkerWidget_HandleHUDMarkerDataChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapMarkerWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapMarkerWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MapMarkerWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.SetOwnerScreen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     Owner                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::SetOwnerScreen(class UWidget* Owner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.SetOwnerScreen");
		
		UMapPanelWidget_SetOwnerScreen_Params params {};
		params.Owner = Owner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.PopulateAll
	 * 		Flags  -> ()
	 */
	void UMapPanelWidget::PopulateAll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.PopulateAll");
		
		UMapPanelWidget_PopulateAll_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.OnZoomChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ZoomLevel                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::OnZoomChange(int32_t ZoomLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.OnZoomChange");
		
		UMapPanelWidget_OnZoomChange_Params params {};
		params.ZoomLevel = ZoomLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.OnUnlockedMapsChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMapComponent*                               Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::OnUnlockedMapsChanged(class UMapComponent* Sender)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.OnUnlockedMapsChanged");
		
		UMapPanelWidget_OnUnlockedMapsChanged_Params params {};
		params.Sender = Sender;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.OnPlayerWaypointRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHUDMarkerData*                              MarkerData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::OnPlayerWaypointRemoved(class UHUDMarkerData* MarkerData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.OnPlayerWaypointRemoved");
		
		UMapPanelWidget_OnPlayerWaypointRemoved_Params params {};
		params.MarkerData = MarkerData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.OnPlayerWaypointAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHUDMarkerData*                              MarkerData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::OnPlayerWaypointAdded(class UHUDMarkerData* MarkerData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.OnPlayerWaypointAdded");
		
		UMapPanelWidget_OnPlayerWaypointAdded_Params params {};
		params.MarkerData = MarkerData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.OnPlayerMarkerRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHUDMarkerData*                              MarkerData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::OnPlayerMarkerRemoved(class UHUDMarkerData* MarkerData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.OnPlayerMarkerRemoved");
		
		UMapPanelWidget_OnPlayerMarkerRemoved_Params params {};
		params.MarkerData = MarkerData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.OnPlayerMarkerAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHUDMarkerData*                              MarkerData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::OnPlayerMarkerAdded(class UHUDMarkerData* MarkerData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.OnPlayerMarkerAdded");
		
		UMapPanelWidget_OnPlayerMarkerAdded_Params params {};
		params.MarkerData = MarkerData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.OnMarkerRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHUDMarkerData*                              MarkerData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::OnMarkerRemoved(class UHUDMarkerData* MarkerData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.OnMarkerRemoved");
		
		UMapPanelWidget_OnMarkerRemoved_Params params {};
		params.MarkerData = MarkerData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.OnMarkerAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHUDMarkerData*                              MarkerData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::OnMarkerAdded(class UHUDMarkerData* MarkerData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.OnMarkerAdded");
		
		UMapPanelWidget_OnMarkerAdded_Params params {};
		params.MarkerData = MarkerData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.OnMapEntryMouseUnHovered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseMapEntryWidget*                         EntryWidget                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::OnMapEntryMouseUnHovered(class UBaseMapEntryWidget* EntryWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.OnMapEntryMouseUnHovered");
		
		UMapPanelWidget_OnMapEntryMouseUnHovered_Params params {};
		params.EntryWidget = EntryWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.OnMapEntryMouseHovered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseMapEntryWidget*                         EntryWidget                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::OnMapEntryMouseHovered(class UBaseMapEntryWidget* EntryWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.OnMapEntryMouseHovered");
		
		UMapPanelWidget_OnMapEntryMouseHovered_Params params {};
		params.EntryWidget = EntryWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.OnBorderMouseDown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGeometry                                   MyGeometry                                                 (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FPointerEvent                               MouseEvent                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FEventReply UMapPanelWidget::OnBorderMouseDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.OnBorderMouseDown");
		
		UMapPanelWidget_OnBorderMouseDown_Params params {};
		params.MyGeometry = MyGeometry;
		params.MouseEvent = MouseEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.HandleMapEntryFocusLost_Internal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               ViaMouseHover                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::HandleMapEntryFocusLost_Internal(bool ViaMouseHover)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.HandleMapEntryFocusLost_Internal");
		
		UMapPanelWidget_HandleMapEntryFocusLost_Internal_Params params {};
		params.ViaMouseHover = ViaMouseHover;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.HandleMapEntryFocusLost
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               ViaMouseHover                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::HandleMapEntryFocusLost(bool ViaMouseHover)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.HandleMapEntryFocusLost");
		
		UMapPanelWidget_HandleMapEntryFocusLost_Params params {};
		params.ViaMouseHover = ViaMouseHover;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.HandleMapEntryFocused_Internal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseMapEntryWidget*                         MapEntry                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMapEntryType                                      EntryType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ViaMouseHover                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::HandleMapEntryFocused_Internal(class UBaseMapEntryWidget* MapEntry, EMapEntryType EntryType, bool ViaMouseHover)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.HandleMapEntryFocused_Internal");
		
		UMapPanelWidget_HandleMapEntryFocused_Internal_Params params {};
		params.MapEntry = MapEntry;
		params.EntryType = EntryType;
		params.ViaMouseHover = ViaMouseHover;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.HandleMapEntryFocused
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseMapEntryWidget*                         MapEntry                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMapEntryType                                      EntryType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ViaMouseHover                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::HandleMapEntryFocused(class UBaseMapEntryWidget* MapEntry, EMapEntryType EntryType, bool ViaMouseHover)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.HandleMapEntryFocused");
		
		UMapPanelWidget_HandleMapEntryFocused_Params params {};
		params.MapEntry = MapEntry;
		params.EntryType = EntryType;
		params.ViaMouseHover = ViaMouseHover;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.GetWorldPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector2D                                   MapPosition                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector2D UMapPanelWidget::GetWorldPosition(const struct FVector2D& MapPosition, bool bIncludeRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.GetWorldPosition");
		
		UMapPanelWidget_GetWorldPosition_Params params {};
		params.MapPosition = MapPosition;
		params.bIncludeRotation = bIncludeRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.GetViewCenterPosition
	 * 		Flags  -> ()
	 */
	struct FVector2D UMapPanelWidget::GetViewCenterPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.GetViewCenterPosition");
		
		UMapPanelWidget_GetViewCenterPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.GetMapPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     WorldLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector2D UMapPanelWidget::GetMapPosition(const struct FVector& WorldLocation, bool bIncludeRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.GetMapPosition");
		
		UMapPanelWidget_GetMapPosition_Params params {};
		params.WorldLocation = WorldLocation;
		params.bIncludeRotation = bIncludeRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.GetEntryUnderCursor
	 * 		Flags  -> ()
	 */
	class UBaseMapEntryWidget* UMapPanelWidget::GetEntryUnderCursor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.GetEntryUnderCursor");
		
		UMapPanelWidget_GetEntryUnderCursor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.FindClosestValidMapEntryToMapCursor
	 * 		Flags  -> ()
	 */
	class UBaseMapEntryWidget* UMapPanelWidget::FindClosestValidMapEntryToMapCursor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.FindClosestValidMapEntryToMapCursor");
		
		UMapPanelWidget_FindClosestValidMapEntryToMapCursor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.CycleZoomValue
	 * 		Flags  -> ()
	 */
	void UMapPanelWidget::CycleZoomValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.CycleZoomValue");
		
		UMapPanelWidget_CycleZoomValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.CenterMapOnPlayer
	 * 		Flags  -> ()
	 */
	void UMapPanelWidget::CenterMapOnPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.CenterMapOnPlayer");
		
		UMapPanelWidget_CenterMapOnPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPanelWidget.AdjustZoomLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ChangeInZoom                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPanelWidget::AdjustZoomLevel(int32_t ChangeInZoom)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPanelWidget.AdjustZoomLevel");
		
		UMapPanelWidget_AdjustZoomLevel_Params params {};
		params.ChangeInZoom = ChangeInZoom;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapPanelWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapPanelWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MapPanelWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapPlayerWaypointWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapPlayerWaypointWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MapPlayerWaypointWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapPlayerWidget.SetPlayerRotation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapPlayerWidget::SetPlayerRotation(float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapPlayerWidget.SetPlayerRotation");
		
		UMapPlayerWidget_SetPlayerRotation_Params params {};
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapPlayerWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapPlayerWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MapPlayerWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapPOIWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapPOIWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MapPOIWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapPuzzleContainerWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapPuzzleContainerWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MapPuzzleContainerWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapPuzzlePieceTextureData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapPuzzlePieceTextureData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MapPuzzlePieceTextureData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapPuzzlePieceWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapPuzzlePieceWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MapPuzzlePieceWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapResourceSurveyWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapResourceSurveyWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MapResourceSurveyWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapResourceWaypointWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapResourceWaypointWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MapResourceWaypointWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapStation.OnMapDownloaded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMapStation::OnMapDownloaded(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapStation.OnMapDownloaded");
		
		AMapStation_OnMapDownloaded_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMapStation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMapStation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MapStation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapWidget.ToggleMapMarkerOnFocusedMapEntry
	 * 		Flags  -> ()
	 */
	void UMapWidget::ToggleMapMarkerOnFocusedMapEntry()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapWidget.ToggleMapMarkerOnFocusedMapEntry");
		
		UMapWidget_ToggleMapMarkerOnFocusedMapEntry_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapWidget.PopulatePlayerWaypointLegend
	 * 		Flags  -> ()
	 */
	void UMapWidget::PopulatePlayerWaypointLegend()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapWidget.PopulatePlayerWaypointLegend");
		
		UMapWidget_PopulatePlayerWaypointLegend_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapWidget.PopulateEntriesForMap
	 * 		Flags  -> ()
	 */
	void UMapWidget::PopulateEntriesForMap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapWidget.PopulateEntriesForMap");
		
		UMapWidget_PopulateEntriesForMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapWidget.OnPlayerWaypointRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHUDMarkerData*                              MarkerData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapWidget::OnPlayerWaypointRemoved(class UHUDMarkerData* MarkerData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapWidget.OnPlayerWaypointRemoved");
		
		UMapWidget_OnPlayerWaypointRemoved_Params params {};
		params.MarkerData = MarkerData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapWidget.OnPlayerWaypointAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHUDMarkerData*                              MarkerData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapWidget::OnPlayerWaypointAdded(class UHUDMarkerData* MarkerData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapWidget.OnPlayerWaypointAdded");
		
		UMapWidget_OnPlayerWaypointAdded_Params params {};
		params.MarkerData = MarkerData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapWidget.OnLegendEntrySelected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseMapEntryWidget*                         EntryWidget                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMapEntryType                                      MapEntryType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapWidget::OnLegendEntrySelected(class UBaseMapEntryWidget* EntryWidget, EMapEntryType MapEntryType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapWidget.OnLegendEntrySelected");
		
		UMapWidget_OnLegendEntrySelected_Params params {};
		params.EntryWidget = EntryWidget;
		params.MapEntryType = MapEntryType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapWidget.OnLegendEntryFocused
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMapLegendEntryWidget*                       Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapWidget::OnLegendEntryFocused(class UMapLegendEntryWidget* Sender)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapWidget.OnLegendEntryFocused");
		
		UMapWidget_OnLegendEntryFocused_Params params {};
		params.Sender = Sender;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MapWidget.K2_OnLegendEntryFocused
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMapLegendEntryWidget*                       Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapWidget::K2_OnLegendEntryFocused(class UMapLegendEntryWidget* Widget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MapWidget.K2_OnLegendEntryFocused");
		
		UMapWidget_K2_OnLegendEntryFocused_Params params {};
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MapWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaterialSwapComponent.SetMaterial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMaterialSwapLayer                                 Layer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMeshComponent*                              Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaterialIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaterialSwapComponent::SetMaterial(EMaterialSwapLayer Layer, class UMeshComponent* Component, int32_t MaterialIndex, class UMaterialInterface* Material)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaterialSwapComponent.SetMaterial");
		
		UMaterialSwapComponent_SetMaterial_Params params {};
		params.Layer = Layer;
		params.Component = Component;
		params.MaterialIndex = MaterialIndex;
		params.Material = Material;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaterialSwapComponent.GetMaterial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMaterialSwapLayer                                 Layer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMeshComponent*                              Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaterialIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UMaterialInterface* UMaterialSwapComponent::GetMaterial(EMaterialSwapLayer Layer, class UMeshComponent* Component, int32_t MaterialIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaterialSwapComponent.GetMaterial");
		
		UMaterialSwapComponent_GetMaterial_Params params {};
		params.Layer = Layer;
		params.Component = Component;
		params.MaterialIndex = MaterialIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaterialSwapComponent.ClearMaterials
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMaterialSwapLayer                                 Layer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMeshComponent*                              Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaterialSwapComponent::ClearMaterials(EMaterialSwapLayer Layer, class UMeshComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaterialSwapComponent.ClearMaterials");
		
		UMaterialSwapComponent_ClearMaterials_Params params {};
		params.Layer = Layer;
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MaterialSwapComponent.ClearMaterial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMaterialSwapLayer                                 Layer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMeshComponent*                              Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaterialIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMaterialSwapComponent::ClearMaterial(EMaterialSwapLayer Layer, class UMeshComponent* Component, int32_t MaterialIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MaterialSwapComponent.ClearMaterial");
		
		UMaterialSwapComponent_ClearMaterial_Params params {};
		params.Layer = Layer;
		params.Component = Component;
		params.MaterialIndex = MaterialIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialSwapComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialSwapComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MaterialSwapComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMenuGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMenuGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MenuGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MetaBuildingDataLibrary.GetMetaBuildingUnlockedSubBuildingNum
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         MetaBuilding                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UMetaBuildingDataLibrary::GetMetaBuildingUnlockedSubBuildingNum(class UObject* WorldContextObject, const struct FDataTableRowHandle& MetaBuilding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MetaBuildingDataLibrary.GetMetaBuildingUnlockedSubBuildingNum");
		
		UMetaBuildingDataLibrary_GetMetaBuildingUnlockedSubBuildingNum_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.MetaBuilding = MetaBuilding;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MetaBuildingDataLibrary.GetMetaBuildingUiSubBuilding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMetaBuildingData                           Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDataTableRowHandle>                 Variants                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle UMetaBuildingDataLibrary::GetMetaBuildingUiSubBuilding(class UObject* WorldContextObject, const struct FMetaBuildingData& Data, TArray<struct FDataTableRowHandle> Variants)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MetaBuildingDataLibrary.GetMetaBuildingUiSubBuilding");
		
		UMetaBuildingDataLibrary_GetMetaBuildingUiSubBuilding_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Data = Data;
		params.Variants = Variants;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MetaBuildingDataLibrary.GetMetaBuildingSubBuildingIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMetaBuildingIdentifier                     Identifier                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UMetaBuildingDataLibrary::GetMetaBuildingSubBuildingIndex(class UObject* WorldContextObject, const struct FMetaBuildingIdentifier& Identifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MetaBuildingDataLibrary.GetMetaBuildingSubBuildingIndex");
		
		UMetaBuildingDataLibrary_GetMetaBuildingSubBuildingIndex_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Identifier = Identifier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MetaBuildingDataLibrary.GetMetaBuildingHasMultipleUnlockedSubBuildings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         MetaBuilding                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UMetaBuildingDataLibrary::GetMetaBuildingHasMultipleUnlockedSubBuildings(class UObject* WorldContextObject, const struct FDataTableRowHandle& MetaBuilding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MetaBuildingDataLibrary.GetMetaBuildingHasMultipleUnlockedSubBuildings");
		
		UMetaBuildingDataLibrary_GetMetaBuildingHasMultipleUnlockedSubBuildings_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.MetaBuilding = MetaBuilding;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MetaBuildingDataLibrary.GetMetaBuildingCurrentSubBuildingIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         MetabuildingRow                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UMetaBuildingDataLibrary::GetMetaBuildingCurrentSubBuildingIndex(class UObject* WorldContextObject, const struct FDataTableRowHandle& MetabuildingRow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MetaBuildingDataLibrary.GetMetaBuildingCurrentSubBuildingIndex");
		
		UMetaBuildingDataLibrary_GetMetaBuildingCurrentSubBuildingIndex_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.MetabuildingRow = MetabuildingRow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MetaBuildingDataLibrary.FindInMetaBuildings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 MetaBuildings                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         Needle                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UMetaBuildingDataLibrary::FindInMetaBuildings(TArray<struct FDataTableRowHandle> MetaBuildings, const struct FDataTableRowHandle& Needle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MetaBuildingDataLibrary.FindInMetaBuildings");
		
		UMetaBuildingDataLibrary_FindInMetaBuildings_Params params {};
		params.MetaBuildings = MetaBuildings;
		params.Needle = Needle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaBuildingDataLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaBuildingDataLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MetaBuildingDataLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.UnpauseSave
	 * 		Flags  -> ()
	 */
	void USaveLoadManager::UnpauseSave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.UnpauseSave");
		
		USaveLoadManager_UnpauseSave_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.ShouldRestorePersistence
	 * 		Flags  -> ()
	 */
	bool USaveLoadManager::ShouldRestorePersistence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.ShouldRestorePersistence");
		
		USaveLoadManager_ShouldRestorePersistence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.SetSaveGameHeaderDatasRequireLoad
	 * 		Flags  -> ()
	 */
	void USaveLoadManager::SetSaveGameHeaderDatasRequireLoad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.SetSaveGameHeaderDatasRequireLoad");
		
		USaveLoadManager_SetSaveGameHeaderDatasRequireLoad_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.SaveUserGameSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSettingsPotentiallyChanged                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USaveLoadManager::SaveUserGameSettings(bool bSettingsPotentiallyChanged)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.SaveUserGameSettings");
		
		USaveLoadManager_SaveUserGameSettings_Params params {};
		params.bSettingsPotentiallyChanged = bSettingsPotentiallyChanged;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.Save
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESaveGameType                                      SaveGameType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USaveLoadManager::Save(ESaveGameType SaveGameType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.Save");
		
		USaveLoadManager_Save_Params params {};
		params.SaveGameType = SaveGameType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.RestoreNewPlayerFromController
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EPlayerRestoreResult USaveLoadManager::RestoreNewPlayerFromController(class APlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.RestoreNewPlayerFromController");
		
		USaveLoadManager_RestoreNewPlayerFromController_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.RequestAutoSave
	 * 		Flags  -> ()
	 */
	void USaveLoadManager::RequestAutoSave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.RequestAutoSave");
		
		USaveLoadManager_RequestAutoSave_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.PauseSave
	 * 		Flags  -> ()
	 */
	void USaveLoadManager::PauseSave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.PauseSave");
		
		USaveLoadManager_PauseSave_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.LoadUserGameSettings
	 * 		Flags  -> ()
	 */
	void USaveLoadManager::LoadUserGameSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.LoadUserGameSettings");
		
		USaveLoadManager_LoadUserGameSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.LoadSaveGameHeaderDatas
	 * 		Flags  -> ()
	 */
	void USaveLoadManager::LoadSaveGameHeaderDatas()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.LoadSaveGameHeaderDatas");
		
		USaveLoadManager_LoadSaveGameHeaderDatas_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.Load
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USaveGameHeaderData*                         SaveGameHeader                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USaveLoadManager::Load(class USaveGameHeaderData* SaveGameHeader)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.Load");
		
		USaveLoadManager_Load_Params params {};
		params.SaveGameHeader = SaveGameHeader;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.IsLoading
	 * 		Flags  -> ()
	 */
	bool USaveLoadManager::IsLoading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.IsLoading");
		
		USaveLoadManager_IsLoading_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.HasEnoughStorageForNewSave
	 * 		Flags  -> ()
	 */
	bool USaveLoadManager::HasEnoughStorageForNewSave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.HasEnoughStorageForNewSave");
		
		USaveLoadManager_HasEnoughStorageForNewSave_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.HandleSaveConversion
	 * 		Flags  -> ()
	 */
	void USaveLoadManager::HandleSaveConversion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.HandleSaveConversion");
		
		USaveLoadManager_HandleSaveConversion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.HandleCheckIfNeedsSaveConversion
	 * 		Flags  -> ()
	 */
	void USaveLoadManager::HandleCheckIfNeedsSaveConversion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.HandleCheckIfNeedsSaveConversion");
		
		USaveLoadManager_HandleCheckIfNeedsSaveConversion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.GetSaveDataToLoad
	 * 		Flags  -> ()
	 */
	class USaveGameHeaderData* USaveLoadManager::GetSaveDataToLoad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.GetSaveDataToLoad");
		
		USaveLoadManager_GetSaveDataToLoad_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.GetSaveConvertPercentage
	 * 		Flags  -> ()
	 */
	float USaveLoadManager::GetSaveConvertPercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.GetSaveConvertPercentage");
		
		USaveLoadManager_GetSaveConvertPercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.GetRemainingStorage
	 * 		Flags  -> ()
	 */
	int64_t USaveLoadManager::GetRemainingStorage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.GetRemainingStorage");
		
		USaveLoadManager_GetRemainingStorage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.ExportSave
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USaveGameHeaderData*                         HeaderData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString USaveLoadManager::ExportSave(class USaveGameHeaderData* HeaderData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.ExportSave");
		
		USaveLoadManager_ExportSave_Params params {};
		params.HeaderData = HeaderData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.EnsureSignIn
	 * 		Flags  -> ()
	 */
	bool USaveLoadManager::EnsureSignIn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.EnsureSignIn");
		
		USaveLoadManager_EnsureSignIn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.DoSaveGameHeaderDatasRequireLoad
	 * 		Flags  -> ()
	 */
	bool USaveLoadManager::DoSaveGameHeaderDatasRequireLoad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.DoSaveGameHeaderDatasRequireLoad");
		
		USaveLoadManager_DoSaveGameHeaderDatasRequireLoad_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.DidLoadFromSaveGame
	 * 		Flags  -> ()
	 */
	bool USaveLoadManager::DidLoadFromSaveGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.DidLoadFromSaveGame");
		
		USaveLoadManager_DidLoadFromSaveGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.Delete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USaveGameHeaderData*                         SaveGameHeader                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USaveLoadManager::Delete(class USaveGameHeaderData* SaveGameHeader)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.Delete");
		
		USaveLoadManager_Delete_Params params {};
		params.SaveGameHeader = SaveGameHeader;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.CanSaveGame
	 * 		Flags  -> ()
	 */
	ESaveLoadRestriction USaveLoadManager::CanSaveGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.CanSaveGame");
		
		USaveLoadManager_CanSaveGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.CanSave
	 * 		Flags  -> ()
	 */
	bool USaveLoadManager::CanSave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.CanSave");
		
		USaveLoadManager_CanSave_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.CanLoad
	 * 		Flags  -> ()
	 */
	bool USaveLoadManager::CanLoad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.CanLoad");
		
		USaveLoadManager_CanLoad_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadManager.CanDelete
	 * 		Flags  -> ()
	 */
	bool USaveLoadManager::CanDelete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadManager.CanDelete");
		
		USaveLoadManager_CanDelete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USaveLoadManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USaveLoadManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SaveLoadManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMicrosoftSaveLoadManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMicrosoftSaveLoadManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MicrosoftSaveLoadManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ModelViewerCapture.ViewStaticMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 Mesh                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UMaterialInterface*>                  Materials                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AModelViewerCapture::ViewStaticMesh(class UStaticMesh* Mesh, TArray<class UMaterialInterface*> Materials, float Scale, const struct FVector& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ModelViewerCapture.ViewStaticMesh");
		
		AModelViewerCapture_ViewStaticMesh_Params params {};
		params.Mesh = Mesh;
		params.Materials = Materials;
		params.Scale = Scale;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ModelViewerCapture.ViewSkeletalMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMesh*                               Mesh                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UMaterialInterface*>                  Materials                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AModelViewerCapture::ViewSkeletalMesh(class USkeletalMesh* Mesh, TArray<class UMaterialInterface*> Materials, float Scale, const struct FVector& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ModelViewerCapture.ViewSkeletalMesh");
		
		AModelViewerCapture_ViewSkeletalMesh_Params params {};
		params.Mesh = Mesh;
		params.Materials = Materials;
		params.Scale = Scale;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ModelViewerCapture.ViewBlueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      BlueprintClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AModelViewerCapture::ViewBlueprint(class UClass* BlueprintClass, float Scale, const struct FVector& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ModelViewerCapture.ViewBlueprint");
		
		AModelViewerCapture_ViewBlueprint_Params params {};
		params.BlueprintClass = BlueprintClass;
		params.Scale = Scale;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ModelViewerCapture.ViewArmorMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMesh*                               Mesh                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UMaterialInterface*>                  Materials                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEquipmentSlot                                     Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUsePet                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AModelViewerCapture::ViewArmorMesh(class USkeletalMesh* Mesh, TArray<class UMaterialInterface*> Materials, float Scale, const struct FVector& Offset, EEquipmentSlot Slot, bool bUsePet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ModelViewerCapture.ViewArmorMesh");
		
		AModelViewerCapture_ViewArmorMesh_Params params {};
		params.Mesh = Mesh;
		params.Materials = Materials;
		params.Scale = Scale;
		params.Offset = Offset;
		params.Slot = Slot;
		params.bUsePet = bUsePet;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ModelViewerCapture.View2DTexture
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTexture*                                    Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AModelViewerCapture::View2DTexture(class UTexture* Texture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ModelViewerCapture.View2DTexture");
		
		AModelViewerCapture_View2DTexture_Params params {};
		params.Texture = Texture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ModelViewerCapture.SetShowSkyLight
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShow                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AModelViewerCapture::SetShowSkyLight(bool bShow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ModelViewerCapture.SetShowSkyLight");
		
		AModelViewerCapture_SetShowSkyLight_Params params {};
		params.bShow = bShow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ModelViewerCapture.SetShowOverheadSpot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShow                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AModelViewerCapture::SetShowOverheadSpot(bool bShow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ModelViewerCapture.SetShowOverheadSpot");
		
		AModelViewerCapture_SetShowOverheadSpot_Params params {};
		params.bShow = bShow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ModelViewerCapture.SetInspectionStaticMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 Mesh                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AModelViewerCapture::SetInspectionStaticMesh(class UStaticMesh* Mesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ModelViewerCapture.SetInspectionStaticMesh");
		
		AModelViewerCapture_SetInspectionStaticMesh_Params params {};
		params.Mesh = Mesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ModelViewerCapture.SetInspectionItemData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemDataHandle                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AModelViewerCapture::SetInspectionItemData(const struct FDataTableRowHandle& ItemDataHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ModelViewerCapture.SetInspectionItemData");
		
		AModelViewerCapture_SetInspectionItemData_Params params {};
		params.ItemDataHandle = ItemDataHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ModelViewerCapture.SetInspectionBuildingData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         BuildingDataHandle                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AModelViewerCapture::SetInspectionBuildingData(const struct FDataTableRowHandle& BuildingDataHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ModelViewerCapture.SetInspectionBuildingData");
		
		AModelViewerCapture_SetInspectionBuildingData_Params params {};
		params.BuildingDataHandle = BuildingDataHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ModelViewerCapture.InitializeRotation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInAutoRotate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInAllowRotationY                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InStartingRotationX                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InStartingRotationY                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AModelViewerCapture::InitializeRotation(bool bInAutoRotate, bool bInAllowRotationY, float InStartingRotationX, float InStartingRotationY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ModelViewerCapture.InitializeRotation");
		
		AModelViewerCapture_InitializeRotation_Params params {};
		params.bInAutoRotate = bInAutoRotate;
		params.bInAllowRotationY = bInAllowRotationY;
		params.InStartingRotationX = InStartingRotationX;
		params.InStartingRotationY = InStartingRotationY;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ModelViewerCapture.Cleanup
	 * 		Flags  -> ()
	 */
	void AModelViewerCapture::Cleanup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ModelViewerCapture.Cleanup");
		
		AModelViewerCapture_Cleanup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AModelViewerCapture.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AModelViewerCapture::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ModelViewerCapture");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MusicManager.SetScriptedTrack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMusicTrackData*                             TrackData                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMusicManager::SetScriptedTrack(class UMusicTrackData* TrackData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MusicManager.SetScriptedTrack");
		
		UMusicManager_SetScriptedTrack_Params params {};
		params.TrackData = TrackData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.MusicManager.ClearScriptedTrack
	 * 		Flags  -> ()
	 */
	void UMusicManager::ClearScriptedTrack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.MusicManager.ClearScriptedTrack");
		
		UMusicManager_ClearScriptedTrack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMusicManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMusicManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MusicManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMusicTrackData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMusicTrackData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MusicTrackData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMusicSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMusicSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.MusicSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNotificationLogBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNotificationLogBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.NotificationLogBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectiveInterfaceWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectiveInterfaceWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ObjectiveInterfaceWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ObjectiveNotificationWidget.ProcessQueuedQuestNotification
	 * 		Flags  -> ()
	 */
	void UObjectiveNotificationWidget::ProcessQueuedQuestNotification()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ObjectiveNotificationWidget.ProcessQueuedQuestNotification");
		
		UObjectiveNotificationWidget_ProcessQueuedQuestNotification_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ObjectiveNotificationWidget.HasQueuedQuestNotifications
	 * 		Flags  -> ()
	 */
	bool UObjectiveNotificationWidget::HasQueuedQuestNotifications()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ObjectiveNotificationWidget.HasQueuedQuestNotifications");
		
		UObjectiveNotificationWidget_HasQueuedQuestNotifications_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectiveNotificationWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectiveNotificationWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ObjectiveNotificationWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OCLComponent.Unlock
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOCLComponent::Unlock(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OCLComponent.Unlock");
		
		UOCLComponent_Unlock_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OCLComponent.ToggleOpen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOCLComponent::ToggleOpen(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OCLComponent.ToggleOpen");
		
		UOCLComponent_ToggleOpen_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OCLComponent.ToggleLock
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOCLComponent::ToggleLock(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OCLComponent.ToggleLock");
		
		UOCLComponent_ToggleLock_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OCLComponent.Open
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOCLComponent::Open(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OCLComponent.Open");
		
		UOCLComponent_Open_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OCLComponent.OnRep_IsOpen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bWasOpen                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOCLComponent::OnRep_IsOpen(bool bWasOpen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OCLComponent.OnRep_IsOpen");
		
		UOCLComponent_OnRep_IsOpen_Params params {};
		params.bWasOpen = bWasOpen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OCLComponent.OnRep_IsLocked
	 * 		Flags  -> ()
	 */
	void UOCLComponent::OnRep_IsLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OCLComponent.OnRep_IsLocked");
		
		UOCLComponent_OnRep_IsLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OCLComponent.MulticastNotifyOpenStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOpen                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOCLComponent::MulticastNotifyOpenStateChanged(bool bOpen, class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OCLComponent.MulticastNotifyOpenStateChanged");
		
		UOCLComponent_MulticastNotifyOpenStateChanged_Params params {};
		params.bOpen = bOpen;
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OCLComponent.Lock
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOCLComponent::Lock(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OCLComponent.Lock");
		
		UOCLComponent_Lock_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OCLComponent.IsOpen
	 * 		Flags  -> ()
	 */
	bool UOCLComponent::IsOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OCLComponent.IsOpen");
		
		UOCLComponent_IsOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OCLComponent.IsLocked
	 * 		Flags  -> ()
	 */
	bool UOCLComponent::IsLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OCLComponent.IsLocked");
		
		UOCLComponent_IsLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OCLComponent.HasKeyToUnlock
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOCLComponent::HasKeyToUnlock(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OCLComponent.HasKeyToUnlock");
		
		UOCLComponent_HasKeyToUnlock_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OCLComponent.Close
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOCLComponent::Close(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OCLComponent.Close");
		
		UOCLComponent_Close_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOCLComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOCLComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.OCLComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnOffToggleWidget.OnToggleStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsToggled                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnOffToggleWidget::OnToggleStateChanged(bool bIsToggled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnOffToggleWidget.OnToggleStateChanged");
		
		UOnOffToggleWidget_OnToggleStateChanged_Params params {};
		params.bIsToggled = bIsToggled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOnOffToggleWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOnOffToggleWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.OnOffToggleWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.SubtractIntVectors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FIntVector                                  A                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FIntVector                                  B                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FIntVector UOnyxFunctionLibrary::SubtractIntVectors(const struct FIntVector& A, const struct FIntVector& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.SubtractIntVectors");
		
		UOnyxFunctionLibrary_SubtractIntVectors_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.RInterpCappedTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRotator                                    Current                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Target                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxSpeed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRotator UOnyxFunctionLibrary::RInterpCappedTo(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float Alpha, float MaxSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.RInterpCappedTo");
		
		UOnyxFunctionLibrary_RInterpCappedTo_Params params {};
		params.Current = Current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.Alpha = Alpha;
		params.MaxSpeed = MaxSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.RangeContains
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFloatRange                                 Range                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnyxFunctionLibrary::RangeContains(const struct FFloatRange& Range, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.RangeContains");
		
		UOnyxFunctionLibrary_RangeContains_Params params {};
		params.Range = Range;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.RandomElementRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 Array                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle UOnyxFunctionLibrary::RandomElementRowHandle(TArray<struct FDataTableRowHandle> Array)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.RandomElementRowHandle");
		
		UOnyxFunctionLibrary_RandomElementRowHandle_Params params {};
		params.Array = Array;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.RandomElementLocString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FLocString>                          Array                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FLocString UOnyxFunctionLibrary::RandomElementLocString(TArray<struct FLocString> Array)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.RandomElementLocString");
		
		UOnyxFunctionLibrary_RandomElementLocString_Params params {};
		params.Array = Array;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.RandomElementInt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<int32_t>                                    Array                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	int32_t UOnyxFunctionLibrary::RandomElementInt(TArray<int32_t> Array)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.RandomElementInt");
		
		UOnyxFunctionLibrary_RandomElementInt_Params params {};
		params.Array = Array;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.RandomElementFloat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<float>                                      Array                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	float UOnyxFunctionLibrary::RandomElementFloat(TArray<float> Array)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.RandomElementFloat");
		
		UOnyxFunctionLibrary_RandomElementFloat_Params params {};
		params.Array = Array;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.KeyToNumberZeroBased
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UOnyxFunctionLibrary::KeyToNumberZeroBased(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.KeyToNumberZeroBased");
		
		UOnyxFunctionLibrary_KeyToNumberZeroBased_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.KeyToNumberOneBased
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UOnyxFunctionLibrary::KeyToNumberOneBased(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.KeyToNumberOneBased");
		
		UOnyxFunctionLibrary_KeyToNumberOneBased_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.KeyMappingToChord
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputActionKeyMapping                      Mapping                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FInputChord UOnyxFunctionLibrary::KeyMappingToChord(const struct FInputActionKeyMapping& Mapping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.KeyMappingToChord");
		
		UOnyxFunctionLibrary_KeyMappingToChord_Params params {};
		params.Mapping = Mapping;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.JoinStringsRemoveEmpty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      A                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      B                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Separator                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UOnyxFunctionLibrary::JoinStringsRemoveEmpty(const class FString& A, const class FString& B, const class FString& Separator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.JoinStringsRemoveEmpty");
		
		UOnyxFunctionLibrary_JoinStringsRemoveEmpty_Params params {};
		params.A = A;
		params.B = B;
		params.Separator = Separator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.IsHandled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FEventReply                                 Reply                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UOnyxFunctionLibrary::IsHandled(const struct FEventReply& Reply)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.IsHandled");
		
		UOnyxFunctionLibrary_IsHandled_Params params {};
		params.Reply = Reply;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.IsAxisPressKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnyxFunctionLibrary::IsAxisPressKey(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.IsAxisPressKey");
		
		UOnyxFunctionLibrary_IsAxisPressKey_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.GetStaticMeshSocketTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SocketName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERelativeTransformSpace                            TransformSpace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform UOnyxFunctionLibrary::GetStaticMeshSocketTransform(class AActor* Actor, const class FName& SocketName, ERelativeTransformSpace TransformSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.GetStaticMeshSocketTransform");
		
		UOnyxFunctionLibrary_GetStaticMeshSocketTransform_Params params {};
		params.Actor = Actor;
		params.SocketName = SocketName;
		params.TransformSpace = TransformSpace;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.GetSelfOrOuterActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AActor* UOnyxFunctionLibrary::GetSelfOrOuterActor(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.GetSelfOrOuterActor");
		
		UOnyxFunctionLibrary_GetSelfOrOuterActor_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.GetPointerEventChord
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPointerEvent                               Event                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FInputChord UOnyxFunctionLibrary::GetPointerEventChord(const struct FPointerEvent& Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.GetPointerEventChord");
		
		UOnyxFunctionLibrary_GetPointerEventChord_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.GetKeyEventChord
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKeyEvent                                   Event                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FInputChord UOnyxFunctionLibrary::GetKeyEventChord(const struct FKeyEvent& Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.GetKeyEventChord");
		
		UOnyxFunctionLibrary_GetKeyEventChord_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.GetComponentByClassSafe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ComponentClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UActorComponent* UOnyxFunctionLibrary::GetComponentByClassSafe(class AActor* Actor, class UClass* ComponentClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.GetComponentByClassSafe");
		
		UOnyxFunctionLibrary_GetComponentByClassSafe_Params params {};
		params.Actor = Actor;
		params.ComponentClass = ComponentClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.FormatIntToFit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxCharacters                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UOnyxFunctionLibrary::FormatIntToFit(int32_t Value, int32_t MaxCharacters)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.FormatIntToFit");
		
		UOnyxFunctionLibrary_FormatIntToFit_Params params {};
		params.Value = Value;
		params.MaxCharacters = MaxCharacters;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.FindDeltaAngleRadians
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              A1                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              A2                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UOnyxFunctionLibrary::FindDeltaAngleRadians(float A1, float A2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.FindDeltaAngleRadians");
		
		UOnyxFunctionLibrary_FindDeltaAngleRadians_Params params {};
		params.A1 = A1;
		params.A2 = A2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.FindDeltaAngleDegrees
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              A1                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              A2                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UOnyxFunctionLibrary::FindDeltaAngleDegrees(float A1, float A2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.FindDeltaAngleDegrees");
		
		UOnyxFunctionLibrary_FindDeltaAngleDegrees_Params params {};
		params.A1 = A1;
		params.A2 = A2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.CoalesceClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* UOnyxFunctionLibrary::CoalesceClass(class UClass* A, class UClass* B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.CoalesceClass");
		
		UOnyxFunctionLibrary_CoalesceClass_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OnyxFunctionLibrary.AddIntVectors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FIntVector                                  A                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FIntVector                                  B                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FIntVector UOnyxFunctionLibrary::AddIntVectors(const struct FIntVector& A, const struct FIntVector& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OnyxFunctionLibrary.AddIntVectors");
		
		UOnyxFunctionLibrary_AddIntVectors_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOnyxFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOnyxFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.OnyxFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOptionsDropdownBaseAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOptionsDropdownBaseAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.OptionsDropdownBaseAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOptionsKeybindingListItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOptionsKeybindingListItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.OptionsKeybindingListItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOptionsKeybindingsPopulator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOptionsKeybindingsPopulator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.OptionsKeybindingsPopulator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.SetAllToDefaults
	 * 		Flags  -> ()
	 */
	void UOptionsMenuWidget::SetAllToDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.SetAllToDefaults");
		
		UOptionsMenuWidget_SetAllToDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.RevertPageSettings
	 * 		Flags  -> ()
	 */
	void UOptionsMenuWidget::RevertPageSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.RevertPageSettings");
		
		UOptionsMenuWidget_RevertPageSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.RevertCachedAndUnconfirmedSettings
	 * 		Flags  -> ()
	 */
	void UOptionsMenuWidget::RevertCachedAndUnconfirmedSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.RevertCachedAndUnconfirmedSettings");
		
		UOptionsMenuWidget_RevertCachedAndUnconfirmedSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.RemoveControlMappings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FAnyControlMapping>                  Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UOptionsMenuWidget::RemoveControlMappings(TArray<struct FAnyControlMapping> Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.RemoveControlMappings");
		
		UOptionsMenuWidget_RemoveControlMappings_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.RemoveAxisMappings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FInputAxisKeyMapping>                Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UOptionsMenuWidget::RemoveAxisMappings(TArray<struct FInputAxisKeyMapping> Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.RemoveAxisMappings");
		
		UOptionsMenuWidget_RemoveAxisMappings_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.RemoveActionMappings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FInputActionKeyMapping>              Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UOptionsMenuWidget::RemoveActionMappings(TArray<struct FInputActionKeyMapping> Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.RemoveActionMappings");
		
		UOptionsMenuWidget_RemoveActionMappings_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.PageHasUnsavedChanges
	 * 		Flags  -> ()
	 */
	bool UOptionsMenuWidget::PageHasUnsavedChanges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.PageHasUnsavedChanges");
		
		UOptionsMenuWidget_PageHasUnsavedChanges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.OnPrevTab
	 * 		Flags  -> ()
	 */
	void UOptionsMenuWidget::OnPrevTab()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.OnPrevTab");
		
		UOptionsMenuWidget_OnPrevTab_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.OnNextTab
	 * 		Flags  -> ()
	 */
	void UOptionsMenuWidget::OnNextTab()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.OnNextTab");
		
		UOptionsMenuWidget_OnNextTab_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.OnFSRQualitySelectionChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SelectedItem                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESelectInfo                                        SelectionType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOptionsMenuWidget::OnFSRQualitySelectionChanged(const class FString& SelectedItem, ESelectInfo SelectionType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.OnFSRQualitySelectionChanged");
		
		UOptionsMenuWidget_OnFSRQualitySelectionChanged_Params params {};
		params.SelectedItem = SelectedItem;
		params.SelectionType = SelectionType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.OnCategoryChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOptionsMenuWidget::OnCategoryChanged(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.OnCategoryChanged");
		
		UOptionsMenuWidget_OnCategoryChanged_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.OnCategoryButtonPressed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOptionsMenuWidget::OnCategoryButtonPressed(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.OnCategoryButtonPressed");
		
		UOptionsMenuWidget_OnCategoryButtonPressed_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.NativeClampQualitySelectionToSafeValue
	 * 		Flags  -> ()
	 */
	void UOptionsMenuWidget::NativeClampQualitySelectionToSafeValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.NativeClampQualitySelectionToSafeValue");
		
		UOptionsMenuWidget_NativeClampQualitySelectionToSafeValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.HasAnyUnsavedChanges
	 * 		Flags  -> ()
	 */
	bool UOptionsMenuWidget::HasAnyUnsavedChanges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.HasAnyUnsavedChanges");
		
		UOptionsMenuWidget_HasAnyUnsavedChanges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.HandleUnsafeQualitySelection
	 * 		Flags  -> ()
	 */
	void UOptionsMenuWidget::HandleUnsafeQualitySelection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.HandleUnsafeQualitySelection");
		
		UOptionsMenuWidget_HandleUnsafeQualitySelection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.FindConflicts
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAnyControlMapping                          Mapping                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FAnyControlMapping> UOptionsMenuWidget::FindConflicts(const struct FAnyControlMapping& Mapping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.FindConflicts");
		
		UOptionsMenuWidget_FindConflicts_Params params {};
		params.Mapping = Mapping;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.ApplyPageSettings
	 * 		Flags  -> ()
	 */
	void UOptionsMenuWidget::ApplyPageSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.ApplyPageSettings");
		
		UOptionsMenuWidget_ApplyPageSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OptionsMenuWidget.ApplyAllSettings
	 * 		Flags  -> ()
	 */
	void UOptionsMenuWidget::ApplyAllSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OptionsMenuWidget.ApplyAllSettings");
		
		UOptionsMenuWidget_ApplyAllSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOptionsMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOptionsMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.OptionsMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AParticleAttachmentBlockingVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AParticleAttachmentBlockingVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ParticleAttachmentBlockingVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ParticleAttachmentVolume.OnBeginPlay
	 * 		Flags  -> ()
	 */
	void AParticleAttachmentVolume::OnBeginPlay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ParticleAttachmentVolume.OnBeginPlay");
		
		AParticleAttachmentVolume_OnBeginPlay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ParticleAttachmentVolume.IsVolumeReachableByPhotoMode
	 * 		Flags  -> ()
	 */
	bool AParticleAttachmentVolume::IsVolumeReachableByPhotoMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ParticleAttachmentVolume.IsVolumeReachableByPhotoMode");
		
		AParticleAttachmentVolume_IsVolumeReachableByPhotoMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ParticleAttachmentVolume.IsNiagaraActivationAllowed
	 * 		Flags  -> ()
	 */
	bool AParticleAttachmentVolume::IsNiagaraActivationAllowed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ParticleAttachmentVolume.IsNiagaraActivationAllowed");
		
		AParticleAttachmentVolume_IsNiagaraActivationAllowed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ParticleAttachmentVolume.IsLocalPlayerInVolume
	 * 		Flags  -> ()
	 */
	bool AParticleAttachmentVolume::IsLocalPlayerInVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ParticleAttachmentVolume.IsLocalPlayerInVolume");
		
		AParticleAttachmentVolume_IsLocalPlayerInVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AParticleAttachmentVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AParticleAttachmentVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ParticleAttachmentVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ParticleSystemSpawnComponent.SpawnParticleSystem
	 * 		Flags  -> ()
	 */
	void UParticleSystemSpawnComponent::SpawnParticleSystem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ParticleSystemSpawnComponent.SpawnParticleSystem");
		
		UParticleSystemSpawnComponent_SpawnParticleSystem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleSystemSpawnComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleSystemSpawnComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ParticleSystemSpawnComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.UpdateResearchPointData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PreviousAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::UpdateResearchPointData(int32_t PreviousAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.UpdateResearchPointData");
		
		UPartyComponent_UpdateResearchPointData_Params params {};
		params.PreviousAmount = PreviousAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.SetPlayerIdentityViaPlayerState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPlayerCharacterIdentity                           PlayerIdentity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::SetPlayerIdentityViaPlayerState(class APlayerState* PlayerState, EPlayerCharacterIdentity PlayerIdentity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.SetPlayerIdentityViaPlayerState");
		
		UPartyComponent_SetPlayerIdentityViaPlayerState_Params params {};
		params.PlayerState = PlayerState;
		params.PlayerIdentity = PlayerIdentity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ServerViewTutorial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TutorialRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::ServerViewTutorial(const struct FDataTableRowHandle& TutorialRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ServerViewTutorial");
		
		UPartyComponent_ServerViewTutorial_Params params {};
		params.TutorialRowHandle = TutorialRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ServerUseTechTreeKeyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerController*                   Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::ServerUseTechTreeKeyItem(class UItem* Item, class ASurvivalPlayerController* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ServerUseTechTreeKeyItem");
		
		UPartyComponent_ServerUseTechTreeKeyItem_Params params {};
		params.Item = Item;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ServerUnlockTechTree
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TechTreeRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerController*                   Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::ServerUnlockTechTree(const struct FDataTableRowHandle& TechTreeRowHandle, class ASurvivalPlayerController* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ServerUnlockTechTree");
		
		UPartyComponent_ServerUnlockTechTree_Params params {};
		params.TechTreeRowHandle = TechTreeRowHandle;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ServerUnlockItemStackUpgradeTier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                ItemStackTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AquirerPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreCost                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::ServerUnlockItemStackUpgradeTier(const struct FGameplayTag& ItemStackTag, class ASurvivalPlayerState* AquirerPlayerState, bool bIgnoreCost)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ServerUnlockItemStackUpgradeTier");
		
		UPartyComponent_ServerUnlockItemStackUpgradeTier_Params params {};
		params.ItemStackTag = ItemStackTag;
		params.AquirerPlayerState = AquirerPlayerState;
		params.bIgnoreCost = bIgnoreCost;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ServerSpendPointsOnTechTreeUnlock
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TechTreeRecipeRowHandle                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Points                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerController*                   Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::ServerSpendPointsOnTechTreeUnlock(const struct FDataTableRowHandle& TechTreeRecipeRowHandle, int32_t Points, class ASurvivalPlayerController* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ServerSpendPointsOnTechTreeUnlock");
		
		UPartyComponent_ServerSpendPointsOnTechTreeUnlock_Params params {};
		params.TechTreeRecipeRowHandle = TechTreeRecipeRowHandle;
		params.Points = Points;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ServerSetTutorialComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TutorialRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::ServerSetTutorialComplete(const struct FDataTableRowHandle& TutorialRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ServerSetTutorialComplete");
		
		UPartyComponent_ServerSetTutorialComplete_Params params {};
		params.TutorialRowHandle = TutorialRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ServerRemoveScience
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ScienceAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::ServerRemoveScience(int32_t ScienceAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ServerRemoveScience");
		
		UPartyComponent_ServerRemoveScience_Params params {};
		params.ScienceAmount = ScienceAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ServerRemoveKeyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::ServerRemoveKeyItem(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ServerRemoveKeyItem");
		
		UPartyComponent_ServerRemoveKeyItem_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ServerPurchaseRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TechTreeRecipeRowHandle                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerController*                   Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::ServerPurchaseRecipe(const struct FDataTableRowHandle& TechTreeRecipeRowHandle, class ASurvivalPlayerController* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ServerPurchaseRecipe");
		
		UPartyComponent_ServerPurchaseRecipe_Params params {};
		params.TechTreeRecipeRowHandle = TechTreeRecipeRowHandle;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ServerCreateAndAddKeyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerCharacter*                    Acquirer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHideNotification                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::ServerCreateAndAddKeyItem(const struct FDataTableRowHandle& ItemRowHandle, class ASurvivalPlayerCharacter* Acquirer, bool bHideNotification)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ServerCreateAndAddKeyItem");
		
		UPartyComponent_ServerCreateAndAddKeyItem_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.Acquirer = Acquirer;
		params.bHideNotification = bHideNotification;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ServerAddScienceFound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ScienceAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::ServerAddScienceFound(int32_t ScienceAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ServerAddScienceFound");
		
		UPartyComponent_ServerAddScienceFound_Params params {};
		params.ScienceAmount = ScienceAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ServerAddKeyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerCharacter*                    Acquirer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHideNotification                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::ServerAddKeyItem(class UItem* Item, class ASurvivalPlayerCharacter* Acquirer, bool bHideNotification)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ServerAddKeyItem");
		
		UPartyComponent_ServerAddKeyItem_Params params {};
		params.Item = Item;
		params.Acquirer = Acquirer;
		params.bHideNotification = bHideNotification;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.RestParty
	 * 		Flags  -> ()
	 */
	void UPartyComponent::RestParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.RestParty");
		
		UPartyComponent_RestParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ResetPlayerIdentities
	 * 		Flags  -> ()
	 */
	void UPartyComponent::ResetPlayerIdentities()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ResetPlayerIdentities");
		
		UPartyComponent_ResetPlayerIdentities_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.RecipeCraftedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInventoryComponent*                         Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         RecipeRow                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::RecipeCraftedCallback(class UInventoryComponent* Sender, const struct FDataTableRowHandle& RecipeRow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.RecipeCraftedCallback");
		
		UPartyComponent_RecipeCraftedCallback_Params params {};
		params.Sender = Sender;
		params.RecipeRow = RecipeRow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.OnRep_TechUnlockDatas
	 * 		Flags  -> ()
	 */
	void UPartyComponent::OnRep_TechUnlockDatas()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.OnRep_TechUnlockDatas");
		
		UPartyComponent_OnRep_TechUnlockDatas_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.OnRep_ScienceFound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PreviousScienceFound                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::OnRep_ScienceFound(int32_t PreviousScienceFound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.OnRep_ScienceFound");
		
		UPartyComponent_OnRep_ScienceFound_Params params {};
		params.PreviousScienceFound = PreviousScienceFound;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.OnRep_RestingPartyMembers
	 * 		Flags  -> ()
	 */
	void UPartyComponent::OnRep_RestingPartyMembers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.OnRep_RestingPartyMembers");
		
		UPartyComponent_OnRep_RestingPartyMembers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.OnRep_ResearchPointsAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PreviousAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::OnRep_ResearchPointsAdded(int32_t PreviousAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.OnRep_ResearchPointsAdded");
		
		UPartyComponent_OnRep_ResearchPointsAdded_Params params {};
		params.PreviousAmount = PreviousAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.OnRep_KnownRecipesChanged
	 * 		Flags  -> ()
	 */
	void UPartyComponent::OnRep_KnownRecipesChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.OnRep_KnownRecipesChanged");
		
		UPartyComponent_OnRep_KnownRecipesChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.OnRep_ItemStackUpgrades
	 * 		Flags  -> ()
	 */
	void UPartyComponent::OnRep_ItemStackUpgrades()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.OnRep_ItemStackUpgrades");
		
		UPartyComponent_OnRep_ItemStackUpgrades_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.OnRep_ItemKnowledge
	 * 		Flags  -> ()
	 */
	void UPartyComponent::OnRep_ItemKnowledge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.OnRep_ItemKnowledge");
		
		UPartyComponent_OnRep_ItemKnowledge_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.OnRep_AssignedPlayerIdentities
	 * 		Flags  -> ()
	 */
	void UPartyComponent::OnRep_AssignedPlayerIdentities()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.OnRep_AssignedPlayerIdentities");
		
		UPartyComponent_OnRep_AssignedPlayerIdentities_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.NotifyCreatureKillCredit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Creature                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::NotifyCreatureKillCredit(class ASurvivalCharacter* Creature, class ASurvivalPlayerState* Killer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.NotifyCreatureKillCredit");
		
		UPartyComponent_NotifyCreatureKillCredit_Params params {};
		params.Creature = Creature;
		params.Killer = Killer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.MulticastUpgradePointsAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsPartyUpgradePoints                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AquirerPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::MulticastUpgradePointsAdded(bool IsPartyUpgradePoints, int32_t Amount, class ASurvivalPlayerState* AquirerPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.MulticastUpgradePointsAdded");
		
		UPartyComponent_MulticastUpgradePointsAdded_Params params {};
		params.IsPartyUpgradePoints = IsPartyUpgradePoints;
		params.Amount = Amount;
		params.AquirerPlayerState = AquirerPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.MulticastTechUnlockDataUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TechUnlockDataRowHandle                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        UnlockerPlayerState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::MulticastTechUnlockDataUnlocked(const struct FDataTableRowHandle& TechUnlockDataRowHandle, class ASurvivalPlayerState* UnlockerPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.MulticastTechUnlockDataUnlocked");
		
		UPartyComponent_MulticastTechUnlockDataUnlocked_Params params {};
		params.TechUnlockDataRowHandle = TechUnlockDataRowHandle;
		params.UnlockerPlayerState = UnlockerPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.MulticastTechTreeUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TechTreeRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        UnlockerPlayerState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::MulticastTechTreeUnlocked(const struct FDataTableRowHandle& TechTreeRowHandle, class ASurvivalPlayerState* UnlockerPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.MulticastTechTreeUnlocked");
		
		UPartyComponent_MulticastTechTreeUnlocked_Params params {};
		params.TechTreeRowHandle = TechTreeRowHandle;
		params.UnlockerPlayerState = UnlockerPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.MulticastStartRestParty
	 * 		Flags  -> ()
	 */
	void UPartyComponent::MulticastStartRestParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.MulticastStartRestParty");
		
		UPartyComponent_MulticastStartRestParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.MulticastPointOfInterestDiscovered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPointOfInterestDataAsset*                   ColorTheme                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        UnlockerPlayerState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::MulticastPointOfInterestDiscovered(class UPointOfInterestDataAsset* ColorTheme, class ASurvivalPlayerState* UnlockerPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.MulticastPointOfInterestDiscovered");
		
		UPartyComponent_MulticastPointOfInterestDiscovered_Params params {};
		params.ColorTheme = ColorTheme;
		params.UnlockerPlayerState = UnlockerPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.MulticastNotifyResourceResearched
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AcquirerPlayerState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDataTableRowHandle>                 RecipesLearned                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::MulticastNotifyResourceResearched(const struct FDataTableRowHandle& ItemRowHandle, class ASurvivalPlayerState* AcquirerPlayerState, TArray<struct FDataTableRowHandle> RecipesLearned)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.MulticastNotifyResourceResearched");
		
		UPartyComponent_MulticastNotifyResourceResearched_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.AcquirerPlayerState = AcquirerPlayerState;
		params.RecipesLearned = RecipesLearned;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.MulticastNotifyNewResourceKnown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AcquirerPlayerState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDataTableRowHandle>                 RecipesLearned                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::MulticastNotifyNewResourceKnown(const struct FDataTableRowHandle& ItemRowHandle, class ASurvivalPlayerState* AcquirerPlayerState, TArray<struct FDataTableRowHandle> RecipesLearned)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.MulticastNotifyNewResourceKnown");
		
		UPartyComponent_MulticastNotifyNewResourceKnown_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.AcquirerPlayerState = AcquirerPlayerState;
		params.RecipesLearned = RecipesLearned;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.MulticastNotifyNewRecipesKnownCoziness
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 RecipeRowHandles                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AcquirerPlayerState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CozinessLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::MulticastNotifyNewRecipesKnownCoziness(TArray<struct FDataTableRowHandle> RecipeRowHandles, class ASurvivalPlayerState* AcquirerPlayerState, int32_t CozinessLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.MulticastNotifyNewRecipesKnownCoziness");
		
		UPartyComponent_MulticastNotifyNewRecipesKnownCoziness_Params params {};
		params.RecipeRowHandles = RecipeRowHandles;
		params.AcquirerPlayerState = AcquirerPlayerState;
		params.CozinessLevel = CozinessLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.MulticastNotifyNewRecipesKnown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 RecipeRowHandles                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AcquirerPlayerState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERecipeUnlockSource                                RecipeUnlockSource                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLocString                                  DisplayName                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::MulticastNotifyNewRecipesKnown(TArray<struct FDataTableRowHandle> RecipeRowHandles, class ASurvivalPlayerState* AcquirerPlayerState, ERecipeUnlockSource RecipeUnlockSource, const struct FLocString& DisplayName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.MulticastNotifyNewRecipesKnown");
		
		UPartyComponent_MulticastNotifyNewRecipesKnown_Params params {};
		params.RecipeRowHandles = RecipeRowHandles;
		params.AcquirerPlayerState = AcquirerPlayerState;
		params.RecipeUnlockSource = RecipeUnlockSource;
		params.DisplayName = DisplayName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.MulticastNotifyNewRecipeKnown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AcquirerPlayerState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::MulticastNotifyNewRecipeKnown(const struct FDataTableRowHandle& RecipeRowHandle, class ASurvivalPlayerState* AcquirerPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.MulticastNotifyNewRecipeKnown");
		
		UPartyComponent_MulticastNotifyNewRecipeKnown_Params params {};
		params.RecipeRowHandle = RecipeRowHandle;
		params.AcquirerPlayerState = AcquirerPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.MulticastNotifyKeyItemCollected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AcquirerPlayerState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDataTableRowHandle>                 RecipesLearned                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::MulticastNotifyKeyItemCollected(const struct FDataTableRowHandle& ItemRowHandle, class ASurvivalPlayerState* AcquirerPlayerState, TArray<struct FDataTableRowHandle> RecipesLearned)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.MulticastNotifyKeyItemCollected");
		
		UPartyComponent_MulticastNotifyKeyItemCollected_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.AcquirerPlayerState = AcquirerPlayerState;
		params.RecipesLearned = RecipesLearned;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.MulticastItemStackUpgradeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                ItemStackTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AquirerPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::MulticastItemStackUpgradeChanged(const struct FGameplayTag& ItemStackTag, class ASurvivalPlayerState* AquirerPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.MulticastItemStackUpgradeChanged");
		
		UPartyComponent_MulticastItemStackUpgradeChanged_Params params {};
		params.ItemStackTag = ItemStackTag;
		params.AquirerPlayerState = AquirerPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.MulticastColorThemeDiscovered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      PointOfInterest                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        UnlockerPlayerState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::MulticastColorThemeDiscovered(class UClass* PointOfInterest, class ASurvivalPlayerState* UnlockerPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.MulticastColorThemeDiscovered");
		
		UPartyComponent_MulticastColorThemeDiscovered_Params params {};
		params.PointOfInterest = PointOfInterest;
		params.UnlockerPlayerState = UnlockerPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.KnowsResourceName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::KnowsResourceName(const class FName& ItemName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.KnowsResourceName");
		
		UPartyComponent_KnowsResourceName_Params params {};
		params.ItemName = ItemName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.KnowsResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::KnowsResource(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.KnowsResource");
		
		UPartyComponent_KnowsResource_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.KnowsRecipeForIngredient
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::KnowsRecipeForIngredient(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.KnowsRecipeForIngredient");
		
		UPartyComponent_KnowsRecipeForIngredient_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.KnowsRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeHidden                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::KnowsRecipe(const struct FDataTableRowHandle& RecipeRowHandle, bool bIncludeHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.KnowsRecipe");
		
		UPartyComponent_KnowsRecipe_Params params {};
		params.RecipeRowHandle = RecipeRowHandle;
		params.bIncludeHidden = bIncludeHidden;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.KnowsOtherRecipeThatContainsIngredientRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::KnowsOtherRecipeThatContainsIngredientRecipe(const struct FDataTableRowHandle& RecipeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.KnowsOtherRecipeThatContainsIngredientRecipe");
		
		UPartyComponent_KnowsOtherRecipeThatContainsIngredientRecipe_Params params {};
		params.RecipeRowHandle = RecipeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.KnowsOtherRecipeThatContainsIngredient
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         IngredientRowHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::KnowsOtherRecipeThatContainsIngredient(const struct FDataTableRowHandle& IngredientRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.KnowsOtherRecipeThatContainsIngredient");
		
		UPartyComponent_KnowsOtherRecipeThatContainsIngredient_Params params {};
		params.IngredientRowHandle = IngredientRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.KnowsOfRecipeIngredient
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         IngredientRowHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::KnowsOfRecipeIngredient(const struct FDataTableRowHandle& IngredientRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.KnowsOfRecipeIngredient");
		
		UPartyComponent_KnowsOfRecipeIngredient_Params params {};
		params.IngredientRowHandle = IngredientRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.KnowsCraftingRecipeForIngredient
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         IngredientRowHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::KnowsCraftingRecipeForIngredient(const struct FDataTableRowHandle& IngredientRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.KnowsCraftingRecipeForIngredient");
		
		UPartyComponent_KnowsCraftingRecipeForIngredient_Params params {};
		params.IngredientRowHandle = IngredientRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.KnowsCraftingRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeHidden                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::KnowsCraftingRecipe(const struct FDataTableRowHandle& RecipeRowHandle, bool bIncludeHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.KnowsCraftingRecipe");
		
		UPartyComponent_KnowsCraftingRecipe_Params params {};
		params.RecipeRowHandle = RecipeRowHandle;
		params.bIncludeHidden = bIncludeHidden;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.KnowsBuildingRecipeForIngredient
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         IngredientRowHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::KnowsBuildingRecipeForIngredient(const struct FDataTableRowHandle& IngredientRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.KnowsBuildingRecipeForIngredient");
		
		UPartyComponent_KnowsBuildingRecipeForIngredient_Params params {};
		params.IngredientRowHandle = IngredientRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.KnowsBuildingRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeHidden                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::KnowsBuildingRecipe(const struct FDataTableRowHandle& RecipeRowHandle, bool bIncludeHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.KnowsBuildingRecipe");
		
		UPartyComponent_KnowsBuildingRecipe_Params params {};
		params.RecipeRowHandle = RecipeRowHandle;
		params.bIncludeHidden = bIncludeHidden;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.IsTechTreeRecipeUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TechTreeRecipeRowHandle                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::IsTechTreeRecipeUnlocked(const struct FDataTableRowHandle& TechTreeRecipeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.IsTechTreeRecipeUnlocked");
		
		UPartyComponent_IsTechTreeRecipeUnlocked_Params params {};
		params.TechTreeRecipeRowHandle = TechTreeRecipeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.IsRestOnCooldown
	 * 		Flags  -> ()
	 */
	bool UPartyComponent::IsRestOnCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.IsRestOnCooldown");
		
		UPartyComponent_IsRestOnCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.IsAnyPartyMemberInRange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::IsAnyPartyMemberInRange(const struct FVector& Location, float Range)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.IsAnyPartyMemberInRange");
		
		UPartyComponent_IsAnyPartyMemberInRange_Params params {};
		params.Location = Location;
		params.Range = Range;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.HasResearchedResourceName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ItemRowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::HasResearchedResourceName(const class FName& ItemRowName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.HasResearchedResourceName");
		
		UPartyComponent_HasResearchedResourceName_Params params {};
		params.ItemRowName = ItemRowName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.HasResearchedResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::HasResearchedResource(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.HasResearchedResource");
		
		UPartyComponent_HasResearchedResource_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.HasKeyItemSubcategory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                KeyItemCategory                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                KeyItemSubCategory                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::HasKeyItemSubcategory(const struct FGameplayTag& KeyItemCategory, const struct FGameplayTag& KeyItemSubCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.HasKeyItemSubcategory");
		
		UPartyComponent_HasKeyItemSubcategory_Params params {};
		params.KeyItemCategory = KeyItemCategory;
		params.KeyItemSubCategory = KeyItemSubCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.HasKeyItemCategory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                KeyItemCategory                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::HasKeyItemCategory(const struct FGameplayTag& KeyItemCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.HasKeyItemCategory");
		
		UPartyComponent_HasKeyItemCategory_Params params {};
		params.KeyItemCategory = KeyItemCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.HasKeyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::HasKeyItem(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.HasKeyItem");
		
		UPartyComponent_HasKeyItem_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetUnlockedTechTrees
	 * 		Flags  -> ()
	 */
	TArray<struct FDataTableRowHandle_NetCrc> UPartyComponent::GetUnlockedTechTrees()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetUnlockedTechTrees");
		
		UPartyComponent_GetUnlockedTechTrees_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetUnlockedSignSets
	 * 		Flags  -> ()
	 */
	TArray<struct FDataTableRowHandle_NetCrc> UPartyComponent::GetUnlockedSignSets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetUnlockedSignSets");
		
		UPartyComponent_GetUnlockedSignSets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetUnlockedPOIs
	 * 		Flags  -> ()
	 */
	TArray<class UPointOfInterestDataAsset*> UPartyComponent::GetUnlockedPOIs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetUnlockedPOIs");
		
		UPartyComponent_GetUnlockedPOIs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetUnlockedColorThemes
	 * 		Flags  -> ()
	 */
	TArray<class UClass*> UPartyComponent::GetUnlockedColorThemes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetUnlockedColorThemes");
		
		UPartyComponent_GetUnlockedColorThemes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetTotalPersonalUpgradePoints
	 * 		Flags  -> ()
	 */
	int32_t UPartyComponent::GetTotalPersonalUpgradePoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetTotalPersonalUpgradePoints");
		
		UPartyComponent_GetTotalPersonalUpgradePoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetTotalPartyUpgradePoints
	 * 		Flags  -> ()
	 */
	int32_t UPartyComponent::GetTotalPartyUpgradePoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetTotalPartyUpgradePoints");
		
		UPartyComponent_GetTotalPartyUpgradePoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetTechTreeKeyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bCheckUnlocked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UPartyComponent::GetTechTreeKeyItem(bool bCheckUnlocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetTechTreeKeyItem");
		
		UPartyComponent_GetTechTreeKeyItem_Params params {};
		params.bCheckUnlocked = bCheckUnlocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetTeamReputation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TeamRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UPartyComponent::GetTeamReputation(const struct FDataTableRowHandle& TeamRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetTeamReputation");
		
		UPartyComponent_GetTeamReputation_Params params {};
		params.TeamRowHandle = TeamRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetScienceFound
	 * 		Flags  -> ()
	 */
	int32_t UPartyComponent::GetScienceFound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetScienceFound");
		
		UPartyComponent_GetScienceFound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetRestCooldownRemaining
	 * 		Flags  -> ()
	 */
	float UPartyComponent::GetRestCooldownRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetRestCooldownRemaining");
		
		UPartyComponent_GetRestCooldownRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetResearchPoints
	 * 		Flags  -> ()
	 */
	int32_t UPartyComponent::GetResearchPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetResearchPoints");
		
		UPartyComponent_GetResearchPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetResearchLevel
	 * 		Flags  -> ()
	 */
	int32_t UPartyComponent::GetResearchLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetResearchLevel");
		
		UPartyComponent_GetResearchLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetReputation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                FactionTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPartyComponent::GetReputation(const struct FGameplayTag& FactionTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetReputation");
		
		UPartyComponent_GetReputation_Params params {};
		params.FactionTag = FactionTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetRemainingPartyUpgradePoints
	 * 		Flags  -> ()
	 */
	int32_t UPartyComponent::GetRemainingPartyUpgradePoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetRemainingPartyUpgradePoints");
		
		UPartyComponent_GetRemainingPartyUpgradePoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetRecipesUnlockedForResearchLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ResearchLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FDataTableRowHandle> UPartyComponent::GetRecipesUnlockedForResearchLevel(int32_t ResearchLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetRecipesUnlockedForResearchLevel");
		
		UPartyComponent_GetRecipesUnlockedForResearchLevel_Params params {};
		params.ResearchLevel = ResearchLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetRecipeForItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 Items                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                CraftingBuildingTag                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle UPartyComponent::GetRecipeForItems(TArray<struct FDataTableRowHandle> Items, const struct FGameplayTag& CraftingBuildingTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetRecipeForItems");
		
		UPartyComponent_GetRecipeForItems_Params params {};
		params.Items = Items;
		params.CraftingBuildingTag = CraftingBuildingTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetRecipeForIngredients
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRecipeRequirements>                 Requirements                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                CraftingBuildingTag                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle UPartyComponent::GetRecipeForIngredients(TArray<struct FRecipeRequirements> Requirements, const struct FGameplayTag& CraftingBuildingTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetRecipeForIngredients");
		
		UPartyComponent_GetRecipeForIngredients_Params params {};
		params.Requirements = Requirements;
		params.CraftingBuildingTag = CraftingBuildingTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetProgressTowardsNextResearchLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Points                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UPartyComponent::GetProgressTowardsNextResearchLevel(int32_t Points)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetProgressTowardsNextResearchLevel");
		
		UPartyComponent_GetProgressTowardsNextResearchLevel_Params params {};
		params.Points = Points;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetPointsSpentOnTechUnlock
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TechUnlockRowHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UPartyComponent::GetPointsSpentOnTechUnlock(const struct FDataTableRowHandle& TechUnlockRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetPointsSpentOnTechUnlock");
		
		UPartyComponent_GetPointsSpentOnTechUnlock_Params params {};
		params.TechUnlockRowHandle = TechUnlockRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetPointsRequiredForResearchLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Level                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPartyComponent::GetPointsRequiredForResearchLevel(int32_t Level)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetPointsRequiredForResearchLevel");
		
		UPartyComponent_GetPointsRequiredForResearchLevel_Params params {};
		params.Level = Level;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetPointsRequiredForNextResearchLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Points                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPartyComponent::GetPointsRequiredForNextResearchLevel(int32_t Points)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetPointsRequiredForNextResearchLevel");
		
		UPartyComponent_GetPointsRequiredForNextResearchLevel_Params params {};
		params.Points = Points;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetPlayerStateMatchingIdentity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerCharacterIdentity                           Identity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalPlayerState* UPartyComponent::GetPlayerStateMatchingIdentity(EPlayerCharacterIdentity Identity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetPlayerStateMatchingIdentity");
		
		UPartyComponent_GetPlayerStateMatchingIdentity_Params params {};
		params.Identity = Identity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetPlayerIdentityViaPlayerState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EPlayerCharacterIdentity UPartyComponent::GetPlayerIdentityViaPlayerState(class ASurvivalPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetPlayerIdentityViaPlayerState");
		
		UPartyComponent_GetPlayerIdentityViaPlayerState_Params params {};
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetPlayerIdentityViaController
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           PlayerController                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EPlayerCharacterIdentity UPartyComponent::GetPlayerIdentityViaController(class APlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetPlayerIdentityViaController");
		
		UPartyComponent_GetPlayerIdentityViaController_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetPlayerIdentity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUniqueNetIdRepl                            UniqueId                                                   (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EPlayerCharacterIdentity UPartyComponent::GetPlayerIdentity(const struct FUniqueNetIdRepl& UniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetPlayerIdentity");
		
		UPartyComponent_GetPlayerIdentity_Params params {};
		params.UniqueId = UniqueId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetPartyMembers
	 * 		Flags  -> ()
	 */
	TArray<class ASurvivalPlayerCharacter*> UPartyComponent::GetPartyMembers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetPartyMembers");
		
		UPartyComponent_GetPartyMembers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetNumTechTreeUnlocksPurchased
	 * 		Flags  -> ()
	 */
	int32_t UPartyComponent::GetNumTechTreeUnlocksPurchased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetNumTechTreeUnlocksPurchased");
		
		UPartyComponent_GetNumTechTreeUnlocksPurchased_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetNumTechDatasUnlockedForTreeRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TechTreeRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UPartyComponent::GetNumTechDatasUnlockedForTreeRowHandle(const struct FDataTableRowHandle& TechTreeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetNumTechDatasUnlockedForTreeRowHandle");
		
		UPartyComponent_GetNumTechDatasUnlockedForTreeRowHandle_Params params {};
		params.TechTreeRowHandle = TechTreeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetNumResearchedResources
	 * 		Flags  -> ()
	 */
	int32_t UPartyComponent::GetNumResearchedResources()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetNumResearchedResources");
		
		UPartyComponent_GetNumResearchedResources_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetNumPartyMembers
	 * 		Flags  -> ()
	 */
	int32_t UPartyComponent::GetNumPartyMembers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetNumPartyMembers");
		
		UPartyComponent_GetNumPartyMembers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetMaxSpeakingRangeSq
	 * 		Flags  -> ()
	 */
	float UPartyComponent::GetMaxSpeakingRangeSq()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetMaxSpeakingRangeSq");
		
		UPartyComponent_GetMaxSpeakingRangeSq_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetMaxSpeakingRange
	 * 		Flags  -> ()
	 */
	float UPartyComponent::GetMaxSpeakingRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetMaxSpeakingRange");
		
		UPartyComponent_GetMaxSpeakingRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetLastRestTime
	 * 		Flags  -> ()
	 */
	float UPartyComponent::GetLastRestTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetLastRestTime");
		
		UPartyComponent_GetLastRestTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetKnownResources
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                ItemTag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FDataTableRowHandle> UPartyComponent::GetKnownResources(const struct FGameplayTag& ItemTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetKnownResources");
		
		UPartyComponent_GetKnownResources_Params params {};
		params.ItemTag = ItemTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetKeyItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UPartyComponent::GetKeyItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetKeyItems");
		
		UPartyComponent_GetKeyItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetKeyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UItem* UPartyComponent::GetKeyItem(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetKeyItem");
		
		UPartyComponent_GetKeyItem_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetItemStackUpgradeTier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                ItemStackTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPartyComponent::GetItemStackUpgradeTier(const struct FGameplayTag& ItemStackTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetItemStackUpgradeTier");
		
		UPartyComponent_GetItemStackUpgradeTier_Params params {};
		params.ItemStackTag = ItemStackTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetItemStackUpgradeCost
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                ItemStackTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPartyComponent::GetItemStackUpgradeCost(const struct FGameplayTag& ItemStackTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetItemStackUpgradeCost");
		
		UPartyComponent_GetItemStackUpgradeCost_Params params {};
		params.ItemStackTag = ItemStackTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetItemStackUpgradeBonus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                ItemStackTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPartyComponent::GetItemStackUpgradeBonus(const struct FGameplayTag& ItemStackTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetItemStackUpgradeBonus");
		
		UPartyComponent_GetItemStackUpgradeBonus_Params params {};
		params.ItemStackTag = ItemStackTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetItemResearchPoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                RarityTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPartyComponent::GetItemResearchPoints(const struct FGameplayTag& RarityTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetItemResearchPoints");
		
		UPartyComponent_GetItemResearchPoints_Params params {};
		params.RarityTag = RarityTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetHighestReputation
	 * 		Flags  -> ()
	 */
	struct FGameplayTag UPartyComponent::GetHighestReputation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetHighestReputation");
		
		UPartyComponent_GetHighestReputation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetFirstPartyMemberByIdentity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerCharacterIdentity                           Identity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalPlayerCharacter* UPartyComponent::GetFirstPartyMemberByIdentity(EPlayerCharacterIdentity Identity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetFirstPartyMemberByIdentity");
		
		UPartyComponent_GetFirstPartyMemberByIdentity_Params params {};
		params.Identity = Identity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetEssentialBuildings
	 * 		Flags  -> ()
	 */
	TArray<class ABuilding*> UPartyComponent::GetEssentialBuildings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetEssentialBuildings");
		
		UPartyComponent_GetEssentialBuildings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetCurrentResearchLevelForPointTotal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Points                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPartyComponent::GetCurrentResearchLevelForPointTotal(int32_t Points)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetCurrentResearchLevelForPointTotal");
		
		UPartyComponent_GetCurrentResearchLevelForPointTotal_Params params {};
		params.Points = Points;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetCraftingRecipesWithIngredient
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         IngredientRowHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               OnlyIncludeKnownRecipes                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FDataTableRowHandle> UPartyComponent::GetCraftingRecipesWithIngredient(const struct FDataTableRowHandle& IngredientRowHandle, bool OnlyIncludeKnownRecipes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetCraftingRecipesWithIngredient");
		
		UPartyComponent_GetCraftingRecipesWithIngredient_Params params {};
		params.IngredientRowHandle = IngredientRowHandle;
		params.OnlyIncludeKnownRecipes = OnlyIncludeKnownRecipes;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetClosestPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalPlayerCharacter* UPartyComponent::GetClosestPlayer(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetClosestPlayer");
		
		UPartyComponent_GetClosestPlayer_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetClosestPartyMemberDistanceSquared
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UPartyComponent::GetClosestPartyMemberDistanceSquared(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetClosestPartyMemberDistanceSquared");
		
		UPartyComponent_GetClosestPartyMemberDistanceSquared_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetBuildingRecipesWithIngredient
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         IngredientRowHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               OnlyIncludeKnownRecipes                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FDataTableRowHandle> UPartyComponent::GetBuildingRecipesWithIngredient(const struct FDataTableRowHandle& IngredientRowHandle, bool OnlyIncludeKnownRecipes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetBuildingRecipesWithIngredient");
		
		UPartyComponent_GetBuildingRecipesWithIngredient_Params params {};
		params.IngredientRowHandle = IngredientRowHandle;
		params.OnlyIncludeKnownRecipes = OnlyIncludeKnownRecipes;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetBonusScienceForResearchLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ResearchLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPartyComponent::GetBonusScienceForResearchLevel(int32_t ResearchLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetBonusScienceForResearchLevel");
		
		UPartyComponent_GetBonusScienceForResearchLevel_Params params {};
		params.ResearchLevel = ResearchLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetBestiaryHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         BestiaryRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	float UPartyComponent::GetBestiaryHealth(const struct FDataTableRowHandle& BestiaryRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetBestiaryHealth");
		
		UPartyComponent_GetBestiaryHealth_Params params {};
		params.BestiaryRowHandle = BestiaryRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetBestiaryDamageWeaknesses
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         BestiaryRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	TArray<ESurvivalDamageTypeFlags> UPartyComponent::GetBestiaryDamageWeaknesses(const struct FDataTableRowHandle& BestiaryRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetBestiaryDamageWeaknesses");
		
		UPartyComponent_GetBestiaryDamageWeaknesses_Params params {};
		params.BestiaryRowHandle = BestiaryRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.GetBestiaryDamageResistances
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         BestiaryRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	TArray<ESurvivalDamageTypeFlags> UPartyComponent::GetBestiaryDamageResistances(const struct FDataTableRowHandle& BestiaryRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.GetBestiaryDamageResistances");
		
		UPartyComponent_GetBestiaryDamageResistances_Params params {};
		params.BestiaryRowHandle = BestiaryRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.FreePlayerIdentityViaPlayerController
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           PlayerController                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::FreePlayerIdentityViaPlayerController(class APlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.FreePlayerIdentityViaPlayerController");
		
		UPartyComponent_FreePlayerIdentityViaPlayerController_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.FinishRestSequence
	 * 		Flags  -> ()
	 */
	void UPartyComponent::FinishRestSequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.FinishRestSequence");
		
		UPartyComponent_FinishRestSequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.DiscoverPointOfInterestData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPointOfInterestDataAsset*                   PointOfInterestData                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerController*                   Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::DiscoverPointOfInterestData(class UPointOfInterestDataAsset* PointOfInterestData, class ASurvivalPlayerController* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.DiscoverPointOfInterestData");
		
		UPartyComponent_DiscoverPointOfInterestData_Params params {};
		params.PointOfInterestData = PointOfInterestData;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.DiscoverPointOfInterest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPointOfInterestComponent*                   PointOfInterest                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerController*                   Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::DiscoverPointOfInterest(class UPointOfInterestComponent* PointOfInterest, class ASurvivalPlayerController* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.DiscoverPointOfInterest");
		
		UPartyComponent_DiscoverPointOfInterest_Params params {};
		params.PointOfInterest = PointOfInterest;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.DiscoveredResourceName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::DiscoveredResourceName(const class FName& ItemName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.DiscoveredResourceName");
		
		UPartyComponent_DiscoveredResourceName_Params params {};
		params.ItemName = ItemName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.DiscoveredResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::DiscoveredResource(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.DiscoveredResource");
		
		UPartyComponent_DiscoveredResource_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.DiscoverColorTheme
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Theme                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerController*                   Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::DiscoverColorTheme(class UClass* Theme, class ASurvivalPlayerController* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.DiscoverColorTheme");
		
		UPartyComponent_DiscoverColorTheme_Params params {};
		params.Theme = Theme;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ClearTeamReputation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TeamRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::ClearTeamReputation(const struct FDataTableRowHandle& TeamRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ClearTeamReputation");
		
		UPartyComponent_ClearTeamReputation_Params params {};
		params.TeamRowHandle = TeamRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.ClearReputation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                FactionTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::ClearReputation(const struct FGameplayTag& FactionTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.ClearReputation");
		
		UPartyComponent_ClearReputation_Params params {};
		params.FactionTag = FactionTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.CanUpgradeItemStack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                ItemStackTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreCost                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::CanUpgradeItemStack(const struct FGameplayTag& ItemStackTag, bool bIgnoreCost)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.CanUpgradeItemStack");
		
		UPartyComponent_CanUpgradeItemStack_Params params {};
		params.ItemStackTag = ItemStackTag;
		params.bIgnoreCost = bIgnoreCost;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.AddUnlockedSignSet
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         SignSetDataHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::AddUnlockedSignSet(const struct FDataTableRowHandle& SignSetDataHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.AddUnlockedSignSet");
		
		UPartyComponent_AddUnlockedSignSet_Params params {};
		params.SignSetDataHandle = SignSetDataHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.AddTeamReputation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TeamRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::AddTeamReputation(const struct FDataTableRowHandle& TeamRowHandle, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.AddTeamReputation");
		
		UPartyComponent_AddTeamReputation_Params params {};
		params.TeamRowHandle = TeamRowHandle;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.AddScience
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ScienceAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::AddScience(int32_t ScienceAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.AddScience");
		
		UPartyComponent_AddScience_Params params {};
		params.ScienceAmount = ScienceAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.AddResearchedResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AquirerPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::AddResearchedResource(const struct FDataTableRowHandle& ItemRowHandle, class ASurvivalPlayerState* AquirerPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.AddResearchedResource");
		
		UPartyComponent_AddResearchedResource_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.AquirerPlayerState = AquirerPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.AddReputation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                FactionTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::AddReputation(const struct FGameplayTag& FactionTag, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.AddReputation");
		
		UPartyComponent_AddReputation_Params params {};
		params.FactionTag = FactionTag;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.AddPersonalUpgradePoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AquirerPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::AddPersonalUpgradePoints(int32_t Amount, class ASurvivalPlayerState* AquirerPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.AddPersonalUpgradePoints");
		
		UPartyComponent_AddPersonalUpgradePoints_Params params {};
		params.Amount = Amount;
		params.AquirerPlayerState = AquirerPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.AddPartyUpgadePoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AquirerPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartyComponent::AddPartyUpgadePoints(int32_t Amount, class ASurvivalPlayerState* AquirerPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.AddPartyUpgadePoints");
		
		UPartyComponent_AddPartyUpgadePoints_Params params {};
		params.Amount = Amount;
		params.AquirerPlayerState = AquirerPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.AddKnownRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AquirerPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMulticastNewRecipeUnlocked                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::AddKnownRecipe(const struct FDataTableRowHandle& RecipeRowHandle, class ASurvivalPlayerState* AquirerPlayerState, bool bMulticastNewRecipeUnlocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.AddKnownRecipe");
		
		UPartyComponent_AddKnownRecipe_Params params {};
		params.RecipeRowHandle = RecipeRowHandle;
		params.AquirerPlayerState = AquirerPlayerState;
		params.bMulticastNewRecipeUnlocked = bMulticastNewRecipeUnlocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.AddKnownCraftingRecipeByName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        RecipeName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AquirerPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMulticastNewRecipeUnlocked                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::AddKnownCraftingRecipeByName(const class FName& RecipeName, class ASurvivalPlayerState* AquirerPlayerState, bool bMulticastNewRecipeUnlocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.AddKnownCraftingRecipeByName");
		
		UPartyComponent_AddKnownCraftingRecipeByName_Params params {};
		params.RecipeName = RecipeName;
		params.AquirerPlayerState = AquirerPlayerState;
		params.bMulticastNewRecipeUnlocked = bMulticastNewRecipeUnlocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.AddKnownCraftingRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AquirerPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMulticastNewRecipeUnlocked                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::AddKnownCraftingRecipe(const struct FDataTableRowHandle& RecipeRowHandle, class ASurvivalPlayerState* AquirerPlayerState, bool bMulticastNewRecipeUnlocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.AddKnownCraftingRecipe");
		
		UPartyComponent_AddKnownCraftingRecipe_Params params {};
		params.RecipeRowHandle = RecipeRowHandle;
		params.AquirerPlayerState = AquirerPlayerState;
		params.bMulticastNewRecipeUnlocked = bMulticastNewRecipeUnlocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.AddKnownBuildingRecipeByName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        RecipeName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AquirerPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMulticastNewRecipeUnlocked                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::AddKnownBuildingRecipeByName(const class FName& RecipeName, class ASurvivalPlayerState* AquirerPlayerState, bool bMulticastNewRecipeUnlocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.AddKnownBuildingRecipeByName");
		
		UPartyComponent_AddKnownBuildingRecipeByName_Params params {};
		params.RecipeName = RecipeName;
		params.AquirerPlayerState = AquirerPlayerState;
		params.bMulticastNewRecipeUnlocked = bMulticastNewRecipeUnlocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PartyComponent.AddKnownBuildingRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        AquirerPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMulticastNewRecipeUnlocked                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPartyComponent::AddKnownBuildingRecipe(const struct FDataTableRowHandle& RecipeRowHandle, class ASurvivalPlayerState* AquirerPlayerState, bool bMulticastNewRecipeUnlocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PartyComponent.AddKnownBuildingRecipe");
		
		UPartyComponent_AddKnownBuildingRecipe_Params params {};
		params.RecipeRowHandle = RecipeRowHandle;
		params.AquirerPlayerState = AquirerPlayerState;
		params.bMulticastNewRecipeUnlocked = bMulticastNewRecipeUnlocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPartyComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPartyComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PartyComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerkComponent.UnlockPerkTier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         PerkRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Tier                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPerkComponent::UnlockPerkTier(const struct FDataTableRowHandle& PerkRowHandle, int32_t Tier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerkComponent.UnlockPerkTier");
		
		UPerkComponent_UnlockPerkTier_Params params {};
		params.PerkRowHandle = PerkRowHandle;
		params.Tier = Tier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerkComponent.ServerUnequipPerk
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        PerkName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPerkComponent::ServerUnequipPerk(const class FName& PerkName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerkComponent.ServerUnequipPerk");
		
		UPerkComponent_ServerUnequipPerk_Params params {};
		params.PerkName = PerkName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerkComponent.ServerEquipPerk
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        PerkName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPerkComponent::ServerEquipPerk(const class FName& PerkName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerkComponent.ServerEquipPerk");
		
		UPerkComponent_ServerEquipPerk_Params params {};
		params.PerkName = PerkName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerkComponent.OnRep_Perks
	 * 		Flags  -> ()
	 */
	void UPerkComponent::OnRep_Perks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerkComponent.OnRep_Perks");
		
		UPerkComponent_OnRep_Perks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerkComponent.OnPlayerStatChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPlayerStatConfig*                           PlayerStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPerkComponent::OnPlayerStatChanged(class UPlayerStatConfig* PlayerStat, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerkComponent.OnPlayerStatChanged");
		
		UPerkComponent_OnPlayerStatChanged_Params params {};
		params.PlayerStat = PlayerStat;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerkComponent.OnGlobalVariableChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       GlobalVariableID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            VariableValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPerkComponent::OnGlobalVariableChanged(const struct FGuid& GlobalVariableID, int32_t VariableValue, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerkComponent.OnGlobalVariableChanged");
		
		UPerkComponent_OnGlobalVariableChanged_Params params {};
		params.GlobalVariableID = GlobalVariableID;
		params.VariableValue = VariableValue;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerkComponent.IsPerkEquipped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         PerkRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UPerkComponent::IsPerkEquipped(const struct FDataTableRowHandle& PerkRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerkComponent.IsPerkEquipped");
		
		UPerkComponent_IsPerkEquipped_Params params {};
		params.PerkRowHandle = PerkRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerkComponent.HasAvailablePerkEquip
	 * 		Flags  -> ()
	 */
	bool UPerkComponent::HasAvailablePerkEquip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerkComponent.HasAvailablePerkEquip");
		
		UPerkComponent_HasAvailablePerkEquip_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerkComponent.GetPerks
	 * 		Flags  -> ()
	 */
	TArray<struct FPerkStatus> UPerkComponent::GetPerks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerkComponent.GetPerks");
		
		UPerkComponent_GetPerks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerkComponent.GetNumEquippedPerks
	 * 		Flags  -> ()
	 */
	int32_t UPerkComponent::GetNumEquippedPerks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerkComponent.GetNumEquippedPerks");
		
		UPerkComponent_GetNumEquippedPerks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerkComponent.GetMaxEquippedPerks
	 * 		Flags  -> ()
	 */
	int32_t UPerkComponent::GetMaxEquippedPerks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerkComponent.GetMaxEquippedPerks");
		
		UPerkComponent_GetMaxEquippedPerks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerkComponent.GetDefaultMaxEquippedPerks
	 * 		Flags  -> ()
	 */
	int32_t UPerkComponent::GetDefaultMaxEquippedPerks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerkComponent.GetDefaultMaxEquippedPerks");
		
		UPerkComponent_GetDefaultMaxEquippedPerks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerkComponent.ClientNotifyUnlockPerk
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPerkStatus                                 Perk                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UPerkComponent::ClientNotifyUnlockPerk(const struct FPerkStatus& Perk)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerkComponent.ClientNotifyUnlockPerk");
		
		UPerkComponent_ClientNotifyUnlockPerk_Params params {};
		params.Perk = Perk;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPerkComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPerkComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PerkComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerlinNoiseFunctionLibrary.SetPerlinNoiseSeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPerlinNoise                                Noise                                                      (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewSeed                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPerlinNoiseFunctionLibrary::SetPerlinNoiseSeed(struct FPerlinNoise* Noise, int32_t NewSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerlinNoiseFunctionLibrary.SetPerlinNoiseSeed");
		
		UPerlinNoiseFunctionLibrary_SetPerlinNoiseSeed_Params params {};
		params.NewSeed = NewSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Noise != nullptr)
			*Noise = params.Noise;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerlinNoiseFunctionLibrary.SamplePerlinNoise1D
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPerlinNoise                                Noise                                                      (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UPerlinNoiseFunctionLibrary::SamplePerlinNoise1D(struct FPerlinNoise* Noise, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerlinNoiseFunctionLibrary.SamplePerlinNoise1D");
		
		UPerlinNoiseFunctionLibrary_SamplePerlinNoise1D_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Noise != nullptr)
			*Noise = params.Noise;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PerlinNoiseFunctionLibrary.GetPerlinNoiseSeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPerlinNoise                                Noise                                                      (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UPerlinNoiseFunctionLibrary::GetPerlinNoiseSeed(struct FPerlinNoise* Noise)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PerlinNoiseFunctionLibrary.GetPerlinNoiseSeed");
		
		UPerlinNoiseFunctionLibrary_GetPerlinNoiseSeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Noise != nullptr)
			*Noise = params.Noise;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPerlinNoiseFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPerlinNoiseFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PerlinNoiseFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPersistenceComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPersistenceComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PersistenceComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PersistentInterface.SkippedLoadOfActor
	 * 		Flags  -> ()
	 */
	bool UPersistentInterface::SkippedLoadOfActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PersistentInterface.SkippedLoadOfActor");
		
		UPersistentInterface_SkippedLoadOfActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PersistentInterface.ShouldSave
	 * 		Flags  -> ()
	 */
	bool UPersistentInterface::ShouldSave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PersistentInterface.ShouldSave");
		
		UPersistentInterface_ShouldSave_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PersistentInterface.ShouldLoad
	 * 		Flags  -> ()
	 */
	bool UPersistentInterface::ShouldLoad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PersistentInterface.ShouldLoad");
		
		UPersistentInterface_ShouldLoad_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PersistentInterface.Save
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USaveWriter*                                 Writer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPersistentInterface::Save(class USaveWriter* Writer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PersistentInterface.Save");
		
		UPersistentInterface_Save_Params params {};
		params.Writer = Writer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PersistentInterface.ProcessLoadData
	 * 		Flags  -> ()
	 */
	void UPersistentInterface::ProcessLoadData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PersistentInterface.ProcessLoadData");
		
		UPersistentInterface_ProcessLoadData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PersistentInterface.PrepareSave
	 * 		Flags  -> ()
	 */
	void UPersistentInterface::PrepareSave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PersistentInterface.PrepareSave");
		
		UPersistentInterface_PrepareSave_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PersistentInterface.LoadAll
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USaveReader*                                 Reader                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Version                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPersistentInterface::LoadAll(class USaveReader* Reader, int32_t Version)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PersistentInterface.LoadAll");
		
		UPersistentInterface_LoadAll_Params params {};
		params.Reader = Reader;
		params.Version = Version;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PersistentInterface.Load
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USaveReader*                                 Reader                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Version                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPersistentInterface::Load(class USaveReader* Reader, int32_t Version)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PersistentInterface.Load");
		
		UPersistentInterface_Load_Params params {};
		params.Reader = Reader;
		params.Version = Version;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PersistentInterface.GetSaveVersion
	 * 		Flags  -> ()
	 */
	int32_t UPersistentInterface::GetSaveVersion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PersistentInterface.GetSaveVersion");
		
		UPersistentInterface_GetSaveVersion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PersistentInterface.GetProcessLoadDataOrder
	 * 		Flags  -> ()
	 */
	int32_t UPersistentInterface::GetProcessLoadDataOrder()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PersistentInterface.GetProcessLoadDataOrder");
		
		UPersistentInterface_GetProcessLoadDataOrder_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPersistentInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPersistentInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PersistentInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USaveWriter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USaveWriter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SaveWriter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USaveReader.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USaveReader::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SaveReader");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PersistentUtilsStatics.BlueprintWritePersistentInt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USaveWriter*                                 Writer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPersistentUtilsStatics::BlueprintWritePersistentInt(class USaveWriter* Writer, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PersistentUtilsStatics.BlueprintWritePersistentInt");
		
		UPersistentUtilsStatics_BlueprintWritePersistentInt_Params params {};
		params.Writer = Writer;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PersistentUtilsStatics.BlueprintWritePersistentBool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USaveWriter*                                 Writer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPersistentUtilsStatics::BlueprintWritePersistentBool(class USaveWriter* Writer, bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PersistentUtilsStatics.BlueprintWritePersistentBool");
		
		UPersistentUtilsStatics_BlueprintWritePersistentBool_Params params {};
		params.Writer = Writer;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PersistentUtilsStatics.BlueprintReadPersistentInt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USaveReader*                                 Reader                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPersistentUtilsStatics::BlueprintReadPersistentInt(class USaveReader* Reader)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PersistentUtilsStatics.BlueprintReadPersistentInt");
		
		UPersistentUtilsStatics_BlueprintReadPersistentInt_Params params {};
		params.Reader = Reader;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PersistentUtilsStatics.BlueprintReadPersistentBool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USaveReader*                                 Reader                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPersistentUtilsStatics::BlueprintReadPersistentBool(class USaveReader* Reader)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PersistentUtilsStatics.BlueprintReadPersistentBool");
		
		UPersistentUtilsStatics_BlueprintReadPersistentBool_Params params {};
		params.Reader = Reader;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPersistentUtilsStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPersistentUtilsStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PersistentUtilsStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PetHomeBuilding.OnRep_StoredPetFull
	 * 		Flags  -> ()
	 */
	void APetHomeBuilding::OnRep_StoredPetFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PetHomeBuilding.OnRep_StoredPetFull");
		
		APetHomeBuilding_OnRep_StoredPetFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PetHomeBuilding.HandleStoredPetLODActorConvertedToProxyActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               LODActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APetHomeBuilding::HandleStoredPetLODActorConvertedToProxyActor(class UBaseLODActor* LODActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PetHomeBuilding.HandleStoredPetLODActorConvertedToProxyActor");
		
		APetHomeBuilding_HandleStoredPetLODActorConvertedToProxyActor_Params params {};
		params.LODActor = LODActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PetHomeBuilding.HandleStoredPetLODActorConvertedToFullActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               LODActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APetHomeBuilding::HandleStoredPetLODActorConvertedToFullActor(class UBaseLODActor* LODActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PetHomeBuilding.HandleStoredPetLODActorConvertedToFullActor");
		
		APetHomeBuilding_HandleStoredPetLODActorConvertedToFullActor_Params params {};
		params.LODActor = LODActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PetHomeBuilding.GetStoredTameData
	 * 		Flags  -> ()
	 */
	class UTamedCreatureData* APetHomeBuilding::GetStoredTameData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PetHomeBuilding.GetStoredTameData");
		
		APetHomeBuilding_GetStoredTameData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PetHomeBuilding.GetStoredPetFull
	 * 		Flags  -> ()
	 */
	class ASurvivalCreature* APetHomeBuilding::GetStoredPetFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PetHomeBuilding.GetStoredPetFull");
		
		APetHomeBuilding_GetStoredPetFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PetHomeBuilding.GetStoredPet
	 * 		Flags  -> ()
	 */
	class UCreatureLODActor* APetHomeBuilding::GetStoredPet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PetHomeBuilding.GetStoredPet");
		
		APetHomeBuilding_GetStoredPet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APetHomeBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APetHomeBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PetHomeBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PheromoneBroadcasterBuilding.TurnOff
	 * 		Flags  -> ()
	 */
	void APheromoneBroadcasterBuilding::TurnOff()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PheromoneBroadcasterBuilding.TurnOff");
		
		APheromoneBroadcasterBuilding_TurnOff_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PheromoneBroadcasterBuilding.TickConsume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APheromoneBroadcasterBuilding::TickConsume(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PheromoneBroadcasterBuilding.TickConsume");
		
		APheromoneBroadcasterBuilding_TickConsume_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PheromoneBroadcasterBuilding.SetGatheringEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APheromoneBroadcasterBuilding::SetGatheringEnabled(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PheromoneBroadcasterBuilding.SetGatheringEnabled");
		
		APheromoneBroadcasterBuilding_SetGatheringEnabled_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PheromoneBroadcasterBuilding.SetBuildingEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APheromoneBroadcasterBuilding::SetBuildingEnabled(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PheromoneBroadcasterBuilding.SetBuildingEnabled");
		
		APheromoneBroadcasterBuilding_SetBuildingEnabled_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PheromoneBroadcasterBuilding.IsAcceptablePowerItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APheromoneBroadcasterBuilding::IsAcceptablePowerItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PheromoneBroadcasterBuilding.IsAcceptablePowerItem");
		
		APheromoneBroadcasterBuilding_IsAcceptablePowerItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PheromoneBroadcasterBuilding.HandleBuildingUnderConstruction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBuildingManagerComponent*                   Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABuilding*                                   Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APheromoneBroadcasterBuilding::HandleBuildingUnderConstruction(class UBuildingManagerComponent* Sender, class ABuilding* Building)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PheromoneBroadcasterBuilding.HandleBuildingUnderConstruction");
		
		APheromoneBroadcasterBuilding_HandleBuildingUnderConstruction_Params params {};
		params.Sender = Sender;
		params.Building = Building;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PheromoneBroadcasterBuilding.HandleBuildingNotUnderConstruction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBuildingManagerComponent*                   Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABuilding*                                   Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APheromoneBroadcasterBuilding::HandleBuildingNotUnderConstruction(class UBuildingManagerComponent* Sender, class ABuilding* Building)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PheromoneBroadcasterBuilding.HandleBuildingNotUnderConstruction");
		
		APheromoneBroadcasterBuilding_HandleBuildingNotUnderConstruction_Params params {};
		params.Sender = Sender;
		params.Building = Building;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PheromoneBroadcasterBuilding.GetGatheringEnabled
	 * 		Flags  -> ()
	 */
	bool APheromoneBroadcasterBuilding::GetGatheringEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PheromoneBroadcasterBuilding.GetGatheringEnabled");
		
		APheromoneBroadcasterBuilding_GetGatheringEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PheromoneBroadcasterBuilding.GetBuildingEnabled
	 * 		Flags  -> ()
	 */
	bool APheromoneBroadcasterBuilding::GetBuildingEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PheromoneBroadcasterBuilding.GetBuildingEnabled");
		
		APheromoneBroadcasterBuilding_GetBuildingEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PheromoneBroadcasterBuilding.CanStart
	 * 		Flags  -> ()
	 */
	bool APheromoneBroadcasterBuilding::CanStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PheromoneBroadcasterBuilding.CanStart");
		
		APheromoneBroadcasterBuilding_CanStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APheromoneBroadcasterBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APheromoneBroadcasterBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PheromoneBroadcasterBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhobiaControllerComponent.SetSafeMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Setting                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPhobiaControllerComponent::SetSafeMode(int32_t Setting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhobiaControllerComponent.SetSafeMode");
		
		UPhobiaControllerComponent_SetSafeMode_Params params {};
		params.Setting = Setting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhobiaControllerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhobiaControllerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PhobiaControllerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhotoModeCheckBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhotoModeCheckBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PhotoModeCheckBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhotoModeComboBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhotoModeComboBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PhotoModeComboBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.ToggleUIVisibility
	 * 		Flags  -> ()
	 */
	void UPhotoModeHUD::ToggleUIVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.ToggleUIVisibility");
		
		UPhotoModeHUD_ToggleUIVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.TogglePhotoModeSettings
	 * 		Flags  -> ()
	 */
	void UPhotoModeHUD::TogglePhotoModeSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.TogglePhotoModeSettings");
		
		UPhotoModeHUD_TogglePhotoModeSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.TakePhotoOverride
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APhotoPawn*                                  PhotoPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPhotoModeHUD::TakePhotoOverride(class APhotoPawn* PhotoPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.TakePhotoOverride");
		
		UPhotoModeHUD_TakePhotoOverride_Params params {};
		params.PhotoPawn = PhotoPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.ShowUI
	 * 		Flags  -> ()
	 */
	void UPhotoModeHUD::ShowUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.ShowUI");
		
		UPhotoModeHUD_ShowUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.RestoreDefaults
	 * 		Flags  -> ()
	 */
	void UPhotoModeHUD::RestoreDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.RestoreDefaults");
		
		UPhotoModeHUD_RestoreDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.OpenPhotoModeSettings
	 * 		Flags  -> ()
	 */
	void UPhotoModeHUD::OpenPhotoModeSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.OpenPhotoModeSettings");
		
		UPhotoModeHUD_OpenPhotoModeSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.OnSettingsOpened
	 * 		Flags  -> ()
	 */
	void UPhotoModeHUD::OnSettingsOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.OnSettingsOpened");
		
		UPhotoModeHUD_OnSettingsOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.OnSettingsClosed
	 * 		Flags  -> ()
	 */
	void UPhotoModeHUD::OnSettingsClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.OnSettingsClosed");
		
		UPhotoModeHUD_OnSettingsClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.OnPhotoTaken
	 * 		Flags  -> ()
	 */
	void UPhotoModeHUD::OnPhotoTaken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.OnPhotoTaken");
		
		UPhotoModeHUD_OnPhotoTaken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.OnPhotoModePreExit
	 * 		Flags  -> ()
	 */
	void UPhotoModeHUD::OnPhotoModePreExit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.OnPhotoModePreExit");
		
		UPhotoModeHUD_OnPhotoModePreExit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.IsHUDVisible
	 * 		Flags  -> ()
	 */
	bool UPhotoModeHUD::IsHUDVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.IsHUDVisible");
		
		UPhotoModeHUD_IsHUDVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.HideUI
	 * 		Flags  -> ()
	 */
	void UPhotoModeHUD::HideUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.HideUI");
		
		UPhotoModeHUD_HideUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.HandleGenericMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  MessageIcon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPhotoModeHUD::HandleGenericMessage(const class FString& Message, class UTexture2D* MessageIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.HandleGenericMessage");
		
		UPhotoModeHUD_HandleGenericMessage_Params params {};
		params.Message = Message;
		params.MessageIcon = MessageIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.ExitPhotoMode
	 * 		Flags  -> ()
	 */
	void UPhotoModeHUD::ExitPhotoMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.ExitPhotoMode");
		
		UPhotoModeHUD_ExitPhotoMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.ClosePhotoModeSettings
	 * 		Flags  -> ()
	 */
	void UPhotoModeHUD::ClosePhotoModeSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.ClosePhotoModeSettings");
		
		UPhotoModeHUD_ClosePhotoModeSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PhotoModeHUD.AreSettingsOpen
	 * 		Flags  -> ()
	 */
	bool UPhotoModeHUD::AreSettingsOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PhotoModeHUD.AreSettingsOpen");
		
		UPhotoModeHUD_AreSettingsOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhotoModeHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhotoModeHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PhotoModeHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhotoModeSettingsSlider.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhotoModeSettingsSlider::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PhotoModeSettingsSlider");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhysicsStateManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhysicsStateManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PhysicsStateManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyPlayerCharacterActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyPlayerCharacterActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyPlayerCharacterActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerCharacterLODActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerCharacterLODActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PlayerCharacterLODActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerListWidget.KickPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerListWidget::KickPlayer(class APlayerController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerListWidget.KickPlayer");
		
		UPlayerListWidget_KickPlayer_Params params {};
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PlayerListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerNameplateWidget.UpdateNameplatePosition
	 * 		Flags  -> ()
	 */
	void UPlayerNameplateWidget::UpdateNameplatePosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerNameplateWidget.UpdateNameplatePosition");
		
		UPlayerNameplateWidget_UpdateNameplatePosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerNameplateWidget.UpdateInfoForMarker
	 * 		Flags  -> ()
	 */
	void UPlayerNameplateWidget::UpdateInfoForMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerNameplateWidget.UpdateInfoForMarker");
		
		UPlayerNameplateWidget_UpdateInfoForMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerNameplateWidget.OnMarkerDataSet
	 * 		Flags  -> ()
	 */
	void UPlayerNameplateWidget::OnMarkerDataSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerNameplateWidget.OnMarkerDataSet");
		
		UPlayerNameplateWidget_OnMarkerDataSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerNameplateWidget.OnIncapacitationRatioChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewRatio                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerNameplateWidget::OnIncapacitationRatioChanged(float NewRatio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerNameplateWidget.OnIncapacitationRatioChanged");
		
		UPlayerNameplateWidget_OnIncapacitationRatioChanged_Params params {};
		params.NewRatio = NewRatio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerNameplateWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerNameplateWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PlayerNameplateWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerScalingReceiverComponent.OnCombatChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerScalingReceiverComponent::OnCombatChanged(class ASurvivalCharacter* Character, bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerScalingReceiverComponent.OnCombatChanged");
		
		UPlayerScalingReceiverComponent_OnCombatChanged_Params params {};
		params.Character = Character;
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerScalingReceiverComponent.GetStunDurationMultiplier
	 * 		Flags  -> ()
	 */
	float UPlayerScalingReceiverComponent::GetStunDurationMultiplier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerScalingReceiverComponent.GetStunDurationMultiplier");
		
		UPlayerScalingReceiverComponent_GetStunDurationMultiplier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerScalingReceiverComponent.GetMaxStunMultiplier
	 * 		Flags  -> ()
	 */
	float UPlayerScalingReceiverComponent::GetMaxStunMultiplier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerScalingReceiverComponent.GetMaxStunMultiplier");
		
		UPlayerScalingReceiverComponent_GetMaxStunMultiplier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerScalingReceiverComponent.GetMaxHealthMultiplier
	 * 		Flags  -> ()
	 */
	float UPlayerScalingReceiverComponent::GetMaxHealthMultiplier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerScalingReceiverComponent.GetMaxHealthMultiplier");
		
		UPlayerScalingReceiverComponent_GetMaxHealthMultiplier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerScalingReceiverComponent.GetDamageResistanceMultiplier
	 * 		Flags  -> ()
	 */
	float UPlayerScalingReceiverComponent::GetDamageResistanceMultiplier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerScalingReceiverComponent.GetDamageResistanceMultiplier");
		
		UPlayerScalingReceiverComponent_GetDamageResistanceMultiplier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerScalingReceiverComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerScalingReceiverComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PlayerScalingReceiverComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerSFXComponent.TriggerStarvationSFXUpdate
	 * 		Flags  -> ()
	 */
	void UPlayerSFXComponent::TriggerStarvationSFXUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerSFXComponent.TriggerStarvationSFXUpdate");
		
		UPlayerSFXComponent_TriggerStarvationSFXUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerSFXComponent.StopSFX
	 * 		Flags  -> ()
	 */
	void UPlayerSFXComponent::StopSFX()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerSFXComponent.StopSFX");
		
		UPlayerSFXComponent_StopSFX_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerSFXComponent.SetSurvivalComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USurvivalComponent*                          InComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerSFXComponent::SetSurvivalComponent(class USurvivalComponent* InComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerSFXComponent.SetSurvivalComponent");
		
		UPlayerSFXComponent_SetSurvivalComponent_Params params {};
		params.InComponent = InComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerSFXComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerSFXComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PlayerSFXComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerStatConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerStatConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PlayerStatConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatKillConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatKillConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatKillConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatItemConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatItemConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatItemConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatCraftConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatCraftConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatCraftConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatPickupConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatPickupConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatPickupConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatReviveConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatReviveConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatReviveConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatDiscoverConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatDiscoverConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatDiscoverConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatStaminaConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatStaminaConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatStaminaConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatBasketballShotConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatBasketballShotConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatBasketballShotConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatTamePetConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatTamePetConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatTamePetConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatProcessItemConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatProcessItemConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatProcessItemConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatZiplineDistanceConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatZiplineDistanceConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatZiplineDistanceConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatUseItemConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatUseItemConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatUseItemConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatBlockConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatBlockConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatBlockConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatScriptedConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatScriptedConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatScriptedConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatPhotoConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatPhotoConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatPhotoConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatRangedAttackConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatRangedAttackConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatRangedAttackConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerStatsComponent.SetPlayerStatIfLarger
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPlayerStatConfig*                           PlayerStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerStatsComponent::SetPlayerStatIfLarger(class UPlayerStatConfig* PlayerStat, int32_t NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerStatsComponent.SetPlayerStatIfLarger");
		
		UPlayerStatsComponent_SetPlayerStatIfLarger_Params params {};
		params.PlayerStat = PlayerStat;
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerStatsComponent.OnStaminaDepleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              StaminaRatio                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerStatsComponent::OnStaminaDepleted(float StaminaRatio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerStatsComponent.OnStaminaDepleted");
		
		UPlayerStatsComponent_OnStaminaDepleted_Params params {};
		params.StaminaRatio = StaminaRatio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerStatsComponent.OnReviveTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      RevivedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerStatsComponent::OnReviveTarget(class AActor* RevivedActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerStatsComponent.OnReviveTarget");
		
		UPlayerStatsComponent_OnReviveTarget_Params params {};
		params.RevivedActor = RevivedActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerStatsComponent.OnPointOfInterestDiscovered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPointOfInterestDataAsset*                   PointOfInterest                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerStatsComponent::OnPointOfInterestDiscovered(class UPointOfInterestDataAsset* PointOfInterest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerStatsComponent.OnPointOfInterestDiscovered");
		
		UPlayerStatsComponent_OnPointOfInterestDiscovered_Params params {};
		params.PointOfInterest = PointOfInterest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerStatsComponent.OnPhotoTaken
	 * 		Flags  -> ()
	 */
	void UPlayerStatsComponent::OnPhotoTaken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerStatsComponent.OnPhotoTaken");
		
		UPlayerStatsComponent_OnPhotoTaken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerStatsComponent.OnPetTamed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCreature*                           Pet                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerStatsComponent::OnPetTamed(class ASurvivalCreature* Pet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerStatsComponent.OnPetTamed");
		
		UPlayerStatsComponent_OnPetTamed_Params params {};
		params.Pet = Pet;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerStatsComponent.OnKill
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      KilledActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UPlayerStatsComponent::OnKill(class AActor* KilledActor, const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerStatsComponent.OnKill");
		
		UPlayerStatsComponent_OnKill_Params params {};
		params.KilledActor = KilledActor;
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerStatsComponent.OnItemUsed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UPlayerStatsComponent::OnItemUsed(class ASurvivalCharacter* User, const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerStatsComponent.OnItemUsed");
		
		UPlayerStatsComponent_OnItemUsed_Params params {};
		params.User = User;
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerStatsComponent.OnItemCrafted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInventoryComponent*                         Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         RecipeHandle                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UPlayerStatsComponent::OnItemCrafted(class UInventoryComponent* Sender, const struct FDataTableRowHandle& RecipeHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerStatsComponent.OnItemCrafted");
		
		UPlayerStatsComponent_OnItemCrafted_Params params {};
		params.Sender = Sender;
		params.RecipeHandle = RecipeHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerStatsComponent.OnItemAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInventoryComponent*                         InventoryComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ItemHandle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               IsNewItem                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TotalCount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerStatsComponent::OnItemAdded(class UInventoryComponent* InventoryComponent, const struct FDataTableRowHandle& ItemHandle, bool IsNewItem, int32_t Count, int32_t TotalCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerStatsComponent.OnItemAdded");
		
		UPlayerStatsComponent_OnItemAdded_Params params {};
		params.InventoryComponent = InventoryComponent;
		params.ItemHandle = ItemHandle;
		params.IsNewItem = IsNewItem;
		params.Count = Count;
		params.TotalCount = TotalCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerStatsComponent.IncrementPlayerStat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPlayerStatConfig*                           PlayerStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ValueToAdd                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerStatsComponent::IncrementPlayerStat(class UPlayerStatConfig* PlayerStat, int32_t ValueToAdd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerStatsComponent.IncrementPlayerStat");
		
		UPlayerStatsComponent_IncrementPlayerStat_Params params {};
		params.PlayerStat = PlayerStat;
		params.ValueToAdd = ValueToAdd;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerStatsComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerStatsComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PlayerStatsComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerStatusWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerStatusWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PlayerStatusWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerUpgradeComponent.ServerUnlockUpgradeTier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         UpgradeRowHandle                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreCost                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerUpgradeComponent::ServerUnlockUpgradeTier(const struct FDataTableRowHandle& UpgradeRowHandle, bool bIgnoreCost)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerUpgradeComponent.ServerUnlockUpgradeTier");
		
		UPlayerUpgradeComponent_ServerUnlockUpgradeTier_Params params {};
		params.UpgradeRowHandle = UpgradeRowHandle;
		params.bIgnoreCost = bIgnoreCost;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerUpgradeComponent.OnRep_PlayerUpgrades
	 * 		Flags  -> ()
	 */
	void UPlayerUpgradeComponent::OnRep_PlayerUpgrades()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerUpgradeComponent.OnRep_PlayerUpgrades");
		
		UPlayerUpgradeComponent_OnRep_PlayerUpgrades_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerUpgradeComponent.GetUpgradeTier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         UpgradeRowHandle                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerUpgradeComponent::GetUpgradeTier(const struct FDataTableRowHandle& UpgradeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerUpgradeComponent.GetUpgradeTier");
		
		UPlayerUpgradeComponent_GetUpgradeTier_Params params {};
		params.UpgradeRowHandle = UpgradeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerUpgradeComponent.GetUpgradeCost
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         UpgradeRowHandle                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerUpgradeComponent::GetUpgradeCost(const struct FDataTableRowHandle& UpgradeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerUpgradeComponent.GetUpgradeCost");
		
		UPlayerUpgradeComponent_GetUpgradeCost_Params params {};
		params.UpgradeRowHandle = UpgradeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerUpgradeComponent.GetTotalSpentPoints
	 * 		Flags  -> ()
	 */
	int32_t UPlayerUpgradeComponent::GetTotalSpentPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerUpgradeComponent.GetTotalSpentPoints");
		
		UPlayerUpgradeComponent_GetTotalSpentPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerUpgradeComponent.GetRemainingUpgradePoints
	 * 		Flags  -> ()
	 */
	int32_t UPlayerUpgradeComponent::GetRemainingUpgradePoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerUpgradeComponent.GetRemainingUpgradePoints");
		
		UPlayerUpgradeComponent_GetRemainingUpgradePoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerUpgradeComponent.GetPerkCountBonus
	 * 		Flags  -> ()
	 */
	int32_t UPlayerUpgradeComponent::GetPerkCountBonus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerUpgradeComponent.GetPerkCountBonus");
		
		UPlayerUpgradeComponent_GetPerkCountBonus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerUpgradeComponent.GetMaxUpgradeTier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         UpgradeRowHandle                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerUpgradeComponent::GetMaxUpgradeTier(const struct FDataTableRowHandle& UpgradeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerUpgradeComponent.GetMaxUpgradeTier");
		
		UPlayerUpgradeComponent_GetMaxUpgradeTier_Params params {};
		params.UpgradeRowHandle = UpgradeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PlayerUpgradeComponent.CanUpgradeTier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         UpgradeRowHandle                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreCost                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerUpgradeComponent::CanUpgradeTier(const struct FDataTableRowHandle& UpgradeRowHandle, bool bIgnoreCost)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PlayerUpgradeComponent.CanUpgradeTier");
		
		UPlayerUpgradeComponent_CanUpgradeTier_Params params {};
		params.UpgradeRowHandle = UpgradeRowHandle;
		params.bIgnoreCost = bIgnoreCost;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerUpgradeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerUpgradeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PlayerUpgradeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PointOfInterestComponent.PlayBanter
	 * 		Flags  -> ()
	 */
	void UPointOfInterestComponent::PlayBanter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PointOfInterestComponent.PlayBanter");
		
		UPointOfInterestComponent_PlayBanter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PointOfInterestComponent.OnLookTriggered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ULookTriggerComponent*                       Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLookTriggeredParams                        Params                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UPointOfInterestComponent::OnLookTriggered(class ULookTriggerComponent* Sender, const struct FLookTriggeredParams& Params)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PointOfInterestComponent.OnLookTriggered");
		
		UPointOfInterestComponent_OnLookTriggered_Params params {};
		params.Sender = Sender;
		params.Params = Params;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PointOfInterestComponent.GetPointOfInterestData
	 * 		Flags  -> ()
	 */
	class UPointOfInterestDataAsset* UPointOfInterestComponent::GetPointOfInterestData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PointOfInterestComponent.GetPointOfInterestData");
		
		UPointOfInterestComponent_GetPointOfInterestData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PointOfInterestComponent.Discover
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalPlayerController*                   Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPointOfInterestComponent::Discover(class ASurvivalPlayerController* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PointOfInterestComponent.Discover");
		
		UPointOfInterestComponent_Discover_Params params {};
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPointOfInterestComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPointOfInterestComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PointOfInterestComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPointOfInterestDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPointOfInterestDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PointOfInterestDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PopulationMonitorComponent.OnHourChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            DayHour                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Day                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPopulationMonitorComponent::OnHourChanged(int32_t DayHour, int32_t Day)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PopulationMonitorComponent.OnHourChanged");
		
		UPopulationMonitorComponent_OnHourChanged_Params params {};
		params.DayHour = DayHour;
		params.Day = Day;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PopulationMonitorComponent.DumpSamplesToFile
	 * 		Flags  -> ()
	 */
	void UPopulationMonitorComponent::DumpSamplesToFile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PopulationMonitorComponent.DumpSamplesToFile");
		
		UPopulationMonitorComponent_DumpSamplesToFile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPopulationMonitorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPopulationMonitorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PopulationMonitorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPossessableInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPossessableInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PossessableInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PoweredBuilding.IsSwitchActive
	 * 		Flags  -> ()
	 */
	bool UPoweredBuilding::IsSwitchActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PoweredBuilding.IsSwitchActive");
		
		UPoweredBuilding_IsSwitchActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PoweredBuilding.IsSwitch
	 * 		Flags  -> ()
	 */
	bool UPoweredBuilding::IsSwitch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PoweredBuilding.IsSwitch");
		
		UPoweredBuilding_IsSwitch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PoweredBuilding.IsPowerSource
	 * 		Flags  -> ()
	 */
	bool UPoweredBuilding::IsPowerSource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PoweredBuilding.IsPowerSource");
		
		UPoweredBuilding_IsPowerSource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PoweredBuilding.IsPowerReceiver
	 * 		Flags  -> ()
	 */
	bool UPoweredBuilding::IsPowerReceiver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PoweredBuilding.IsPowerReceiver");
		
		UPoweredBuilding_IsPowerReceiver_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PoweredBuilding.HasValidPowerId
	 * 		Flags  -> ()
	 */
	bool UPoweredBuilding::HasValidPowerId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PoweredBuilding.HasValidPowerId");
		
		UPoweredBuilding_HasValidPowerId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PoweredBuilding.GetPowerValue
	 * 		Flags  -> ()
	 */
	float UPoweredBuilding::GetPowerValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PoweredBuilding.GetPowerValue");
		
		UPoweredBuilding_GetPowerValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PoweredBuilding.GetPowerState
	 * 		Flags  -> ()
	 */
	EBuildingPowerState UPoweredBuilding::GetPowerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PoweredBuilding.GetPowerState");
		
		UPoweredBuilding_GetPowerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PoweredBuilding.GetBuildingPowerId
	 * 		Flags  -> ()
	 */
	struct FBuildingPowerId UPoweredBuilding::GetBuildingPowerId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PoweredBuilding.GetBuildingPowerId");
		
		UPoweredBuilding_GetBuildingPowerId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PoweredBuilding.CanJoinPowerNetwork
	 * 		Flags  -> ()
	 */
	bool UPoweredBuilding::CanJoinPowerNetwork()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PoweredBuilding.CanJoinPowerNetwork");
		
		UPoweredBuilding_CanJoinPowerNetwork_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPoweredBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPoweredBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PoweredBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PoweredBuildingConnection.SetEdgeInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InNodeA                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InNodeB                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InNetworkIdA                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InNetworkIdB                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPoweredBuildingConnection::SetEdgeInfo(int32_t InNodeA, int32_t InNodeB, int32_t InNetworkIdA, int32_t InNetworkIdB)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PoweredBuildingConnection.SetEdgeInfo");
		
		UPoweredBuildingConnection_SetEdgeInfo_Params params {};
		params.InNodeA = InNodeA;
		params.InNodeB = InNodeB;
		params.InNetworkIdA = InNetworkIdA;
		params.InNetworkIdB = InNetworkIdB;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PoweredBuildingConnection.GetSplineMeshComponent
	 * 		Flags  -> ()
	 */
	class USplineMeshComponent* UPoweredBuildingConnection::GetSplineMeshComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PoweredBuildingConnection.GetSplineMeshComponent");
		
		UPoweredBuildingConnection_GetSplineMeshComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PoweredBuildingConnection.GetEdgeInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            OutNodeA                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutNodeB                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutNetworkIdA                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutNetworkIdB                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPoweredBuildingConnection::GetEdgeInfo(int32_t* OutNodeA, int32_t* OutNodeB, int32_t* OutNetworkIdA, int32_t* OutNetworkIdB)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PoweredBuildingConnection.GetEdgeInfo");
		
		UPoweredBuildingConnection_GetEdgeInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutNodeA != nullptr)
			*OutNodeA = params.OutNodeA;
		if (OutNodeB != nullptr)
			*OutNodeB = params.OutNodeB;
		if (OutNetworkIdA != nullptr)
			*OutNetworkIdA = params.OutNetworkIdA;
		if (OutNetworkIdB != nullptr)
			*OutNetworkIdB = params.OutNetworkIdB;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPoweredBuildingConnection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPoweredBuildingConnection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PoweredBuildingConnection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerGenerator.TickUpdatePower
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APowerGenerator::TickUpdatePower(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerGenerator.TickUpdatePower");
		
		APowerGenerator_TickUpdatePower_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APowerGenerator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APowerGenerator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PowerGenerator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerNetworkManagerComponent.GetTotalPowerForNetwork
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NetworkId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UPowerNetworkManagerComponent::GetTotalPowerForNetwork(int32_t NetworkId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerNetworkManagerComponent.GetTotalPowerForNetwork");
		
		UPowerNetworkManagerComponent_GetTotalPowerForNetwork_Params params {};
		params.NetworkId = NetworkId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerNetworkManagerComponent.GetPoweredBuilding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBuildingPowerId                            ID                                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class ABuilding* UPowerNetworkManagerComponent::GetPoweredBuilding(const struct FBuildingPowerId& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerNetworkManagerComponent.GetPoweredBuilding");
		
		UPowerNetworkManagerComponent_GetPoweredBuilding_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPowerNetworkManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPowerNetworkManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PowerNetworkManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerReservoirLibrary.UsesPowerType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPowerReservoir                             Reservoir                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                PowerType                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPowerReservoirLibrary::UsesPowerType(const struct FPowerReservoir& Reservoir, const struct FGameplayTag& PowerType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerReservoirLibrary.UsesPowerType");
		
		UPowerReservoirLibrary_UsesPowerType_Params params {};
		params.Reservoir = Reservoir;
		params.PowerType = PowerType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerReservoirLibrary.RemoveCharges
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPowerReservoir                             Reservoir                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPowerReservoirLibrary::RemoveCharges(struct FPowerReservoir* Reservoir, float Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerReservoirLibrary.RemoveCharges");
		
		UPowerReservoirLibrary_RemoveCharges_Params params {};
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Reservoir != nullptr)
			*Reservoir = params.Reservoir;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerReservoirLibrary.IsValid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPowerReservoir                             Reservoir                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UPowerReservoirLibrary::IsValid(const struct FPowerReservoir& Reservoir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerReservoirLibrary.IsValid");
		
		UPowerReservoirLibrary_IsValid_Params params {};
		params.Reservoir = Reservoir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerReservoirLibrary.IsFull
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPowerReservoir                             Reservoir                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UPowerReservoirLibrary::IsFull(const struct FPowerReservoir& Reservoir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerReservoirLibrary.IsFull");
		
		UPowerReservoirLibrary_IsFull_Params params {};
		params.Reservoir = Reservoir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerReservoirLibrary.IsEmpty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPowerReservoir                             Reservoir                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UPowerReservoirLibrary::IsEmpty(const struct FPowerReservoir& Reservoir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerReservoirLibrary.IsEmpty");
		
		UPowerReservoirLibrary_IsEmpty_Params params {};
		params.Reservoir = Reservoir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerReservoirLibrary.GetPowerPercentage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPowerReservoir                             Reservoir                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	float UPowerReservoirLibrary::GetPowerPercentage(const struct FPowerReservoir& Reservoir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerReservoirLibrary.GetPowerPercentage");
		
		UPowerReservoirLibrary_GetPowerPercentage_Params params {};
		params.Reservoir = Reservoir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerReservoirLibrary.GetEmptySpace
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPowerReservoir                             Reservoir                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	float UPowerReservoirLibrary::GetEmptySpace(const struct FPowerReservoir& Reservoir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerReservoirLibrary.GetEmptySpace");
		
		UPowerReservoirLibrary_GetEmptySpace_Params params {};
		params.Reservoir = Reservoir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerReservoirLibrary.GetCurrentPowerType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPowerReservoir                             Reservoir                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FGameplayTag UPowerReservoirLibrary::GetCurrentPowerType(const struct FPowerReservoir& Reservoir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerReservoirLibrary.GetCurrentPowerType");
		
		UPowerReservoirLibrary_GetCurrentPowerType_Params params {};
		params.Reservoir = Reservoir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerReservoirLibrary.GetCurrentCharges
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPowerReservoir                             Reservoir                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	float UPowerReservoirLibrary::GetCurrentCharges(const struct FPowerReservoir& Reservoir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerReservoirLibrary.GetCurrentCharges");
		
		UPowerReservoirLibrary_GetCurrentCharges_Params params {};
		params.Reservoir = Reservoir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerReservoirLibrary.GetCapacity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPowerReservoir                             Reservoir                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	float UPowerReservoirLibrary::GetCapacity(const struct FPowerReservoir& Reservoir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerReservoirLibrary.GetCapacity");
		
		UPowerReservoirLibrary_GetCapacity_Params params {};
		params.Reservoir = Reservoir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerReservoirLibrary.GetAllowedPowerType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPowerReservoir                             Reservoir                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FGameplayTag UPowerReservoirLibrary::GetAllowedPowerType(const struct FPowerReservoir& Reservoir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerReservoirLibrary.GetAllowedPowerType");
		
		UPowerReservoirLibrary_GetAllowedPowerType_Params params {};
		params.Reservoir = Reservoir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerReservoirLibrary.CanAcceptPowerType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPowerReservoir                             Reservoir                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                PowerType                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPowerReservoirLibrary::CanAcceptPowerType(const struct FPowerReservoir& Reservoir, const struct FGameplayTag& PowerType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerReservoirLibrary.CanAcceptPowerType");
		
		UPowerReservoirLibrary_CanAcceptPowerType_Params params {};
		params.Reservoir = Reservoir;
		params.PowerType = PowerType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerReservoirLibrary.AddCharges
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPowerReservoir                             Reservoir                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                PowerTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPowerReservoirLibrary::AddCharges(struct FPowerReservoir* Reservoir, const struct FGameplayTag& PowerTag, float Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerReservoirLibrary.AddCharges");
		
		UPowerReservoirLibrary_AddCharges_Params params {};
		params.PowerTag = PowerTag;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Reservoir != nullptr)
			*Reservoir = params.Reservoir;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPowerReservoirLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPowerReservoirLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PowerReservoirLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.OnWithdrawSucceeded
	 * 		Flags  -> ()
	 */
	void APowerStorageBuilding::OnWithdrawSucceeded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.OnWithdrawSucceeded");
		
		APowerStorageBuilding_OnWithdrawSucceeded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.OnWithdrawFailed
	 * 		Flags  -> ()
	 */
	void APowerStorageBuilding::OnWithdrawFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.OnWithdrawFailed");
		
		APowerStorageBuilding_OnWithdrawFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.OnRep_PowerReservoir
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPowerReservoir                             OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void APowerStorageBuilding::OnRep_PowerReservoir(const struct FPowerReservoir& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.OnRep_PowerReservoir");
		
		APowerStorageBuilding_OnRep_PowerReservoir_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.OnMixError
	 * 		Flags  -> ()
	 */
	void APowerStorageBuilding::OnMixError()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.OnMixError");
		
		APowerStorageBuilding_OnMixError_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.OnErrorWithdrawFromEmpty
	 * 		Flags  -> ()
	 */
	void APowerStorageBuilding::OnErrorWithdrawFromEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.OnErrorWithdrawFromEmpty");
		
		APowerStorageBuilding_OnErrorWithdrawFromEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.OnErrorDepositToFull
	 * 		Flags  -> ()
	 */
	void APowerStorageBuilding::OnErrorDepositToFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.OnErrorDepositToFull");
		
		APowerStorageBuilding_OnErrorDepositToFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.OnErrorDepositFromEmpty
	 * 		Flags  -> ()
	 */
	void APowerStorageBuilding::OnErrorDepositFromEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.OnErrorDepositFromEmpty");
		
		APowerStorageBuilding_OnErrorDepositFromEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.OnDepositSucceeded
	 * 		Flags  -> ()
	 */
	void APowerStorageBuilding::OnDepositSucceeded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.OnDepositSucceeded");
		
		APowerStorageBuilding_OnDepositSucceeded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.IsPowerFull
	 * 		Flags  -> ()
	 */
	bool APowerStorageBuilding::IsPowerFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.IsPowerFull");
		
		APowerStorageBuilding_IsPowerFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.IsPowerEmpty
	 * 		Flags  -> ()
	 */
	bool APowerStorageBuilding::IsPowerEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.IsPowerEmpty");
		
		APowerStorageBuilding_IsPowerEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.InteractManualDrink
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APowerStorageBuilding::InteractManualDrink(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.InteractManualDrink");
		
		APowerStorageBuilding_InteractManualDrink_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.GetPowerReservoir
	 * 		Flags  -> ()
	 */
	struct FPowerReservoir APowerStorageBuilding::GetPowerReservoir()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.GetPowerReservoir");
		
		APowerStorageBuilding_GetPowerReservoir_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.GetCurrentPower
	 * 		Flags  -> ()
	 */
	float APowerStorageBuilding::GetCurrentPower()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.GetCurrentPower");
		
		APowerStorageBuilding_GetCurrentPower_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.ConsumeUnit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                PreviousPowerType                                          (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APowerStorageBuilding::ConsumeUnit(struct FGameplayTag* PreviousPowerType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.ConsumeUnit");
		
		APowerStorageBuilding_ConsumeUnit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PreviousPowerType != nullptr)
			*PreviousPowerType = params.PreviousPowerType;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.PowerStorageBuilding.AddCharges
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                PowerType                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Charges                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APowerStorageBuilding::AddCharges(const struct FGameplayTag& PowerType, int32_t Charges)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.PowerStorageBuilding.AddCharges");
		
		APowerStorageBuilding_AddCharges_Params params {};
		params.PowerType = PowerType;
		params.Charges = Charges;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APowerStorageBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APowerStorageBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PowerStorageBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProceduralAnimationComponent.StopAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FProceduralAnimationHandle                  Handle                                                     (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UProceduralAnimationComponent::StopAnimation(struct FProceduralAnimationHandle* Handle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProceduralAnimationComponent.StopAnimation");
		
		UProceduralAnimationComponent_StopAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Handle != nullptr)
			*Handle = params.Handle;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProceduralAnimationComponent.SetAdditiveRotationQuat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FQuat                                       Rotation                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UProceduralAnimationComponent::SetAdditiveRotationQuat(class UObject* Source, const struct FQuat& Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProceduralAnimationComponent.SetAdditiveRotationQuat");
		
		UProceduralAnimationComponent_SetAdditiveRotationQuat_Params params {};
		params.Source = Source;
		params.Rotation = Rotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProceduralAnimationComponent.SetAdditiveRotation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UProceduralAnimationComponent::SetAdditiveRotation(class UObject* Source, const struct FRotator& Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProceduralAnimationComponent.SetAdditiveRotation");
		
		UProceduralAnimationComponent_SetAdditiveRotation_Params params {};
		params.Source = Source;
		params.Rotation = Rotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProceduralAnimationComponent.PlayWiggle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCurveFloat*                                 InStrengthCurve                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Frequency                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FProceduralAnimationHandle UProceduralAnimationComponent::PlayWiggle(class UObject* Source, class UCurveFloat* InStrengthCurve, float Frequency, float Delay, bool bLoop)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProceduralAnimationComponent.PlayWiggle");
		
		UProceduralAnimationComponent_PlayWiggle_Params params {};
		params.Source = Source;
		params.InStrengthCurve = InStrengthCurve;
		params.Frequency = Frequency;
		params.Delay = Delay;
		params.bLoop = bLoop;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProceduralAnimationComponent.PlayScaleAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCurveFloat*                                 InStrengthXCurve                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCurveFloat*                                 InStrengthYCurve                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCurveFloat*                                 InStrengthZCurve                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FProceduralAnimationHandle UProceduralAnimationComponent::PlayScaleAnimation(class UObject* Source, class UCurveFloat* InStrengthXCurve, class UCurveFloat* InStrengthYCurve, class UCurveFloat* InStrengthZCurve, float Delay, bool bLoop)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProceduralAnimationComponent.PlayScaleAnimation");
		
		UProceduralAnimationComponent_PlayScaleAnimation_Params params {};
		params.Source = Source;
		params.InStrengthXCurve = InStrengthXCurve;
		params.InStrengthYCurve = InStrengthYCurve;
		params.InStrengthZCurve = InStrengthZCurve;
		params.Delay = Delay;
		params.bLoop = bLoop;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProceduralAnimationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProceduralAnimationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProceduralAnimationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.TickVisuals
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProductionBuilding::TickVisuals(float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.TickVisuals");
		
		AProductionBuilding_TickVisuals_Params params {};
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.TickProduction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProductionBuilding::TickProduction(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.TickProduction");
		
		AProductionBuilding_TickProduction_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.ReceiveProcductionTick
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProductionBuilding::ReceiveProcductionTick(float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.ReceiveProcductionTick");
		
		AProductionBuilding_ReceiveProcductionTick_Params params {};
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.ProductionCapacityIsFull
	 * 		Flags  -> ()
	 */
	bool AProductionBuilding::ProductionCapacityIsFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.ProductionCapacityIsFull");
		
		AProductionBuilding_ProductionCapacityIsFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.OnRep_ProductionItemsChanged
	 * 		Flags  -> ()
	 */
	void AProductionBuilding::OnRep_ProductionItemsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.OnRep_ProductionItemsChanged");
		
		AProductionBuilding_OnRep_ProductionItemsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.NotifyProductionItemStarted
	 * 		Flags  -> ()
	 */
	void AProductionBuilding::NotifyProductionItemStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.NotifyProductionItemStarted");
		
		AProductionBuilding_NotifyProductionItemStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.MulticastNotifyProductionItemStarted
	 * 		Flags  -> ()
	 */
	void AProductionBuilding::MulticastNotifyProductionItemStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.MulticastNotifyProductionItemStarted");
		
		AProductionBuilding_MulticastNotifyProductionItemStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.IsItemFinished
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AProductionBuilding::IsItemFinished(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.IsItemFinished");
		
		AProductionBuilding_IsItemFinished_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.HasItemsInProduction
	 * 		Flags  -> ()
	 */
	bool AProductionBuilding::HasItemsInProduction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.HasItemsInProduction");
		
		AProductionBuilding_HasItemsInProduction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.GetRecipeModItem
	 * 		Flags  -> ()
	 */
	class UItem* AProductionBuilding::GetRecipeModItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.GetRecipeModItem");
		
		AProductionBuilding_GetRecipeModItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.GetRecipeItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> AProductionBuilding::GetRecipeItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.GetRecipeItems");
		
		AProductionBuilding_GetRecipeItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.GetProductionTime
	 * 		Flags  -> ()
	 */
	float AProductionBuilding::GetProductionTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.GetProductionTime");
		
		AProductionBuilding_GetProductionTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.GetProductionItems
	 * 		Flags  -> ()
	 */
	TArray<struct FRecipeProducitonItem> AProductionBuilding::GetProductionItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.GetProductionItems");
		
		AProductionBuilding_GetProductionItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.GetItemProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AProductionBuilding::GetItemProgress(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.GetItemProgress");
		
		AProductionBuilding_GetItemProgress_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.GetDefaultItemResult
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle AProductionBuilding::GetDefaultItemResult()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.GetDefaultItemResult");
		
		AProductionBuilding_GetDefaultItemResult_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.FindBestRecipe
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle AProductionBuilding::FindBestRecipe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.FindBestRecipe");
		
		AProductionBuilding_FindBestRecipe_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.CanCraft
	 * 		Flags  -> ()
	 */
	bool AProductionBuilding::CanCraft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.CanCraft");
		
		AProductionBuilding_CanCraft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.CanAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AProductionBuilding::CanAddItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.CanAddItem");
		
		AProductionBuilding_CanAddItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProductionBuilding.AreIngredientsFull
	 * 		Flags  -> ()
	 */
	bool AProductionBuilding::AreIngredientsFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProductionBuilding.AreIngredientsFull");
		
		AProductionBuilding_AreIngredientsFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProductionBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProductionBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProductionBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Projectile.OnStop
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AProjectile::OnStop(const struct FHitResult& ImpactResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Projectile.OnStop");
		
		AProjectile_OnStop_Params params {};
		params.ImpactResult = ImpactResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Projectile.OnParticleSystemFinished
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UParticleSystemComponent*                    ParticleSystemComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectile::OnParticleSystemFinished(class UParticleSystemComponent* ParticleSystemComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Projectile.OnParticleSystemFinished");
		
		AProjectile_OnParticleSystemFinished_Params params {};
		params.ParticleSystemComponent = ParticleSystemComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Projectile.OnHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComp                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AProjectile::OnHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Projectile.OnHit");
		
		AProjectile_OnHit_Params params {};
		params.HitComp = HitComp;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Projectile.DestroyProjectile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bForceDestroy                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectile::DestroyProjectile(bool bForceDestroy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Projectile.DestroyProjectile");
		
		AProjectile_DestroyProjectile_Params params {};
		params.bForceDestroy = bForceDestroy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProjectile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProjectile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Projectile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPropManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPropManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.PropManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProximityInventoryComponent.RemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UProximityInventoryComponent::RemoveItem(class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProximityInventoryComponent.RemoveItem");
		
		UProximityInventoryComponent_RemoveItem_Params params {};
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProximityInventoryComponent.OnInventoryChanged
	 * 		Flags  -> ()
	 */
	void UProximityInventoryComponent::OnInventoryChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProximityInventoryComponent.OnInventoryChanged");
		
		UProximityInventoryComponent_OnInventoryChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProximityInventoryComponent.GetNumNearbyInventories
	 * 		Flags  -> ()
	 */
	int32_t UProximityInventoryComponent::GetNumNearbyInventories()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProximityInventoryComponent.GetNumNearbyInventories");
		
		UProximityInventoryComponent_GetNumNearbyInventories_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProximityInventoryComponent.GetItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UProximityInventoryComponent::GetItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProximityInventoryComponent.GetItems");
		
		UProximityInventoryComponent_GetItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProximityInventoryComponent.ClearInventories
	 * 		Flags  -> ()
	 */
	void UProximityInventoryComponent::ClearInventories()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProximityInventoryComponent.ClearInventories");
		
		UProximityInventoryComponent_ClearInventories_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProximityInventoryComponent.CacheInventories
	 * 		Flags  -> ()
	 */
	void UProximityInventoryComponent::CacheInventories()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProximityInventoryComponent.CacheInventories");
		
		UProximityInventoryComponent_CacheInventories_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProximityInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProximityInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProximityInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProxyStandInActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProxyStandInActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyStandInActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyCharacterStandInActor.OnLocalPlayerSpyGlassStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProxyCharacterStandInActor::OnLocalPlayerSpyGlassStateChanged(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyCharacterStandInActor.OnLocalPlayerSpyGlassStateChanged");
		
		AProxyCharacterStandInActor_OnLocalPlayerSpyGlassStateChanged_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProxyCharacterStandInActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProxyCharacterStandInActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyCharacterStandInActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UQuadAudioBedSounds.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UQuadAudioBedSounds::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.QuadAudioBedSounds");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuadAudioBedComponent.OnUpdateZoneAmbience
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ZoneAudioDataTableRowHandle                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsSubmerged                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UQuadAudioBedComponent::OnUpdateZoneAmbience(const struct FDataTableRowHandle& ZoneAudioDataTableRowHandle, bool bIsSubmerged)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuadAudioBedComponent.OnUpdateZoneAmbience");
		
		UQuadAudioBedComponent_OnUpdateZoneAmbience_Params params {};
		params.ZoneAudioDataTableRowHandle = ZoneAudioDataTableRowHandle;
		params.bIsSubmerged = bIsSubmerged;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UQuadAudioBedComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UQuadAudioBedComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.QuadAudioBedComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UQuadAudioSatelliteComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UQuadAudioSatelliteComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.QuadAudioSatelliteComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Objective.OnRep_ObjectiveChanged
	 * 		Flags  -> ()
	 */
	void UObjective::OnRep_ObjectiveChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Objective.OnRep_ObjectiveChanged");
		
		UObjective_OnRep_ObjectiveChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Objective.IsValidForGamePackage
	 * 		Flags  -> ()
	 */
	bool UObjective::IsValidForGamePackage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Objective.IsValidForGamePackage");
		
		UObjective_IsValidForGamePackage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Objective.IsTutorialObjective
	 * 		Flags  -> ()
	 */
	bool UObjective::IsTutorialObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Objective.IsTutorialObjective");
		
		UObjective_IsTutorialObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Objective.GetQuestDataRowHandle
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UObjective::GetQuestDataRowHandle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Objective.GetQuestDataRowHandle");
		
		UObjective_GetQuestDataRowHandle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjective.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjective::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Objective");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Quest.OnRep_QuestChanged
	 * 		Flags  -> ()
	 */
	void UQuest::OnRep_QuestChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Quest.OnRep_QuestChanged");
		
		UQuest_OnRep_QuestChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Quest.IsValidForGamePackage
	 * 		Flags  -> ()
	 */
	bool UQuest::IsValidForGamePackage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Quest.IsValidForGamePackage");
		
		UQuest_IsValidForGamePackage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Quest.IsTutorialQuest
	 * 		Flags  -> ()
	 */
	bool UQuest::IsTutorialQuest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Quest.IsTutorialQuest");
		
		UQuest_IsTutorialQuest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Quest.GetQuestDataRowHandle
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UQuest::GetQuestDataRowHandle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Quest.GetQuestDataRowHandle");
		
		UQuest_GetQuestDataRowHandle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Quest.GetObjectiveName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UQuest::GetObjectiveName(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Quest.GetObjectiveName");
		
		UQuest_GetObjectiveName_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UQuest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UQuest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Quest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.StartQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UQuestManagerComponent::StartQuest(const struct FDataTableRowHandle& QuestRowHandle, class ASurvivalPlayerState* PlayerState, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.StartQuest");
		
		UQuestManagerComponent_StartQuest_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		params.PlayerState = PlayerState;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.ResetQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UQuestManagerComponent::ResetQuest(const struct FDataTableRowHandle& QuestRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.ResetQuest");
		
		UQuestManagerComponent_ResetQuest_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.OnRep_PartyQuests
	 * 		Flags  -> ()
	 */
	void UQuestManagerComponent::OnRep_PartyQuests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.OnRep_PartyQuests");
		
		UQuestManagerComponent_OnRep_PartyQuests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.OnGlobalVariableChangedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       GlobalVariableID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            VariableValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UQuestManagerComponent::OnGlobalVariableChangedEvent(const struct FGuid& GlobalVariableID, int32_t VariableValue, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.OnGlobalVariableChangedEvent");
		
		UQuestManagerComponent_OnGlobalVariableChangedEvent_Params params {};
		params.GlobalVariableID = GlobalVariableID;
		params.VariableValue = VariableValue;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.MulticastStartQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UQuestManagerComponent::MulticastStartQuest(const struct FDataTableRowHandle& QuestRowHandle, class ASurvivalPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.MulticastStartQuest");
		
		UQuestManagerComponent_MulticastStartQuest_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.MulticastCompleteQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UQuestManagerComponent::MulticastCompleteQuest(const struct FDataTableRowHandle& QuestRowHandle, class ASurvivalPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.MulticastCompleteQuest");
		
		UQuestManagerComponent_MulticastCompleteQuest_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.MulticastCompleteObjective
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            QuestIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UQuestManagerComponent::MulticastCompleteObjective(const struct FDataTableRowHandle& QuestRowHandle, int32_t QuestIndex, class ASurvivalPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.MulticastCompleteObjective");
		
		UQuestManagerComponent_MulticastCompleteObjective_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		params.QuestIndex = QuestIndex;
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.MulticastActivateObjective
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            QuestIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UQuestManagerComponent::MulticastActivateObjective(const struct FDataTableRowHandle& QuestRowHandle, int32_t QuestIndex, class ASurvivalPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.MulticastActivateObjective");
		
		UQuestManagerComponent_MulticastActivateObjective_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		params.QuestIndex = QuestIndex;
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.IsQuestStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UQuestManagerComponent::IsQuestStarted(const struct FDataTableRowHandle& QuestRowHandle, class ASurvivalPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.IsQuestStarted");
		
		UQuestManagerComponent_IsQuestStarted_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.IsQuestCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UQuestManagerComponent::IsQuestCompleted(const struct FDataTableRowHandle& QuestRowHandle, class ASurvivalPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.IsQuestCompleted");
		
		UQuestManagerComponent_IsQuestCompleted_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.GetQuests
	 * 		Flags  -> ()
	 */
	TArray<class UQuest*> UQuestManagerComponent::GetQuests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.GetQuests");
		
		UQuestManagerComponent_GetQuests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.GetPartyQuests
	 * 		Flags  -> ()
	 */
	TArray<class UQuest*> UQuestManagerComponent::GetPartyQuests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.GetPartyQuests");
		
		UQuestManagerComponent_GetPartyQuests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.GetClientQuests
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UQuest*> UQuestManagerComponent::GetClientQuests(class ASurvivalPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.GetClientQuests");
		
		UQuestManagerComponent_GetClientQuests_Params params {};
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.GetActiveTutorialQuests
	 * 		Flags  -> ()
	 */
	TArray<class UQuest*> UQuestManagerComponent::GetActiveTutorialQuests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.GetActiveTutorialQuests");
		
		UQuestManagerComponent_GetActiveTutorialQuests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.CompleteQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UQuestManagerComponent::CompleteQuest(const struct FDataTableRowHandle& QuestRowHandle, class ASurvivalPlayerState* PlayerState, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.CompleteQuest");
		
		UQuestManagerComponent_CompleteQuest_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		params.PlayerState = PlayerState;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.CompleteObjective
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            QuestIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UQuestManagerComponent::CompleteObjective(const struct FDataTableRowHandle& QuestRowHandle, int32_t QuestIndex, class ASurvivalPlayerState* PlayerState, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.CompleteObjective");
		
		UQuestManagerComponent_CompleteObjective_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		params.QuestIndex = QuestIndex;
		params.PlayerState = PlayerState;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.AreAllObjectivesActiveAndComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UQuestManagerComponent::AreAllObjectivesActiveAndComplete(const struct FDataTableRowHandle& QuestRowHandle, class ASurvivalPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.AreAllObjectivesActiveAndComplete");
		
		UQuestManagerComponent_AreAllObjectivesActiveAndComplete_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.QuestManagerComponent.ActivateObjective
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            QuestIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UQuestManagerComponent::ActivateObjective(const struct FDataTableRowHandle& QuestRowHandle, int32_t QuestIndex, class ASurvivalPlayerState* PlayerState, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.QuestManagerComponent.ActivateObjective");
		
		UQuestManagerComponent_ActivateObjective_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		params.QuestIndex = QuestIndex;
		params.PlayerState = PlayerState;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UQuestManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UQuestManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.QuestManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URandomAnimEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URandomAnimEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.RandomAnimEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ReactionComponent.OnRep_StunState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStunState                                         PrevStunState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReactionComponent::OnRep_StunState(EStunState PrevStunState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ReactionComponent.OnRep_StunState");
		
		UReactionComponent_OnRep_StunState_Params params {};
		params.PrevStunState = PrevStunState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ReactionComponent.OnHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsKillingBlow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReactionComponent::OnHit(float Damage, const struct FDamageInfo& DamageInfo, class AController* InstigatedBy, class UBaseLODActor* DamageCauser, bool IsKillingBlow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ReactionComponent.OnHit");
		
		UReactionComponent_OnHit_Params params {};
		params.Damage = Damage;
		params.DamageInfo = DamageInfo;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		params.IsKillingBlow = IsKillingBlow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ReactionComponent.OnHealthStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHealthState                                       NewHealthState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReactionComponent::OnHealthStateChanged(EHealthState NewHealthState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ReactionComponent.OnHealthStateChanged");
		
		UReactionComponent_OnHealthStateChanged_Params params {};
		params.NewHealthState = NewHealthState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ReactionComponent.OnCharacterMovementChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACharacter*                                  Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMovementMode                                      PrevMovementMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      PreviousCustomMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReactionComponent::OnCharacterMovementChanged(class ACharacter* Character, EMovementMode PrevMovementMode, unsigned char PreviousCustomMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ReactionComponent.OnCharacterMovementChanged");
		
		UReactionComponent_OnCharacterMovementChanged_Params params {};
		params.Character = Character;
		params.PrevMovementMode = PrevMovementMode;
		params.PreviousCustomMode = PreviousCustomMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ReactionComponent.IsStunned
	 * 		Flags  -> ()
	 */
	bool UReactionComponent::IsStunned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ReactionComponent.IsStunned");
		
		UReactionComponent_IsStunned_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ReactionComponent.GetStunState
	 * 		Flags  -> ()
	 */
	EStunState UReactionComponent::GetStunState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ReactionComponent.GetStunState");
		
		UReactionComponent_GetStunState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ReactionComponent.GetStunRatio
	 * 		Flags  -> ()
	 */
	float UReactionComponent::GetStunRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ReactionComponent.GetStunRatio");
		
		UReactionComponent_GetStunRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ReactionComponent.GetStunDuration
	 * 		Flags  -> ()
	 */
	float UReactionComponent::GetStunDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ReactionComponent.GetStunDuration");
		
		UReactionComponent_GetStunDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ReactionComponent.GetMaxStun
	 * 		Flags  -> ()
	 */
	float UReactionComponent::GetMaxStun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ReactionComponent.GetMaxStun");
		
		UReactionComponent_GetMaxStun_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ReactionComponent.CanBeStunned
	 * 		Flags  -> ()
	 */
	bool UReactionComponent::CanBeStunned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ReactionComponent.CanBeStunned");
		
		UReactionComponent_CanBeStunned_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ReactionComponent.BeginStun
	 * 		Flags  -> ()
	 */
	void UReactionComponent::BeginStun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ReactionComponent.BeginStun");
		
		UReactionComponent_BeginStun_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReactionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReactionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ReactionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URelevanceOptimizationInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URelevanceOptimizationInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.RelevanceOptimizationInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RemoteInteractionActor.Use
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARemoteInteractionActor::Use(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RemoteInteractionActor.Use");
		
		ARemoteInteractionActor_Use_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RemoteInteractionActor.OnRep_InteractedByList
	 * 		Flags  -> ()
	 */
	void ARemoteInteractionActor::OnRep_InteractedByList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RemoteInteractionActor.OnRep_InteractedByList");
		
		ARemoteInteractionActor_OnRep_InteractedByList_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RemoteInteractionActor.HandleRemoteInteractionState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsRemoteInteracted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARemoteInteractionActor::HandleRemoteInteractionState(bool bIsRemoteInteracted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RemoteInteractionActor.HandleRemoteInteractionState");
		
		ARemoteInteractionActor_HandleRemoteInteractionState_Params params {};
		params.bIsRemoteInteracted = bIsRemoteInteracted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RemoteInteractionActor.GetUseText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText ARemoteInteractionActor::GetUseText(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RemoteInteractionActor.GetUseText");
		
		ARemoteInteractionActor_GetUseText_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RemoteInteractionActor.GetUseInteractionType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EInteractionType ARemoteInteractionActor::GetUseInteractionType(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RemoteInteractionActor.GetUseInteractionType");
		
		ARemoteInteractionActor_GetUseInteractionType_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RemoteInteractionActor.CanUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARemoteInteractionActor::CanUse(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RemoteInteractionActor.CanUse");
		
		ARemoteInteractionActor_CanUse_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARemoteInteractionActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARemoteInteractionActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.RemoteInteractionActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URenderTargetManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URenderTargetManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.RenderTargetManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RenderTargetPublisher.UnregisterAsRenderTargetPublisher
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UManagedRenderTargetObject*                  ManagedRTO                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URenderTargetPublisher::UnregisterAsRenderTargetPublisher(class UManagedRenderTargetObject* ManagedRTO)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RenderTargetPublisher.UnregisterAsRenderTargetPublisher");
		
		URenderTargetPublisher_UnregisterAsRenderTargetPublisher_Params params {};
		params.ManagedRTO = ManagedRTO;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RenderTargetPublisher.RegisterAsRenderTargetPublisher
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UManagedRenderTargetObject*                  ManagedRTO                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URenderTargetPublisher::RegisterAsRenderTargetPublisher(class UManagedRenderTargetObject* ManagedRTO)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RenderTargetPublisher.RegisterAsRenderTargetPublisher");
		
		URenderTargetPublisher_RegisterAsRenderTargetPublisher_Params params {};
		params.ManagedRTO = ManagedRTO;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RenderTargetPublisher.OnPublisherRenderTargetWillBeDestroyed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UManagedRenderTargetObject*                  ManagedRTO                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTextureRenderTarget2D*                      RenderTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URenderTargetPublisher::OnPublisherRenderTargetWillBeDestroyed(class UManagedRenderTargetObject* ManagedRTO, class UTextureRenderTarget2D* RenderTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RenderTargetPublisher.OnPublisherRenderTargetWillBeDestroyed");
		
		URenderTargetPublisher_OnPublisherRenderTargetWillBeDestroyed_Params params {};
		params.ManagedRTO = ManagedRTO;
		params.RenderTarget = RenderTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RenderTargetPublisher.OnPublisherRenderTargetCreated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UManagedRenderTargetObject*                  ManagedRTO                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTextureRenderTarget2D*                      RenderTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URenderTargetPublisher::OnPublisherRenderTargetCreated(class UManagedRenderTargetObject* ManagedRTO, class UTextureRenderTarget2D* RenderTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RenderTargetPublisher.OnPublisherRenderTargetCreated");
		
		URenderTargetPublisher_OnPublisherRenderTargetCreated_Params params {};
		params.ManagedRTO = ManagedRTO;
		params.RenderTarget = RenderTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URenderTargetPublisher.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URenderTargetPublisher::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.RenderTargetPublisher");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RenderTargetSubscriber.UnregisterAsRenderTargetSubscriber
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UManagedRenderTargetObject*                  ManagedRTO                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URenderTargetSubscriber::UnregisterAsRenderTargetSubscriber(class UManagedRenderTargetObject* ManagedRTO)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RenderTargetSubscriber.UnregisterAsRenderTargetSubscriber");
		
		URenderTargetSubscriber_UnregisterAsRenderTargetSubscriber_Params params {};
		params.ManagedRTO = ManagedRTO;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RenderTargetSubscriber.RegisterAsRenderTargetSubscriber
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UManagedRenderTargetObject*                  ManagedRTO                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URenderTargetSubscriber::RegisterAsRenderTargetSubscriber(class UManagedRenderTargetObject* ManagedRTO)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RenderTargetSubscriber.RegisterAsRenderTargetSubscriber");
		
		URenderTargetSubscriber_RegisterAsRenderTargetSubscriber_Params params {};
		params.ManagedRTO = ManagedRTO;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RenderTargetSubscriber.OnSubscribedRenderTargetWillBeUnavailable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UManagedRenderTargetObject*                  ManagedRTO                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTextureRenderTarget2D*                      RenderTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URenderTargetSubscriber::OnSubscribedRenderTargetWillBeUnavailable(class UManagedRenderTargetObject* ManagedRTO, class UTextureRenderTarget2D* RenderTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RenderTargetSubscriber.OnSubscribedRenderTargetWillBeUnavailable");
		
		URenderTargetSubscriber_OnSubscribedRenderTargetWillBeUnavailable_Params params {};
		params.ManagedRTO = ManagedRTO;
		params.RenderTarget = RenderTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RenderTargetSubscriber.OnSubscribedRenderTargetAvailable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UManagedRenderTargetObject*                  ManagedRTO                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTextureRenderTarget2D*                      RenderTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URenderTargetSubscriber::OnSubscribedRenderTargetAvailable(class UManagedRenderTargetObject* ManagedRTO, class UTextureRenderTarget2D* RenderTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RenderTargetSubscriber.OnSubscribedRenderTargetAvailable");
		
		URenderTargetSubscriber_OnSubscribedRenderTargetAvailable_Params params {};
		params.ManagedRTO = ManagedRTO;
		params.RenderTarget = RenderTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URenderTargetSubscriber.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URenderTargetSubscriber::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.RenderTargetSubscriber");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReplicationGraphNode_AlwaysRelevant_ForConnection_Maine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReplicationGraphNode_AlwaysRelevant_ForConnection_Maine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ReplicationGraphNode_AlwaysRelevant_ForConnection_Maine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceAnalyzer.OnRep_PowerReservoir
	 * 		Flags  -> ()
	 */
	void AResourceAnalyzer::OnRep_PowerReservoir()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceAnalyzer.OnRep_PowerReservoir");
		
		AResourceAnalyzer_OnRep_PowerReservoir_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceAnalyzer.MulticastPlayAnimMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AResourceAnalyzer::MulticastPlayAnimMontage(class UAnimMontage* AnimMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceAnalyzer.MulticastPlayAnimMontage");
		
		AResourceAnalyzer_MulticastPlayAnimMontage_Params params {};
		params.AnimMontage = AnimMontage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceAnalyzer.IsFullyCharged
	 * 		Flags  -> ()
	 */
	bool AResourceAnalyzer::IsFullyCharged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceAnalyzer.IsFullyCharged");
		
		AResourceAnalyzer_IsFullyCharged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceAnalyzer.IsCharging
	 * 		Flags  -> ()
	 */
	bool AResourceAnalyzer::IsCharging()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceAnalyzer.IsCharging");
		
		AResourceAnalyzer_IsCharging_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceAnalyzer.HasCharges
	 * 		Flags  -> ()
	 */
	bool AResourceAnalyzer::HasCharges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceAnalyzer.HasCharges");
		
		AResourceAnalyzer_HasCharges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceAnalyzer.GetNextChargeTime
	 * 		Flags  -> ()
	 */
	float AResourceAnalyzer::GetNextChargeTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceAnalyzer.GetNextChargeTime");
		
		AResourceAnalyzer_GetNextChargeTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceAnalyzer.GetChargeCount
	 * 		Flags  -> ()
	 */
	int32_t AResourceAnalyzer::GetChargeCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceAnalyzer.GetChargeCount");
		
		AResourceAnalyzer_GetChargeCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceAnalyzer.GetChargeCapacity
	 * 		Flags  -> ()
	 */
	int32_t AResourceAnalyzer::GetChargeCapacity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceAnalyzer.GetChargeCapacity");
		
		AResourceAnalyzer_GetChargeCapacity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AResourceAnalyzer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AResourceAnalyzer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ResourceAnalyzer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceScannerBuilding.HandleSingleUseInteractingActorChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidgetInteractComponent*                    Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InteractingActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AResourceScannerBuilding::HandleSingleUseInteractingActorChanged(class UWidgetInteractComponent* Sender, class AActor* InteractingActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceScannerBuilding.HandleSingleUseInteractingActorChanged");
		
		AResourceScannerBuilding_HandleSingleUseInteractingActorChanged_Params params {};
		params.Sender = Sender;
		params.InteractingActor = InteractingActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AResourceScannerBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AResourceScannerBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ResourceScannerBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceSurveyComponent.UnregisterManualSource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceSurveyComponent::UnregisterManualSource(class UObject* Source)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceSurveyComponent.UnregisterManualSource");
		
		UResourceSurveyComponent_UnregisterManualSource_Params params {};
		params.Source = Source;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceSurveyComponent.ToggleScanEverything
	 * 		Flags  -> ()
	 */
	void UResourceSurveyComponent::ToggleScanEverything()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceSurveyComponent.ToggleScanEverything");
		
		UResourceSurveyComponent_ToggleScanEverything_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceSurveyComponent.ShowSurveyingInterface
	 * 		Flags  -> ()
	 */
	void UResourceSurveyComponent::ShowSurveyingInterface()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceSurveyComponent.ShowSurveyingInterface");
		
		UResourceSurveyComponent_ShowSurveyingInterface_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceSurveyComponent.RegisterManualSource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceSurveyComponent::RegisterManualSource(class UObject* Source)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceSurveyComponent.RegisterManualSource");
		
		UResourceSurveyComponent_RegisterManualSource_Params params {};
		params.Source = Source;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceSurveyComponent.OnRep_SurveyedResource
	 * 		Flags  -> ()
	 */
	void UResourceSurveyComponent::OnRep_SurveyedResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceSurveyComponent.OnRep_SurveyedResource");
		
		UResourceSurveyComponent_OnRep_SurveyedResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceSurveyComponent.MulticastReplicateDataChunk
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            StartIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<unsigned char>                              Buffer                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UResourceSurveyComponent::MulticastReplicateDataChunk(int32_t StartIndex, TArray<unsigned char> Buffer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceSurveyComponent.MulticastReplicateDataChunk");
		
		UResourceSurveyComponent_MulticastReplicateDataChunk_Params params {};
		params.StartIndex = StartIndex;
		params.Buffer = Buffer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceSurveyComponent.GetSurveyedResource
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UResourceSurveyComponent::GetSurveyedResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceSurveyComponent.GetSurveyedResource");
		
		UResourceSurveyComponent_GetSurveyedResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceSurveyComponent.GetSurveyedRegionTexture
	 * 		Flags  -> ()
	 */
	class UTexture2D* UResourceSurveyComponent::GetSurveyedRegionTexture()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceSurveyComponent.GetSurveyedRegionTexture");
		
		UResourceSurveyComponent_GetSurveyedRegionTexture_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceSurveyComponent.GetLastScanWorldHours
	 * 		Flags  -> ()
	 */
	float UResourceSurveyComponent::GetLastScanWorldHours()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceSurveyComponent.GetLastScanWorldHours");
		
		UResourceSurveyComponent_GetLastScanWorldHours_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceSurveyComponent.GetLastScanPlayerName
	 * 		Flags  -> ()
	 */
	class FString UResourceSurveyComponent::GetLastScanPlayerName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceSurveyComponent.GetLastScanPlayerName");
		
		UResourceSurveyComponent_GetLastScanPlayerName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceSurveyComponent.GetHeatmapTexture
	 * 		Flags  -> ()
	 */
	class UTexture2D* UResourceSurveyComponent::GetHeatmapTexture()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceSurveyComponent.GetHeatmapTexture");
		
		UResourceSurveyComponent_GetHeatmapTexture_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ResourceSurveyComponent.ActivateAllSurveyors
	 * 		Flags  -> ()
	 */
	void UResourceSurveyComponent::ActivateAllSurveyors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ResourceSurveyComponent.ActivateAllSurveyors");
		
		UResourceSurveyComponent_ActivateAllSurveyors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UResourceSurveyComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UResourceSurveyComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ResourceSurveyComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UResourceSurveyOriginComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UResourceSurveyOriginComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ResourceSurveyOriginComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RespawnableInstancedMeshGroup.Spawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemSpawnPointData                         SpawnPoint                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* ARespawnableInstancedMeshGroup::Spawn(const struct FItemSpawnPointData& SpawnPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RespawnableInstancedMeshGroup.Spawn");
		
		ARespawnableInstancedMeshGroup_Spawn_Params params {};
		params.SpawnPoint = SpawnPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RespawnableInstancedMeshGroup.OnFoliageDamaged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Sender                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARespawnableInstancedMeshGroup::OnFoliageDamaged(class AActor* Sender, float Damage, const struct FDamageEvent& DamageEvent, const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RespawnableInstancedMeshGroup.OnFoliageDamaged");
		
		ARespawnableInstancedMeshGroup_OnFoliageDamaged_Params params {};
		params.Sender = Sender;
		params.Damage = Damage;
		params.DamageEvent = DamageEvent;
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RespawnableInstancedMeshGroup.GetSpawnPoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FItemSpawnPointData>                 SpawnPoints                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void ARespawnableInstancedMeshGroup::GetSpawnPoints(TArray<struct FItemSpawnPointData>* SpawnPoints)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RespawnableInstancedMeshGroup.GetSpawnPoints");
		
		ARespawnableInstancedMeshGroup_GetSpawnPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SpawnPoints != nullptr)
			*SpawnPoints = params.SpawnPoints;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RespawnableInstancedMeshGroup.GetItemSpawnGroupData
	 * 		Flags  -> ()
	 */
	class UClass* ARespawnableInstancedMeshGroup::GetItemSpawnGroupData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RespawnableInstancedMeshGroup.GetItemSpawnGroupData");
		
		ARespawnableInstancedMeshGroup_GetItemSpawnGroupData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RespawnableInstancedMeshGroup.DoesSpawnActors
	 * 		Flags  -> ()
	 */
	bool ARespawnableInstancedMeshGroup::DoesSpawnActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RespawnableInstancedMeshGroup.DoesSpawnActors");
		
		ARespawnableInstancedMeshGroup_DoesSpawnActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RespawnableInstancedMeshGroup.Despawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemSpawnPointData                         SpawnPoint                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARespawnableInstancedMeshGroup::Despawn(const struct FItemSpawnPointData& SpawnPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RespawnableInstancedMeshGroup.Despawn");
		
		ARespawnableInstancedMeshGroup_Despawn_Params params {};
		params.SpawnPoint = SpawnPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.RespawnableInstancedMeshGroup.BuildInstances
	 * 		Flags  -> ()
	 */
	void ARespawnableInstancedMeshGroup::BuildInstances()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.RespawnableInstancedMeshGroup.BuildInstances");
		
		ARespawnableInstancedMeshGroup_BuildInstances_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARespawnableInstancedMeshGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARespawnableInstancedMeshGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.RespawnableInstancedMeshGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARestingSpot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARestingSpot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.RestingSpot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USaveGameSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USaveGameSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SaveGameSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveGameHeaderData.GetSaveGameScreenshotPath
	 * 		Flags  -> ()
	 */
	class FString USaveGameHeaderData::GetSaveGameScreenshotPath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveGameHeaderData.GetSaveGameScreenshotPath");
		
		USaveGameHeaderData_GetSaveGameScreenshotPath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USaveGameHeaderData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USaveGameHeaderData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SaveGameHeaderData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActorHeaderData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActorHeaderData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ActorHeaderData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UComponentHeaderData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UComponentHeaderData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ComponentHeaderData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadWidget.SetMenuMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESaveLoadMenuMode                                  MenuMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USaveLoadWidget::SetMenuMode(ESaveLoadMenuMode MenuMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadWidget.SetMenuMode");
		
		USaveLoadWidget_SetMenuMode_Params params {};
		params.MenuMode = MenuMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SaveLoadWidget.OnMenuModeSet
	 * 		Flags  -> ()
	 */
	void USaveLoadWidget::OnMenuModeSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SaveLoadWidget.OnMenuModeSet");
		
		USaveLoadWidget_OnMenuModeSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USaveLoadWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USaveLoadWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SaveLoadWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ScanSwitch.OnStopScan
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInteractSuccess                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScanSwitch::OnStopScan(bool bInteractSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ScanSwitch.OnStopScan");
		
		AScanSwitch_OnStopScan_Params params {};
		params.bInteractSuccess = bInteractSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ScanSwitch.OnStartScan
	 * 		Flags  -> ()
	 */
	void AScanSwitch::OnStartScan()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ScanSwitch.OnStartScan");
		
		AScanSwitch_OnStartScan_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ScanSwitch.OnRep_CurrentUser
	 * 		Flags  -> ()
	 */
	void AScanSwitch::OnRep_CurrentUser()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ScanSwitch.OnRep_CurrentUser");
		
		AScanSwitch_OnRep_CurrentUser_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ScanSwitch.MulticastStopScan
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInteractSuccess                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScanSwitch::MulticastStopScan(bool bInteractSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ScanSwitch.MulticastStopScan");
		
		AScanSwitch_MulticastStopScan_Params params {};
		params.bInteractSuccess = bInteractSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ScanSwitch.MulticastStartScan
	 * 		Flags  -> ()
	 */
	void AScanSwitch::MulticastStartScan()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ScanSwitch.MulticastStartScan");
		
		AScanSwitch_MulticastStartScan_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AScanSwitch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AScanSwitch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ScanSwitch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ScienceCollectable.SetScienceAmount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScienceCollectable::SetScienceAmount(int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ScienceCollectable.SetScienceAmount");
		
		AScienceCollectable_SetScienceAmount_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ScienceCollectable.OnOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AScienceCollectable::OnOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ScienceCollectable.OnOverlap");
		
		AScienceCollectable_OnOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AScienceCollectable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AScienceCollectable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ScienceCollectable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ScreenEffectComponent.OnStatusEffectRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStatusEffect*                               StatusEffect                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenEffectComponent::OnStatusEffectRemoved(class AActor* Owner, class UStatusEffect* StatusEffect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ScreenEffectComponent.OnStatusEffectRemoved");
		
		UScreenEffectComponent_OnStatusEffectRemoved_Params params {};
		params.Owner = Owner;
		params.StatusEffect = StatusEffect;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ScreenEffectComponent.OnStatusEffectAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStatusEffect*                               StatusEffect                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenEffectComponent::OnStatusEffectAdded(class AActor* Owner, class UStatusEffect* StatusEffect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ScreenEffectComponent.OnStatusEffectAdded");
		
		UScreenEffectComponent_OnStatusEffectAdded_Params params {};
		params.Owner = Owner;
		params.StatusEffect = StatusEffect;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ScreenEffectComponent.EndScreenEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScreenEffectData*                           ScreenEffectData                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenEffectComponent::EndScreenEffect(class UScreenEffectData* ScreenEffectData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ScreenEffectComponent.EndScreenEffect");
		
		UScreenEffectComponent_EndScreenEffect_Params params {};
		params.ScreenEffectData = ScreenEffectData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ScreenEffectComponent.BeginScreenEffectWithDirection
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScreenEffectData*                           ScreenEffectData                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenEffectComponent::BeginScreenEffectWithDirection(class UScreenEffectData* ScreenEffectData, const struct FVector& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ScreenEffectComponent.BeginScreenEffectWithDirection");
		
		UScreenEffectComponent_BeginScreenEffectWithDirection_Params params {};
		params.ScreenEffectData = ScreenEffectData;
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ScreenEffectComponent.BeginScreenEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScreenEffectData*                           ScreenEffectData                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenEffectComponent::BeginScreenEffect(class UScreenEffectData* ScreenEffectData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ScreenEffectComponent.BeginScreenEffect");
		
		UScreenEffectComponent_BeginScreenEffect_Params params {};
		params.ScreenEffectData = ScreenEffectData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScreenEffectComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScreenEffectComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ScreenEffectComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScreenEffectData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScreenEffectData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ScreenEffectData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Scripts.OpenUpgradesUIForConversationOwner
	 * 		Flags  -> ()
	 */
	void UScripts::OpenUpgradesUIForConversationOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Scripts.OpenUpgradesUIForConversationOwner");
		
		UScripts_OpenUpgradesUIForConversationOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Scripts.OpenScienceStoreUIForConversationOwner
	 * 		Flags  -> ()
	 */
	void UScripts::OpenScienceStoreUIForConversationOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Scripts.OpenScienceStoreUIForConversationOwner");
		
		UScripts_OpenScienceStoreUIForConversationOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Scripts.OpenBurgleQuestUIForConversationOwner
	 * 		Flags  -> ()
	 */
	void UScripts::OpenBurgleQuestUIForConversationOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Scripts.OpenBurgleQuestUIForConversationOwner");
		
		UScripts_OpenBurgleQuestUIForConversationOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Scripts.LogObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       Object                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScripts::LogObject(const struct FGuid& Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Scripts.LogObject");
		
		UScripts_LogObject_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Scripts.GiveSpeakerTechChip
	 * 		Flags  -> ()
	 */
	void UScripts::GiveSpeakerTechChip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Scripts.GiveSpeakerTechChip");
		
		UScripts_GiveSpeakerTechChip_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Scripts.EndEarlyAccessContent
	 * 		Flags  -> ()
	 */
	void UScripts::EndEarlyAccessContent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Scripts.EndEarlyAccessContent");
		
		UScripts_EndEarlyAccessContent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScripts.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScripts::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Scripts");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASecurityCamera.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASecurityCamera::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SecurityCamera");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASecurityMonitor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASecurityMonitor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SecurityMonitor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SignBuilding.OnRep_CurrentSignDataHandle
	 * 		Flags  -> ()
	 */
	void ASignBuilding::OnRep_CurrentSignDataHandle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SignBuilding.OnRep_CurrentSignDataHandle");
		
		ASignBuilding_OnRep_CurrentSignDataHandle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SignBuilding.GetValidSignData
	 * 		Flags  -> ()
	 */
	TArray<struct FDataTableRowHandle> ASignBuilding::GetValidSignData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SignBuilding.GetValidSignData");
		
		ASignBuilding_GetValidSignData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SignBuilding.GetSelectedSignData
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle ASignBuilding::GetSelectedSignData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SignBuilding.GetSelectedSignData");
		
		ASignBuilding_GetSelectedSignData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASignBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASignBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SignBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SimpleSpeaker.GetSpeaker
	 * 		Flags  -> ()
	 */
	struct FSpeakerReference ASimpleSpeaker::GetSpeaker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SimpleSpeaker.GetSpeaker");
		
		ASimpleSpeaker_GetSpeaker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SimpleSpeaker.GetCharacterName
	 * 		Flags  -> ()
	 */
	struct FLocString ASimpleSpeaker::GetCharacterName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SimpleSpeaker.GetCharacterName");
		
		ASimpleSpeaker_GetCharacterName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASimpleSpeaker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASimpleSpeaker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SimpleSpeaker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnAssociatedActor.OnRep_IsEnabled
	 * 		Flags  -> ()
	 */
	void ASpawnAssociatedActor::OnRep_IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnAssociatedActor.OnRep_IsEnabled");
		
		ASpawnAssociatedActor_OnRep_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnAssociatedActor.OnRegisteredActorDestroyed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               LODActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnAssociatedActor::OnRegisteredActorDestroyed(class UBaseLODActor* LODActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnAssociatedActor.OnRegisteredActorDestroyed");
		
		ASpawnAssociatedActor_OnRegisteredActorDestroyed_Params params {};
		params.LODActor = LODActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnAssociatedActor.IsEnabled
	 * 		Flags  -> ()
	 */
	bool ASpawnAssociatedActor::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnAssociatedActor.IsEnabled");
		
		ASpawnAssociatedActor_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpawnAssociatedActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpawnAssociatedActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SpawnAssociatedActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedEffectActor.OnDeath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASpawnedEffectActor::OnDeath(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedEffectActor.OnDeath");
		
		ASpawnedEffectActor_OnDeath_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpawnedEffectActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpawnedEffectActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SpawnedEffectActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.Unfreeze
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AController*                                 InstigatorController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItemDroplet::Unfreeze(class AController* InstigatorController, class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.Unfreeze");
		
		ASpawnedItemDroplet_Unfreeze_Params params {};
		params.InstigatorController = InstigatorController;
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.SetServings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Servings                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItemDroplet::SetServings(int32_t Servings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.SetServings");
		
		ASpawnedItemDroplet_SetServings_Params params {};
		params.Servings = Servings;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.ServerDrink
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItemDroplet::ServerDrink(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.ServerDrink");
		
		ASpawnedItemDroplet_ServerDrink_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.PlayContactWobble
	 * 		Flags  -> ()
	 */
	void ASpawnedItemDroplet::PlayContactWobble()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.PlayContactWobble");
		
		ASpawnedItemDroplet_PlayContactWobble_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.PlayContactEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItemDroplet::PlayContactEffects(const struct FVector& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.PlayContactEffects");
		
		ASpawnedItemDroplet_PlayContactEffects_Params params {};
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.OnRep_Servings
	 * 		Flags  -> ()
	 */
	void ASpawnedItemDroplet::OnRep_Servings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.OnRep_Servings");
		
		ASpawnedItemDroplet_OnRep_Servings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.OnRep_ActorsContained
	 * 		Flags  -> ()
	 */
	void ASpawnedItemDroplet::OnRep_ActorsContained()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.OnRep_ActorsContained");
		
		ASpawnedItemDroplet_OnRep_ActorsContained_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.OnDropletUnfrozen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AController*                                 InstigatorController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItemDroplet::OnDropletUnfrozen(class AController* InstigatorController, class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.OnDropletUnfrozen");
		
		ASpawnedItemDroplet_OnDropletUnfrozen_Params params {};
		params.InstigatorController = InstigatorController;
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.GetVolume
	 * 		Flags  -> ()
	 */
	float ASpawnedItemDroplet::GetVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.GetVolume");
		
		ASpawnedItemDroplet_GetVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.GetServings
	 * 		Flags  -> ()
	 */
	int32_t ASpawnedItemDroplet::GetServings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.GetServings");
		
		ASpawnedItemDroplet_GetServings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.GetRadius
	 * 		Flags  -> ()
	 */
	float ASpawnedItemDroplet::GetRadius()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.GetRadius");
		
		ASpawnedItemDroplet_GetRadius_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.GetOccupiedVolume
	 * 		Flags  -> ()
	 */
	float ASpawnedItemDroplet::GetOccupiedVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.GetOccupiedVolume");
		
		ASpawnedItemDroplet_GetOccupiedVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.GetNumActorContained
	 * 		Flags  -> ()
	 */
	int32_t ASpawnedItemDroplet::GetNumActorContained()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.GetNumActorContained");
		
		ASpawnedItemDroplet_GetNumActorContained_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.GetAvailableVolume
	 * 		Flags  -> ()
	 */
	float ASpawnedItemDroplet::GetAvailableVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.GetAvailableVolume");
		
		ASpawnedItemDroplet_GetAvailableVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.GetActorContained
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AActor* ASpawnedItemDroplet::GetActorContained(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.GetActorContained");
		
		ASpawnedItemDroplet_GetActorContained_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.EjectRandomActor
	 * 		Flags  -> ()
	 */
	void ASpawnedItemDroplet::EjectRandomActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.EjectRandomActor");
		
		ASpawnedItemDroplet_EjectRandomActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.EjectAllActors
	 * 		Flags  -> ()
	 */
	void ASpawnedItemDroplet::EjectAllActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.EjectAllActors");
		
		ASpawnedItemDroplet_EjectAllActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.EjectActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItemDroplet::EjectActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.EjectActor");
		
		ASpawnedItemDroplet_EjectActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemDroplet.AdjustServings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Delta                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnedItemDroplet::AdjustServings(int32_t Delta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemDroplet.AdjustServings");
		
		ASpawnedItemDroplet_AdjustServings_Params params {};
		params.Delta = Delta;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpawnedItemDroplet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpawnedItemDroplet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SpawnedItemDroplet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxySpawnedItemActor.RemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       InItem                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UProxySpawnedItemActor::RemoveItem(class UItem* InItem, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxySpawnedItemActor.RemoveItem");
		
		UProxySpawnedItemActor_RemoveItem_Params params {};
		params.InItem = InItem;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxySpawnedItemActor.GetItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UProxySpawnedItemActor::GetItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxySpawnedItemActor.GetItems");
		
		UProxySpawnedItemActor_GetItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxySpawnedItemActor.GetDropItemTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       InItem                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform UProxySpawnedItemActor::GetDropItemTransform(class UItem* InItem, const struct FVector& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxySpawnedItemActor.GetDropItemTransform");
		
		UProxySpawnedItemActor_GetDropItemTransform_Params params {};
		params.InItem = InItem;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxySpawnedItemActor.CanAddItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UItem*>                               InItems                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UProxySpawnedItemActor::CanAddItems(TArray<class UItem*> InItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxySpawnedItemActor.CanAddItems");
		
		UProxySpawnedItemActor_CanAddItems_Params params {};
		params.InItems = InItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxySpawnedItemActor.CanAddItemRowHandles
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 ItemRowHandles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UProxySpawnedItemActor::CanAddItemRowHandles(TArray<struct FDataTableRowHandle> ItemRowHandles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxySpawnedItemActor.CanAddItemRowHandles");
		
		UProxySpawnedItemActor_CanAddItemRowHandles_Params params {};
		params.ItemRowHandles = ItemRowHandles;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxySpawnedItemActor.CanAddItemRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UProxySpawnedItemActor::CanAddItemRowHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxySpawnedItemActor.CanAddItemRowHandle");
		
		UProxySpawnedItemActor_CanAddItemRowHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxySpawnedItemActor.CanAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       InItem                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UProxySpawnedItemActor::CanAddItem(class UItem* InItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxySpawnedItemActor.CanAddItem");
		
		UProxySpawnedItemActor_CanAddItem_Params params {};
		params.InItem = InItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxySpawnedItemActor.AddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       InItem                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNewItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UProxySpawnedItemActor::AddItem(class UItem* InItem, bool bIsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxySpawnedItemActor.AddItem");
		
		UProxySpawnedItemActor_AddItem_Params params {};
		params.InItem = InItem;
		params.bIsNewItem = bIsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxySpawnedItemActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxySpawnedItemActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxySpawnedItemActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxySpawnedItemDropletActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxySpawnedItemDropletActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxySpawnedItemDropletActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemLODActor.RemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       InItem                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t USpawnedItemLODActor::RemoveItem(class UItem* InItem, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemLODActor.RemoveItem");
		
		USpawnedItemLODActor_RemoveItem_Params params {};
		params.InItem = InItem;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemLODActor.GetItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> USpawnedItemLODActor::GetItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemLODActor.GetItems");
		
		USpawnedItemLODActor_GetItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemLODActor.GetItem
	 * 		Flags  -> ()
	 */
	class UItem* USpawnedItemLODActor::GetItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemLODActor.GetItem");
		
		USpawnedItemLODActor_GetItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemLODActor.GetDropItemTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       InItem                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform USpawnedItemLODActor::GetDropItemTransform(class UItem* InItem, const struct FVector& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemLODActor.GetDropItemTransform");
		
		USpawnedItemLODActor_GetDropItemTransform_Params params {};
		params.InItem = InItem;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemLODActor.CanAddItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UItem*>                               InItems                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool USpawnedItemLODActor::CanAddItems(TArray<class UItem*> InItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemLODActor.CanAddItems");
		
		USpawnedItemLODActor_CanAddItems_Params params {};
		params.InItems = InItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemLODActor.CanAddItemRowHandles
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 ItemRowHandles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool USpawnedItemLODActor::CanAddItemRowHandles(TArray<struct FDataTableRowHandle> ItemRowHandles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemLODActor.CanAddItemRowHandles");
		
		USpawnedItemLODActor_CanAddItemRowHandles_Params params {};
		params.ItemRowHandles = ItemRowHandles;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemLODActor.CanAddItemRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool USpawnedItemLODActor::CanAddItemRowHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemLODActor.CanAddItemRowHandle");
		
		USpawnedItemLODActor_CanAddItemRowHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemLODActor.CanAddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       InItem                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USpawnedItemLODActor::CanAddItem(class UItem* InItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemLODActor.CanAddItem");
		
		USpawnedItemLODActor_CanAddItem_Params params {};
		params.InItem = InItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnedItemLODActor.AddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       InItem                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNewItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USpawnedItemLODActor::AddItem(class UItem* InItem, bool bIsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnedItemLODActor.AddItem");
		
		USpawnedItemLODActor_AddItem_Params params {};
		params.InItem = InItem;
		params.bIsNewItem = bIsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpawnedItemLODActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpawnedItemLODActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SpawnedItemLODActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpawnedItemDropletLODActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpawnedItemDropletLODActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SpawnedItemDropletLODActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnPointProviderInterface.Spawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemSpawnPointData                         SpawnPoint                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* USpawnPointProviderInterface::Spawn(const struct FItemSpawnPointData& SpawnPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnPointProviderInterface.Spawn");
		
		USpawnPointProviderInterface_Spawn_Params params {};
		params.SpawnPoint = SpawnPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnPointProviderInterface.GetSpawnPoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FItemSpawnPointData>                 SpawnPoints                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void USpawnPointProviderInterface::GetSpawnPoints(TArray<struct FItemSpawnPointData>* SpawnPoints)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnPointProviderInterface.GetSpawnPoints");
		
		USpawnPointProviderInterface_GetSpawnPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SpawnPoints != nullptr)
			*SpawnPoints = params.SpawnPoints;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnPointProviderInterface.GetProviderID
	 * 		Flags  -> ()
	 */
	struct FGuid USpawnPointProviderInterface::GetProviderID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnPointProviderInterface.GetProviderID");
		
		USpawnPointProviderInterface_GetProviderID_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnPointProviderInterface.GetItemSpawnGroupData
	 * 		Flags  -> ()
	 */
	class UClass* USpawnPointProviderInterface::GetItemSpawnGroupData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnPointProviderInterface.GetItemSpawnGroupData");
		
		USpawnPointProviderInterface_GetItemSpawnGroupData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnPointProviderInterface.DoesSpawnActors
	 * 		Flags  -> ()
	 */
	bool USpawnPointProviderInterface::DoesSpawnActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnPointProviderInterface.DoesSpawnActors");
		
		USpawnPointProviderInterface_DoesSpawnActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpawnPointProviderInterface.Despawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemSpawnPointData                         SpawnPoint                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USpawnPointProviderInterface::Despawn(const struct FItemSpawnPointData& SpawnPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpawnPointProviderInterface.Despawn");
		
		USpawnPointProviderInterface_Despawn_Params params {};
		params.SpawnPoint = SpawnPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpawnPointProviderInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpawnPointProviderInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SpawnPointProviderInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpeakerFunctionLibrary.GetSpeakerBundleVOPrefix
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSpeakerBundle                              Bundle                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class FString USpeakerFunctionLibrary::GetSpeakerBundleVOPrefix(const struct FSpeakerBundle& Bundle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpeakerFunctionLibrary.GetSpeakerBundleVOPrefix");
		
		USpeakerFunctionLibrary_GetSpeakerBundleVOPrefix_Params params {};
		params.Bundle = Bundle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpeakerFunctionLibrary.GetSpeakerBundleObjectName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSpeakerBundle                              Bundle                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class FString USpeakerFunctionLibrary::GetSpeakerBundleObjectName(const struct FSpeakerBundle& Bundle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpeakerFunctionLibrary.GetSpeakerBundleObjectName");
		
		USpeakerFunctionLibrary_GetSpeakerBundleObjectName_Params params {};
		params.Bundle = Bundle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpeakerFunctionLibrary.GetSpeakerBundleIsUniqueNPC
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSpeakerBundle                              Bundle                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool USpeakerFunctionLibrary::GetSpeakerBundleIsUniqueNPC(const struct FSpeakerBundle& Bundle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpeakerFunctionLibrary.GetSpeakerBundleIsUniqueNPC");
		
		USpeakerFunctionLibrary_GetSpeakerBundleIsUniqueNPC_Params params {};
		params.Bundle = Bundle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpeakerFunctionLibrary.GetSpeakerBundleID
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSpeakerBundle                              Bundle                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FGuid USpeakerFunctionLibrary::GetSpeakerBundleID(const struct FSpeakerBundle& Bundle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpeakerFunctionLibrary.GetSpeakerBundleID");
		
		USpeakerFunctionLibrary_GetSpeakerBundleID_Params params {};
		params.Bundle = Bundle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpeakerFunctionLibrary.GetSpeakerBundleGender
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSpeakerBundle                              Bundle                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	EOEIGender USpeakerFunctionLibrary::GetSpeakerBundleGender(const struct FSpeakerBundle& Bundle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpeakerFunctionLibrary.GetSpeakerBundleGender");
		
		USpeakerFunctionLibrary_GetSpeakerBundleGender_Params params {};
		params.Bundle = Bundle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpeakerFunctionLibrary.GetSpeakerBundleDisplayName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSpeakerBundle                              Bundle                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FLocString USpeakerFunctionLibrary::GetSpeakerBundleDisplayName(const struct FSpeakerBundle& Bundle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpeakerFunctionLibrary.GetSpeakerBundleDisplayName");
		
		USpeakerFunctionLibrary_GetSpeakerBundleDisplayName_Params params {};
		params.Bundle = Bundle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SpeakerFunctionLibrary.GetSpeakerBundleChatterFileID
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSpeakerBundle                              Bundle                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FGuid USpeakerFunctionLibrary::GetSpeakerBundleChatterFileID(const struct FSpeakerBundle& Bundle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SpeakerFunctionLibrary.GetSpeakerBundleChatterFileID");
		
		USpeakerFunctionLibrary_GetSpeakerBundleChatterFileID_Params params {};
		params.Bundle = Bundle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpeakerFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpeakerFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SpeakerFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaComponent.Restore
	 * 		Flags  -> ()
	 */
	void UStaminaComponent::Restore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaComponent.Restore");
		
		UStaminaComponent_Restore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaComponent.OnStatusEffectChanged
	 * 		Flags  -> ()
	 */
	void UStaminaComponent::OnStatusEffectChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaComponent.OnStatusEffectChanged");
		
		UStaminaComponent_OnStatusEffectChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaComponent.OnRest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              RestDuration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStaminaComponent::OnRest(float RestDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaComponent.OnRest");
		
		UStaminaComponent_OnRest_Params params {};
		params.RestDuration = RestDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaComponent.OnRep_CurrentStamina
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              PrevStamina                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStaminaComponent::OnRep_CurrentStamina(float PrevStamina)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaComponent.OnRep_CurrentStamina");
		
		UStaminaComponent_OnRep_CurrentStamina_Params params {};
		params.PrevStamina = PrevStamina;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaComponent.IsStaminaCapped
	 * 		Flags  -> ()
	 */
	bool UStaminaComponent::IsStaminaCapped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaComponent.IsStaminaCapped");
		
		UStaminaComponent_IsStaminaCapped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaComponent.IsEmpty
	 * 		Flags  -> ()
	 */
	bool UStaminaComponent::IsEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaComponent.IsEmpty");
		
		UStaminaComponent_IsEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaComponent.GetStaminaRatio
	 * 		Flags  -> ()
	 */
	float UStaminaComponent::GetStaminaRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaComponent.GetStaminaRatio");
		
		UStaminaComponent_GetStaminaRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaComponent.GetMaxStaminaCapped
	 * 		Flags  -> ()
	 */
	float UStaminaComponent::GetMaxStaminaCapped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaComponent.GetMaxStaminaCapped");
		
		UStaminaComponent_GetMaxStaminaCapped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaComponent.GetMaxStamina
	 * 		Flags  -> ()
	 */
	float UStaminaComponent::GetMaxStamina()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaComponent.GetMaxStamina");
		
		UStaminaComponent_GetMaxStamina_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaComponent.GetEnergyRatio
	 * 		Flags  -> ()
	 */
	float UStaminaComponent::GetEnergyRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaComponent.GetEnergyRatio");
		
		UStaminaComponent_GetEnergyRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaComponent.GetCurrentStamina
	 * 		Flags  -> ()
	 */
	float UStaminaComponent::GetCurrentStamina()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaComponent.GetCurrentStamina");
		
		UStaminaComponent_GetCurrentStamina_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaComponent.ConsumeStamina
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              AmountToConsume                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStaminaComponent::ConsumeStamina(float AmountToConsume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaComponent.ConsumeStamina");
		
		UStaminaComponent_ConsumeStamina_Params params {};
		params.AmountToConsume = AmountToConsume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaComponent.CanRegenerate
	 * 		Flags  -> ()
	 */
	bool UStaminaComponent::CanRegenerate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaComponent.CanRegenerate");
		
		UStaminaComponent_CanRegenerate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaComponent.AddStamina
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              AmountToAdd                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStaminaComponent::AddStamina(float AmountToAdd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaComponent.AddStamina");
		
		UStaminaComponent_AddStamina_Params params {};
		params.AmountToAdd = AmountToAdd;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStaminaComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStaminaComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StaminaComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StaminaReadoutWidget.UpdateStaminaAnim
	 * 		Flags  -> ()
	 */
	void UStaminaReadoutWidget::UpdateStaminaAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StaminaReadoutWidget.UpdateStaminaAnim");
		
		UStaminaReadoutWidget_UpdateStaminaAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStaminaReadoutWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStaminaReadoutWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StaminaReadoutWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffect.ShowInUI
	 * 		Flags  -> ()
	 */
	bool UStatusEffect::ShowInUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffect.ShowInUI");
		
		UStatusEffect_ShowInUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffect.OnRep_StatusEffectRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         PreviousHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UStatusEffect::OnRep_StatusEffectRowHandle(const struct FDataTableRowHandle& PreviousHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffect.OnRep_StatusEffectRowHandle");
		
		UStatusEffect_OnRep_StatusEffectRowHandle_Params params {};
		params.PreviousHandle = PreviousHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffect.OnRep_ResetTime
	 * 		Flags  -> ()
	 */
	void UStatusEffect::OnRep_ResetTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffect.OnRep_ResetTime");
		
		UStatusEffect_OnRep_ResetTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffect.GetTimeRemaining
	 * 		Flags  -> ()
	 */
	float UStatusEffect::GetTimeRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffect.GetTimeRemaining");
		
		UStatusEffect_GetTimeRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffect.GetTimeElapsed
	 * 		Flags  -> ()
	 */
	float UStatusEffect::GetTimeElapsed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffect.GetTimeElapsed");
		
		UStatusEffect_GetTimeElapsed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffect.GetStatusEffectType
	 * 		Flags  -> ()
	 */
	EStatusEffectType UStatusEffect::GetStatusEffectType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffect.GetStatusEffectType");
		
		UStatusEffect_GetStatusEffectType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffect.GetOriginType
	 * 		Flags  -> ()
	 */
	EStatusEffectOriginType UStatusEffect::GetOriginType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffect.GetOriginType");
		
		UStatusEffect_GetOriginType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffect.GetEffectTags
	 * 		Flags  -> ()
	 */
	struct FGameplayTagContainer UStatusEffect::GetEffectTags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffect.GetEffectTags");
		
		UStatusEffect_GetEffectTags_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffect.GetDurationType
	 * 		Flags  -> ()
	 */
	EStatusEffectDurationType UStatusEffect::GetDurationType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffect.GetDurationType");
		
		UStatusEffect_GetDurationType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffect.GetDuration
	 * 		Flags  -> ()
	 */
	float UStatusEffect::GetDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffect.GetDuration");
		
		UStatusEffect_GetDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffect.GetDataHandle
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UStatusEffect::GetDataHandle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffect.GetDataHandle");
		
		UStatusEffect_GetDataHandle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffect.GetApplicationType
	 * 		Flags  -> ()
	 */
	EStatusEffectApplyType UStatusEffect::GetApplicationType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffect.GetApplicationType");
		
		UStatusEffect_GetApplicationType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatusEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatusEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatusEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.RemoveEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStatusEffect*                               StatusEffect                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBroadcastChangedEvent                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatusEffectComponent::RemoveEffect(class UStatusEffect* StatusEffect, bool bBroadcastChangedEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.RemoveEffect");
		
		UStatusEffectComponent_RemoveEffect_Params params {};
		params.StatusEffect = StatusEffect;
		params.bBroadcastChangedEvent = bBroadcastChangedEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.OnRest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              RestDuration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatusEffectComponent::OnRest(float RestDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.OnRest");
		
		UStatusEffectComponent_OnRest_Params params {};
		params.RestDuration = RestDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.OnRep_StatusEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UStatusEffect*>                       PreviousStatusEffects                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UStatusEffectComponent::OnRep_StatusEffects(TArray<class UStatusEffect*> PreviousStatusEffects)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.OnRep_StatusEffects");
		
		UStatusEffectComponent_OnRep_StatusEffects_Params params {};
		params.PreviousStatusEffects = PreviousStatusEffects;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.OnHealthStateChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHealthState                                       NewHealthState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatusEffectComponent::OnHealthStateChange(EHealthState NewHealthState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.OnHealthStateChange");
		
		UStatusEffectComponent_OnHealthStateChange_Params params {};
		params.NewHealthState = NewHealthState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.OnDayNightChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bbIsDayTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatusEffectComponent::OnDayNightChange(bool bbIsDayTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.OnDayNightChange");
		
		UStatusEffectComponent_OnDayNightChange_Params params {};
		params.bbIsDayTime = bbIsDayTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.OnCombatChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInCombat                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatusEffectComponent::OnCombatChange(class ASurvivalCharacter* Character, bool bInCombat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.OnCombatChange");
		
		UStatusEffectComponent_OnCombatChange_Params params {};
		params.Character = Character;
		params.bInCombat = bInCombat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.HasStatusEffectTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                EffectTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UStatusEffectComponent::HasStatusEffectTag(const struct FGameplayTag& EffectTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.HasStatusEffectTag");
		
		UStatusEffectComponent_HasStatusEffectTag_Params params {};
		params.EffectTag = EffectTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.HasStatusEffectOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStatusEffectType                                  StatType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UStatusEffectComponent::HasStatusEffectOfType(EStatusEffectType StatType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.HasStatusEffectOfType");
		
		UStatusEffectComponent_HasStatusEffectOfType_Params params {};
		params.StatType = StatType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.HasStatusEffectOfDamageType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStatusEffectType                                  StatType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UStatusEffectComponent::HasStatusEffectOfDamageType(EStatusEffectType StatType, class UClass* DamageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.HasStatusEffectOfDamageType");
		
		UStatusEffectComponent_HasStatusEffectOfDamageType_Params params {};
		params.StatType = StatType;
		params.DamageType = DamageType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.HasAnyStatusEffectTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTagContainer                       EffectTags                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	bool UStatusEffectComponent::HasAnyStatusEffectTag(const struct FGameplayTagContainer& EffectTags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.HasAnyStatusEffectTag");
		
		UStatusEffectComponent_HasAnyStatusEffectTag_Params params {};
		params.EffectTags = EffectTags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.GetValueForStatWithExtraData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStatusEffectType                                  StatType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ExtraData                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	float UStatusEffectComponent::GetValueForStatWithExtraData(EStatusEffectType StatType, const struct FDataTableRowHandle& ExtraData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.GetValueForStatWithExtraData");
		
		UStatusEffectComponent_GetValueForStatWithExtraData_Params params {};
		params.StatType = StatType;
		params.ExtraData = ExtraData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.GetValueForStatForDamageTypeFlags
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStatusEffectType                                  StatType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Flags                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UStatusEffectComponent::GetValueForStatForDamageTypeFlags(EStatusEffectType StatType, int32_t Flags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.GetValueForStatForDamageTypeFlags");
		
		UStatusEffectComponent_GetValueForStatForDamageTypeFlags_Params params {};
		params.StatType = StatType;
		params.Flags = Flags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.GetValueForStatForDamageInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStatusEffectType                                  StatType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DammageInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	float UStatusEffectComponent::GetValueForStatForDamageInfo(EStatusEffectType StatType, const struct FDamageInfo& DammageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.GetValueForStatForDamageInfo");
		
		UStatusEffectComponent_GetValueForStatForDamageInfo_Params params {};
		params.StatType = StatType;
		params.DammageInfo = DammageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.GetValueForStat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStatusEffectType                                  StatType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UStatusEffectComponent::GetValueForStat(EStatusEffectType StatType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.GetValueForStat");
		
		UStatusEffectComponent_GetValueForStat_Params params {};
		params.StatType = StatType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.GetStatusEffects
	 * 		Flags  -> ()
	 */
	TArray<class UStatusEffect*> UStatusEffectComponent::GetStatusEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.GetStatusEffects");
		
		UStatusEffectComponent_GetStatusEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.GetNumStatusEffectOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStatusEffectType                                  StatType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UStatusEffectComponent::GetNumStatusEffectOfType(EStatusEffectType StatType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.GetNumStatusEffectOfType");
		
		UStatusEffectComponent_GetNumStatusEffectOfType_Params params {};
		params.StatType = StatType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.GetDefaultStatusEffects
	 * 		Flags  -> ()
	 */
	TArray<struct FDataTableRowHandle> UStatusEffectComponent::GetDefaultStatusEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.GetDefaultStatusEffects");
		
		UStatusEffectComponent_GetDefaultStatusEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.CreateAndAddEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         StatusEffectRowHandle                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UStatusEffect* UStatusEffectComponent::CreateAndAddEffect(const struct FDataTableRowHandle& StatusEffectRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.CreateAndAddEffect");
		
		UStatusEffectComponent_CreateAndAddEffect_Params params {};
		params.StatusEffectRowHandle = StatusEffectRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.CanAddEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         StatusEffectRowHandle                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UStatusEffectComponent::CanAddEffect(const struct FDataTableRowHandle& StatusEffectRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.CanAddEffect");
		
		UStatusEffectComponent_CanAddEffect_Params params {};
		params.StatusEffectRowHandle = StatusEffectRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.StatusEffectComponent.AddEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStatusEffect*                               StatusEffect                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatusEffectComponent::AddEffect(class UStatusEffect* StatusEffect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.StatusEffectComponent.AddEffect");
		
		UStatusEffectComponent_AddEffect_Params params {};
		params.StatusEffect = StatusEffect;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatusEffectComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatusEffectComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatusEffectComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatusEffectOrigin.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatusEffectOrigin::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StatusEffectOrigin");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AStencilStandInActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AStencilStandInActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.StencilStandInActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AStorage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AStorage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Storage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SubtitleWindow.HandleShowSubtitlesChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowSubtitles                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USubtitleWindow::HandleShowSubtitlesChanged(bool bShowSubtitles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SubtitleWindow.HandleShowSubtitlesChanged");
		
		USubtitleWindow_HandleShowSubtitlesChanged_Params params {};
		params.bShowSubtitles = bShowSubtitles;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USubtitleWindow.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USubtitleWindow::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SubtitleWindow");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurfaceEffectData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurfaceEffectData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurfaceEffectData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.UpdateHomeLocation
	 * 		Flags  -> ()
	 */
	void ASurvivalAIController::UpdateHomeLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.UpdateHomeLocation");
		
		ASurvivalAIController_UpdateHomeLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.ShouldWaitAfterWander
	 * 		Flags  -> ()
	 */
	bool ASurvivalAIController::ShouldWaitAfterWander()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.ShouldWaitAfterWander");
		
		ASurvivalAIController_ShouldWaitAfterWander_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.ShouldStrafeInCombat
	 * 		Flags  -> ()
	 */
	bool ASurvivalAIController::ShouldStrafeInCombat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.ShouldStrafeInCombat");
		
		ASurvivalAIController_ShouldStrafeInCombat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.ShouldBurrowAfterFlee
	 * 		Flags  -> ()
	 */
	bool ASurvivalAIController::ShouldBurrowAfterFlee()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.ShouldBurrowAfterFlee");
		
		ASurvivalAIController_ShouldBurrowAfterFlee_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.SetTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalAIController::SetTarget(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.SetTarget");
		
		ASurvivalAIController_SetTarget_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.SetNextWaypoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AWaypoint*                                   NextWaypoint                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalAIController::SetNextWaypoint(class AWaypoint* NextWaypoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.SetNextWaypoint");
		
		ASurvivalAIController_SetNextWaypoint_Params params {};
		params.NextWaypoint = NextWaypoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.SetHomeLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalAIController::SetHomeLocation(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.SetHomeLocation");
		
		ASurvivalAIController_SetHomeLocation_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.SetDisabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bDisabled                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalAIController::SetDisabled(bool bDisabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.SetDisabled");
		
		ASurvivalAIController_SetDisabled_Params params {};
		params.bDisabled = bDisabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.SetDesiredCombatAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAttack*                                     Attack                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalAIController::SetDesiredCombatAction(class AActor* Target, class UAttack* Attack, class UAnimMontage* AnimMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.SetDesiredCombatAction");
		
		ASurvivalAIController_SetDesiredCombatAction_Params params {};
		params.Target = Target;
		params.Attack = Attack;
		params.AnimMontage = AnimMontage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.OnRevived
	 * 		Flags  -> ()
	 */
	void ASurvivalAIController::OnRevived()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.OnRevived");
		
		ASurvivalAIController_OnRevived_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.OnHealthStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHealthState                                       HealthState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalAIController::OnHealthStateChanged(EHealthState HealthState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.OnHealthStateChanged");
		
		ASurvivalAIController_OnHealthStateChanged_Params params {};
		params.HealthState = HealthState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.OnDamaged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsKillingBlow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalAIController::OnDamaged(float Damage, const struct FDamageInfo& DamageInfo, class AController* InstigatedBy, class UBaseLODActor* DamageCauser, bool IsKillingBlow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.OnDamaged");
		
		ASurvivalAIController_OnDamaged_Params params {};
		params.Damage = Damage;
		params.DamageInfo = DamageInfo;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		params.IsKillingBlow = IsKillingBlow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.OnAttack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAttack*                                     Attack                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalAIController::OnAttack(class UAttack* Attack)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.OnAttack");
		
		ASurvivalAIController_OnAttack_Params params {};
		params.Attack = Attack;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.OnActorCollision
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      SelfActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ASurvivalAIController::OnActorCollision(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.OnActorCollision");
		
		ASurvivalAIController_OnActorCollision_Params params {};
		params.SelfActor = SelfActor;
		params.OtherActor = OtherActor;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.IsScriptedBpConditionValid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         AbilityData                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalAIController::IsScriptedBpConditionValid(const struct FDataTableRowHandle& AbilityData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.IsScriptedBpConditionValid");
		
		ASurvivalAIController_IsScriptedBpConditionValid_Params params {};
		params.AbilityData = AbilityData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.IsInCombat
	 * 		Flags  -> ()
	 */
	bool ASurvivalAIController::IsInCombat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.IsInCombat");
		
		ASurvivalAIController_IsInCombat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.IsClimbing
	 * 		Flags  -> ()
	 */
	bool ASurvivalAIController::IsClimbing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.IsClimbing");
		
		ASurvivalAIController_IsClimbing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.HasPatrol
	 * 		Flags  -> ()
	 */
	bool ASurvivalAIController::HasPatrol()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.HasPatrol");
		
		ASurvivalAIController_HasPatrol_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.HasAbilityUsableOfPriority
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            MinPriority                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalAIController::HasAbilityUsableOfPriority(int32_t MinPriority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.HasAbilityUsableOfPriority");
		
		ASurvivalAIController_HasAbilityUsableOfPriority_Params params {};
		params.MinPriority = MinPriority;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.HasAbilityUsable
	 * 		Flags  -> ()
	 */
	bool ASurvivalAIController::HasAbilityUsable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.HasAbilityUsable");
		
		ASurvivalAIController_HasAbilityUsable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetWaveDestination
	 * 		Flags  -> ()
	 */
	struct FVector ASurvivalAIController::GetWaveDestination()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetWaveDestination");
		
		ASurvivalAIController_GetWaveDestination_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetWanderRange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ASurvivalAIController::GetWanderRange(class UWorld* World)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetWanderRange");
		
		ASurvivalAIController_GetWanderRange_Params params {};
		params.World = World;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetUsePathFollower
	 * 		Flags  -> ()
	 */
	bool ASurvivalAIController::GetUsePathFollower()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetUsePathFollower");
		
		ASurvivalAIController_GetUsePathFollower_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetTetherRange
	 * 		Flags  -> ()
	 */
	float ASurvivalAIController::GetTetherRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetTetherRange");
		
		ASurvivalAIController_GetTetherRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetSearchOrigin
	 * 		Flags  -> ()
	 */
	struct FVector ASurvivalAIController::GetSearchOrigin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetSearchOrigin");
		
		ASurvivalAIController_GetSearchOrigin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetPreferredMinimumHeight
	 * 		Flags  -> ()
	 */
	float ASurvivalAIController::GetPreferredMinimumHeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetPreferredMinimumHeight");
		
		ASurvivalAIController_GetPreferredMinimumHeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetHomeLocation
	 * 		Flags  -> ()
	 */
	struct FVector ASurvivalAIController::GetHomeLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetHomeLocation");
		
		ASurvivalAIController_GetHomeLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetGoalLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalAIController::GetGoalLocation(struct FVector* OutLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetGoalLocation");
		
		ASurvivalAIController_GetGoalLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetGoalActor
	 * 		Flags  -> ()
	 */
	class AActor* ASurvivalAIController::GetGoalActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetGoalActor");
		
		ASurvivalAIController_GetGoalActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetFleeRange
	 * 		Flags  -> ()
	 */
	float ASurvivalAIController::GetFleeRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetFleeRange");
		
		ASurvivalAIController_GetFleeRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetDesiredBehavior
	 * 		Flags  -> ()
	 */
	EBehaviorType ASurvivalAIController::GetDesiredBehavior()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetDesiredBehavior");
		
		ASurvivalAIController_GetDesiredBehavior_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetDesiredAttackTarget
	 * 		Flags  -> ()
	 */
	class AActor* ASurvivalAIController::GetDesiredAttackTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetDesiredAttackTarget");
		
		ASurvivalAIController_GetDesiredAttackTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetDesiredAttack
	 * 		Flags  -> ()
	 */
	class UAttack* ASurvivalAIController::GetDesiredAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetDesiredAttack");
		
		ASurvivalAIController_GetDesiredAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetCurrentWaypoint
	 * 		Flags  -> ()
	 */
	class AWaypoint* ASurvivalAIController::GetCurrentWaypoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetCurrentWaypoint");
		
		ASurvivalAIController_GetCurrentWaypoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetConeWanderRange
	 * 		Flags  -> ()
	 */
	struct FVector2D ASurvivalAIController::GetConeWanderRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetConeWanderRange");
		
		ASurvivalAIController_GetConeWanderRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetBlackboardTargetLocation
	 * 		Flags  -> ()
	 */
	struct FVector ASurvivalAIController::GetBlackboardTargetLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetBlackboardTargetLocation");
		
		ASurvivalAIController_GetBlackboardTargetLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.GetBlackboardTargetActor
	 * 		Flags  -> ()
	 */
	class AActor* ASurvivalAIController::GetBlackboardTargetActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.GetBlackboardTargetActor");
		
		ASurvivalAIController_GetBlackboardTargetActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.FinishMoveManual
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EBTNodeResult                                      ResultType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalAIController::FinishMoveManual(EBTNodeResult ResultType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.FinishMoveManual");
		
		ASurvivalAIController_FinishMoveManual_Params params {};
		params.ResultType = ResultType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAIController.FindClosestAttachPoint
	 * 		Flags  -> ()
	 */
	struct FVector ASurvivalAIController::FindClosestAttachPoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAIController.FindClosestAttachPoint");
		
		ASurvivalAIController_FindClosestAttachPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASurvivalAIController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASurvivalAIController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalAIController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAutoPlayer.StopAutoPlayer
	 * 		Flags  -> ()
	 */
	void USurvivalAutoPlayer::StopAutoPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAutoPlayer.StopAutoPlayer");
		
		USurvivalAutoPlayer_StopAutoPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAutoPlayer.StartAutoPlayer
	 * 		Flags  -> ()
	 */
	void USurvivalAutoPlayer::StartAutoPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAutoPlayer.StartAutoPlayer");
		
		USurvivalAutoPlayer_StartAutoPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalAutoPlayer.OnAsyncSaveComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESaveGameResult                                    Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESaveGameType                                      SaveType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalAutoPlayer::OnAsyncSaveComplete(ESaveGameResult Result, ESaveGameType SaveType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalAutoPlayer.OnAsyncSaveComplete");
		
		USurvivalAutoPlayer_OnAsyncSaveComplete_Params params {};
		params.Result = Result;
		params.SaveType = SaveType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalAutoPlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalAutoPlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalAutoPlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalAutoPlayerTestSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalAutoPlayerTestSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalAutoPlayerTestSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCharacterDataFunctionLibrary.GetCharacterDataFilterMatches
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSurvivalCharacterData                      CharacterData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      FilterText                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalCharacterDataFunctionLibrary::GetCharacterDataFilterMatches(const struct FSurvivalCharacterData& CharacterData, class FString* FilterText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCharacterDataFunctionLibrary.GetCharacterDataFilterMatches");
		
		USurvivalCharacterDataFunctionLibrary_GetCharacterDataFilterMatches_Params params {};
		params.CharacterData = CharacterData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (FilterText != nullptr)
			*FilterText = params.FilterText;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalCharacterDataFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalCharacterDataFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalCharacterDataFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.UnlockPlayerUpgrade
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        UpgradeName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::UnlockPlayerUpgrade(const class FName& UpgradeName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.UnlockPlayerUpgrade");
		
		USurvivalCheatManager_UnlockPlayerUpgrade_Params params {};
		params.UpgradeName = UpgradeName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.UnlockItemStackUpgrade
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                ItemStackTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::UnlockItemStackUpgrade(const struct FGameplayTag& ItemStackTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.UnlockItemStackUpgrade");
		
		USurvivalCheatManager_UnlockItemStackUpgrade_Params params {};
		params.ItemStackTag = ItemStackTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.UnlockAllTechTrees
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::UnlockAllTechTrees()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.UnlockAllTechTrees");
		
		USurvivalCheatManager_UnlockAllTechTrees_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.UnlockAllTechTreeRecipes
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::UnlockAllTechTreeRecipes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.UnlockAllTechTreeRecipes");
		
		USurvivalCheatManager_UnlockAllTechTreeRecipes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.UnlockAllRecipes
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERecipeUnlockMode                                  Mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::UnlockAllRecipes(ERecipeUnlockMode Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.UnlockAllRecipes");
		
		USurvivalCheatManager_UnlockAllRecipes_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.UnlockAllPerks
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::UnlockAllPerks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.UnlockAllPerks");
		
		USurvivalCheatManager_UnlockAllPerks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.UnlockAllKeyItems
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::UnlockAllKeyItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.UnlockAllKeyItems");
		
		USurvivalCheatManager_UnlockAllKeyItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.UnlockAllColorThemes
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::UnlockAllColorThemes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.UnlockAllColorThemes");
		
		USurvivalCheatManager_UnlockAllColorThemes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.TryKill
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::TryKill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.TryKill");
		
		USurvivalCheatManager_TryKill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.TryDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::TryDamage(float DamageAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.TryDamage");
		
		USurvivalCheatManager_TryDamage_Params params {};
		params.DamageAmount = DamageAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.ToggleSubtitles
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::ToggleSubtitles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.ToggleSubtitles");
		
		USurvivalCheatManager_ToggleSubtitles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.ToggleSpawnPointDebug
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::ToggleSpawnPointDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.ToggleSpawnPointDebug");
		
		USurvivalCheatManager_ToggleSpawnPointDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.TogglePlayerSpectatorMode
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::TogglePlayerSpectatorMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.TogglePlayerSpectatorMode");
		
		USurvivalCheatManager_TogglePlayerSpectatorMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.ToggleHUD
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::ToggleHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.ToggleHUD");
		
		USurvivalCheatManager_ToggleHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.ToggleCameraShake
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::ToggleCameraShake()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.ToggleCameraShake");
		
		USurvivalCheatManager_ToggleCameraShake_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.ToggleAlternateRecipeMode
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::ToggleAlternateRecipeMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.ToggleAlternateRecipeMode");
		
		USurvivalCheatManager_ToggleAlternateRecipeMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.TimeSpeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Multiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::TimeSpeed(float Multiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.TimeSpeed");
		
		USurvivalCheatManager_TimeSpeed_Params params {};
		params.Multiplier = Multiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.TeleportPartyToMe
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::TeleportPartyToMe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.TeleportPartyToMe");
		
		USurvivalCheatManager_TeleportPartyToMe_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.TameNearest
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::TameNearest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.TameNearest");
		
		USurvivalCheatManager_TameNearest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.SuperStructures
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::SuperStructures()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.SuperStructures");
		
		USurvivalCheatManager_SuperStructures_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.Stamina
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::Stamina(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.Stamina");
		
		USurvivalCheatManager_Stamina_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.SpawnBird
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::SpawnBird()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.SpawnBird");
		
		USurvivalCheatManager_SpawnBird_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.ShowWaveStats
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::ShowWaveStats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.ShowWaveStats");
		
		USurvivalCheatManager_ShowWaveStats_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.SetTickLODProxies
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldTick                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::SetTickLODProxies(bool bShouldTick)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.SetTickLODProxies");
		
		USurvivalCheatManager_SetTickLODProxies_Params params {};
		params.bShouldTick = bShouldTick;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.SetOverrideLevelName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      LevelName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::SetOverrideLevelName(const class FString& LevelName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.SetOverrideLevelName");
		
		USurvivalCheatManager_SetOverrideLevelName_Params params {};
		params.LevelName = LevelName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.SetHungerThirstKill
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldKill                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::SetHungerThirstKill(bool bShouldKill)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.SetHungerThirstKill");
		
		USurvivalCheatManager_SetHungerThirstKill_Params params {};
		params.bShouldKill = bShouldKill;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.SetGlobalValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Global                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::SetGlobalValue(const class FString& Global, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.SetGlobalValue");
		
		USurvivalCheatManager_SetGlobalValue_Params params {};
		params.Global = Global;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.SetCompletedBurgleQuestCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::SetCompletedBurgleQuestCount(int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.SetCompletedBurgleQuestCount");
		
		USurvivalCheatManager_SetCompletedBurgleQuestCount_Params params {};
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.SetBonusEnhancementLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                EnhancementTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            BonusEnhancementLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::SetBonusEnhancementLevel(const struct FGameplayTag& EnhancementTag, int32_t BonusEnhancementLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.SetBonusEnhancementLevel");
		
		USurvivalCheatManager_SetBonusEnhancementLevel_Params params {};
		params.EnhancementTag = EnhancementTag;
		params.BonusEnhancementLevel = BonusEnhancementLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.SetBaseEnhancementLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            BaseEnhancementLevel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::SetBaseEnhancementLevel(int32_t BaseEnhancementLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.SetBaseEnhancementLevel");
		
		USurvivalCheatManager_SetBaseEnhancementLevel_Params params {};
		params.BaseEnhancementLevel = BaseEnhancementLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.Revive
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::Revive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.Revive");
		
		USurvivalCheatManager_Revive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.ResearchAllItems
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::ResearchAllItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.ResearchAllItems");
		
		USurvivalCheatManager_ResearchAllItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.RepairAllItems
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::RepairAllItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.RepairAllItems");
		
		USurvivalCheatManager_RepairAllItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.RemoveAchievement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        AchievementName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::RemoveAchievement(const class FName& AchievementName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.RemoveAchievement");
		
		USurvivalCheatManager_RemoveAchievement_Params params {};
		params.AchievementName = AchievementName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.RecoverBackpacks
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::RecoverBackpacks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.RecoverBackpacks");
		
		USurvivalCheatManager_RecoverBackpacks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.PopulationMonitorDump
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::PopulationMonitorDump()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.PopulationMonitorDump");
		
		USurvivalCheatManager_PopulationMonitorDump_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.LogActorAndFoliageCount
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::LogActorAndFoliageCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.LogActorAndFoliageCount");
		
		USurvivalCheatManager_LogActorAndFoliageCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.InfiniteDamage
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::InfiniteDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.InfiniteDamage");
		
		USurvivalCheatManager_InfiniteDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.GiveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Quantity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::GiveItem(const class FName& ItemName, int32_t Quantity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.GiveItem");
		
		USurvivalCheatManager_GiveItem_Params params {};
		params.ItemName = ItemName;
		params.Quantity = Quantity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.FullRestore
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::FullRestore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.FullRestore");
		
		USurvivalCheatManager_FullRestore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.FreezePlayerSizzle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Freeze                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::FreezePlayerSizzle(bool Freeze)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.FreezePlayerSizzle");
		
		USurvivalCheatManager_FreezePlayerSizzle_Params params {};
		params.Freeze = Freeze;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.ForceSpawnWave
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                TeamName                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Heat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::ForceSpawnWave(const struct FGameplayTag& TeamName, int32_t Heat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.ForceSpawnWave");
		
		USurvivalCheatManager_ForceSpawnWave_Params params {};
		params.TeamName = TeamName;
		params.Heat = Heat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.ForceRegenerateBurgleQuests
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::ForceRegenerateBurgleQuests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.ForceRegenerateBurgleQuests");
		
		USurvivalCheatManager_ForceRegenerateBurgleQuests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.Fish
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::Fish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.Fish");
		
		USurvivalCheatManager_Fish_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.Fireproof
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::Fireproof()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.Fireproof");
		
		USurvivalCheatManager_Fireproof_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.FillPheromoneBroadcasters
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                PheromoneTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::FillPheromoneBroadcasters(const struct FGameplayTag& PheromoneTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.FillPheromoneBroadcasters");
		
		USurvivalCheatManager_FillPheromoneBroadcasters_Params params {};
		params.PheromoneTag = PheromoneTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.EquipItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::EquipItem(const class FName& ItemName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.EquipItem");
		
		USurvivalCheatManager_EquipItem_Params params {};
		params.ItemName = ItemName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.DumpOnlyRelevantToOwnerClasses
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::DumpOnlyRelevantToOwnerClasses()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.DumpOnlyRelevantToOwnerClasses");
		
		USurvivalCheatManager_DumpOnlyRelevantToOwnerClasses_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.DumpMobileReplicatedActors
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::DumpMobileReplicatedActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.DumpMobileReplicatedActors");
		
		USurvivalCheatManager_DumpMobileReplicatedActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.DumpAlwaysReplicatedClasses
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::DumpAlwaysReplicatedClasses()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.DumpAlwaysReplicatedClasses");
		
		USurvivalCheatManager_DumpAlwaysReplicatedClasses_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.DestroyCreaturesHalf
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::DestroyCreaturesHalf()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.DestroyCreaturesHalf");
		
		USurvivalCheatManager_DestroyCreaturesHalf_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.BuildAllBuildings
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::BuildAllBuildings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.BuildAllBuildings");
		
		USurvivalCheatManager_BuildAllBuildings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.BreakAllItems
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::BreakAllItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.BreakAllItems");
		
		USurvivalCheatManager_BreakAllItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.AwardAchievement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        AchievementName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::AwardAchievement(const class FName& AchievementName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.AwardAchievement");
		
		USurvivalCheatManager_AwardAchievement_Params params {};
		params.AchievementName = AchievementName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.AlmostBreakAllItems
	 * 		Flags  -> ()
	 */
	void USurvivalCheatManager::AlmostBreakAllItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.AlmostBreakAllItems");
		
		USurvivalCheatManager_AlmostBreakAllItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.AdvanceTimeToHour
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Hour                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::AdvanceTimeToHour(int32_t Hour)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.AdvanceTimeToHour");
		
		USurvivalCheatManager_AdvanceTimeToHour_Params params {};
		params.Hour = Hour;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.AdvanceTimeByHours
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Hours                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::AdvanceTimeByHours(float Hours)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.AdvanceTimeByHours");
		
		USurvivalCheatManager_AdvanceTimeByHours_Params params {};
		params.Hours = Hours;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.AddStatusEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        StatusEffectName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::AddStatusEffect(const class FName& StatusEffectName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.AddStatusEffect");
		
		USurvivalCheatManager_AddStatusEffect_Params params {};
		params.StatusEffectName = StatusEffectName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.AddScience
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::AddScience(int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.AddScience");
		
		USurvivalCheatManager_AddScience_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.AddPersonalUpgradePoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::AddPersonalUpgradePoints(int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.AddPersonalUpgradePoints");
		
		USurvivalCheatManager_AddPersonalUpgradePoints_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalCheatManager.AddPartyUpgradePoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalCheatManager::AddPartyUpgradePoints(int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalCheatManager.AddPartyUpgradePoints");
		
		USurvivalCheatManager_AddPartyUpgradePoints_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalCheatManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalCheatManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalCheatManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.SetCurrentWater
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewWaterLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalComponent::SetCurrentWater(float NewWaterLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.SetCurrentWater");
		
		USurvivalComponent_SetCurrentWater_Params params {};
		params.NewWaterLevel = NewWaterLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.SetCurrentSizzle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewSizzle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalComponent::SetCurrentSizzle(float NewSizzle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.SetCurrentSizzle");
		
		USurvivalComponent_SetCurrentSizzle_Params params {};
		params.NewSizzle = NewSizzle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.SetCurrentFood
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewFoodLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalComponent::SetCurrentFood(float NewFoodLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.SetCurrentFood");
		
		USurvivalComponent_SetCurrentFood_Params params {};
		params.NewFoodLevel = NewFoodLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.SetCurrentBreath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewBreath                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalComponent::SetCurrentBreath(float NewBreath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.SetCurrentBreath");
		
		USurvivalComponent_SetCurrentBreath_Params params {};
		params.NewBreath = NewBreath;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.RestoreBreath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              BreathAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalComponent::RestoreBreath(float BreathAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.RestoreBreath");
		
		USurvivalComponent_RestoreBreath_Params params {};
		params.BreathAmount = BreathAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.Rest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              RestDuration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalComponent::Rest(float RestDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.Rest");
		
		USurvivalComponent_Rest_Params params {};
		params.RestDuration = RestDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.OnStatusEffectsChanged
	 * 		Flags  -> ()
	 */
	void USurvivalComponent::OnStatusEffectsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.OnStatusEffectsChanged");
		
		USurvivalComponent_OnStatusEffectsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.OnRep_CurrentWater
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              PrevWater                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalComponent::OnRep_CurrentWater(float PrevWater)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.OnRep_CurrentWater");
		
		USurvivalComponent_OnRep_CurrentWater_Params params {};
		params.PrevWater = PrevWater;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.OnRep_CurrentFood
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              PrevFood                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalComponent::OnRep_CurrentFood(float PrevFood)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.OnRep_CurrentFood");
		
		USurvivalComponent_OnRep_CurrentFood_Params params {};
		params.PrevFood = PrevFood;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.IsFullBreath
	 * 		Flags  -> ()
	 */
	bool USurvivalComponent::IsFullBreath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.IsFullBreath");
		
		USurvivalComponent_IsFullBreath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.IsFoodOrWaterEmpty
	 * 		Flags  -> ()
	 */
	bool USurvivalComponent::IsFoodOrWaterEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.IsFoodOrWaterEmpty");
		
		USurvivalComponent_IsFoodOrWaterEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.GetThirstRatio
	 * 		Flags  -> ()
	 */
	float USurvivalComponent::GetThirstRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.GetThirstRatio");
		
		USurvivalComponent_GetThirstRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.GetHungerRatio
	 * 		Flags  -> ()
	 */
	float USurvivalComponent::GetHungerRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.GetHungerRatio");
		
		USurvivalComponent_GetHungerRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.GetDeathSecondsTimerRatio
	 * 		Flags  -> ()
	 */
	float USurvivalComponent::GetDeathSecondsTimerRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.GetDeathSecondsTimerRatio");
		
		USurvivalComponent_GetDeathSecondsTimerRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.GetDeathSecondsLeft
	 * 		Flags  -> ()
	 */
	int32_t USurvivalComponent::GetDeathSecondsLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.GetDeathSecondsLeft");
		
		USurvivalComponent_GetDeathSecondsLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.GetCurrentSizzleRatio
	 * 		Flags  -> ()
	 */
	float USurvivalComponent::GetCurrentSizzleRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.GetCurrentSizzleRatio");
		
		USurvivalComponent_GetCurrentSizzleRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.GetBreathSecondsLeft
	 * 		Flags  -> ()
	 */
	int32_t USurvivalComponent::GetBreathSecondsLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.GetBreathSecondsLeft");
		
		USurvivalComponent_GetBreathSecondsLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.GetBreathRatio
	 * 		Flags  -> ()
	 */
	float USurvivalComponent::GetBreathRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.GetBreathRatio");
		
		USurvivalComponent_GetBreathRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.GetBreathAlertTime
	 * 		Flags  -> ()
	 */
	int32_t USurvivalComponent::GetBreathAlertTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.GetBreathAlertTime");
		
		USurvivalComponent_GetBreathAlertTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.GetBreathAdjustmentRate
	 * 		Flags  -> ()
	 */
	float USurvivalComponent::GetBreathAdjustmentRate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.GetBreathAdjustmentRate");
		
		USurvivalComponent_GetBreathAdjustmentRate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.CanBreathe
	 * 		Flags  -> ()
	 */
	bool USurvivalComponent::CanBreathe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.CanBreathe");
		
		USurvivalComponent_CanBreathe_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.AddWater
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              WaterAmount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalComponent::AddWater(float WaterAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.AddWater");
		
		USurvivalComponent_AddWater_Params params {};
		params.WaterAmount = WaterAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalComponent.AddFood
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              FoodAmount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalComponent::AddFood(float FoodAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalComponent.AddFood");
		
		USurvivalComponent_AddFood_Params params {};
		params.FoodAmount = FoodAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalDamageType.HasDamageTypeFlag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESurvivalDamageTypeFlags                           flag                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalDamageType::HasDamageTypeFlag(ESurvivalDamageTypeFlags flag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalDamageType.HasDamageTypeFlag");
		
		USurvivalDamageType_HasDamageTypeFlag_Params params {};
		params.flag = flag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalDamageType.HasAnyDamageTypeFlag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            flag                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalDamageType::HasAnyDamageTypeFlag(int32_t flag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalDamageType.HasAnyDamageTypeFlag");
		
		USurvivalDamageType_HasAnyDamageTypeFlag_Params params {};
		params.flag = flag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalDamageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalDamageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalDamageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.ValidateColorTheme
	 * 		Flags  -> ()
	 */
	void USurvivalGameInstance::ValidateColorTheme()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.ValidateColorTheme");
		
		USurvivalGameInstance_ValidateColorTheme_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.UserLoggedIntoValidProfile
	 * 		Flags  -> ()
	 */
	bool USurvivalGameInstance::UserLoggedIntoValidProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.UserLoggedIntoValidProfile");
		
		USurvivalGameInstance_UserLoggedIntoValidProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.SetUIThemeByIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::SetUIThemeByIndex(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.SetUIThemeByIndex");
		
		USurvivalGameInstance_SetUIThemeByIndex_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.SetUITheme
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Theme                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::SetUITheme(class UClass* Theme)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.SetUITheme");
		
		USurvivalGameInstance_SetUITheme_Params params {};
		params.Theme = Theme;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.SetSelectedGameMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGameMode                                          GameMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::SetSelectedGameMode(EGameMode GameMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.SetSelectedGameMode");
		
		USurvivalGameInstance_SetSelectedGameMode_Params params {};
		params.GameMode = GameMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.SetOnlineGamePassword
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Password                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::SetOnlineGamePassword(const class FString& Password)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.SetOnlineGamePassword");
		
		USurvivalGameInstance_SetOnlineGamePassword_Params params {};
		params.Password = Password;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.SetNightUIThemeByIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::SetNightUIThemeByIndex(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.SetNightUIThemeByIndex");
		
		USurvivalGameInstance_SetNightUIThemeByIndex_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.SetNightUITheme
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Theme                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::SetNightUITheme(class UClass* Theme)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.SetNightUITheme");
		
		USurvivalGameInstance_SetNightUITheme_Params params {};
		params.Theme = Theme;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.SetCustomGameSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCustomGameModeSettings                     CustomSettings                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::SetCustomGameSettings(const struct FCustomGameModeSettings& CustomSettings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.SetCustomGameSettings");
		
		USurvivalGameInstance_SetCustomGameSettings_Params params {};
		params.CustomSettings = CustomSettings;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.ServerTravelToGameLevel
	 * 		Flags  -> ()
	 */
	void USurvivalGameInstance::ServerTravelToGameLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.ServerTravelToGameLevel");
		
		USurvivalGameInstance_ServerTravelToGameLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.ResetGameState
	 * 		Flags  -> ()
	 */
	void USurvivalGameInstance::ResetGameState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.ResetGameState");
		
		USurvivalGameInstance_ResetGameState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.QuitToDesktop
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           SpecificPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::QuitToDesktop(class UObject* WorldContextObject, class APlayerController* SpecificPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.QuitToDesktop");
		
		USurvivalGameInstance_QuitToDesktop_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.SpecificPlayer = SpecificPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.OpenLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        LevelName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::OpenLevel(const class FName& LevelName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.OpenLevel");
		
		USurvivalGameInstance_OpenLevel_Params params {};
		params.LevelName = LevelName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.LoadMainMenuLevel
	 * 		Flags  -> ()
	 */
	void USurvivalGameInstance::LoadMainMenuLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.LoadMainMenuLevel");
		
		USurvivalGameInstance_LoadMainMenuLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.LoadLobbyLevel
	 * 		Flags  -> ()
	 */
	void USurvivalGameInstance::LoadLobbyLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.LoadLobbyLevel");
		
		USurvivalGameInstance_LoadLobbyLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.JoinOnlineSession
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBlueprintSessionResult                     SessionResult                                              (Parm, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::JoinOnlineSession(const struct FBlueprintSessionResult& SessionResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.JoinOnlineSession");
		
		USurvivalGameInstance_JoinOnlineSession_Params params {};
		params.SessionResult = SessionResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.IsUsingGamepadControls
	 * 		Flags  -> ()
	 */
	bool USurvivalGameInstance::IsUsingGamepadControls()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.IsUsingGamepadControls");
		
		USurvivalGameInstance_IsUsingGamepadControls_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.IsGroundFoliage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 StaticMesh                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameInstance::IsGroundFoliage(class UStaticMesh* StaticMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.IsGroundFoliage");
		
		USurvivalGameInstance_IsGroundFoliage_Params params {};
		params.StaticMesh = StaticMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.IsCurrentLevelMenuLevel
	 * 		Flags  -> ()
	 */
	bool USurvivalGameInstance::IsCurrentLevelMenuLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.IsCurrentLevelMenuLevel");
		
		USurvivalGameInstance_IsCurrentLevelMenuLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.IsCurrentLevelGameOrLobby
	 * 		Flags  -> ()
	 */
	bool USurvivalGameInstance::IsCurrentLevelGameOrLobby()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.IsCurrentLevelGameOrLobby");
		
		USurvivalGameInstance_IsCurrentLevelGameOrLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.HostSession
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsLAN                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsPresence                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPasswordProtected                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxNumPlayers                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameInstance::HostSession(bool bIsLAN, bool bIsPresence, bool bPasswordProtected, int32_t MaxNumPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.HostSession");
		
		USurvivalGameInstance_HostSession_Params params {};
		params.bIsLAN = bIsLAN;
		params.bIsPresence = bIsPresence;
		params.bPasswordProtected = bPasswordProtected;
		params.MaxNumPlayers = MaxNumPlayers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.HandleVOIPVolumeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::HandleVOIPVolumeChanged(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.HandleVOIPVolumeChanged");
		
		USurvivalGameInstance_HandleVOIPVolumeChanged_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.HandleVoiceVolumeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::HandleVoiceVolumeChanged(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.HandleVoiceVolumeChanged");
		
		USurvivalGameInstance_HandleVoiceVolumeChanged_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.HandleUIVolumeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::HandleUIVolumeChanged(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.HandleUIVolumeChanged");
		
		USurvivalGameInstance_HandleUIVolumeChanged_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.HandleSetIsSinglePlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               SinglePlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::HandleSetIsSinglePlayer(bool SinglePlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.HandleSetIsSinglePlayer");
		
		USurvivalGameInstance_HandleSetIsSinglePlayer_Params params {};
		params.SinglePlayer = SinglePlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.HandleReadToMeSpeedChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Speed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::HandleReadToMeSpeedChanged(float Speed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.HandleReadToMeSpeedChanged");
		
		USurvivalGameInstance_HandleReadToMeSpeedChanged_Params params {};
		params.Speed = Speed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.HandleReadToMeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bReadToMe                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::HandleReadToMeChanged(bool bReadToMe)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.HandleReadToMeChanged");
		
		USurvivalGameInstance_HandleReadToMeChanged_Params params {};
		params.bReadToMe = bReadToMe;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.HandleNarrationVolumeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::HandleNarrationVolumeChanged(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.HandleNarrationVolumeChanged");
		
		USurvivalGameInstance_HandleNarrationVolumeChanged_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.HandleMusicVolumeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::HandleMusicVolumeChanged(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.HandleMusicVolumeChanged");
		
		USurvivalGameInstance_HandleMusicVolumeChanged_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.HandleMasterVolumeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::HandleMasterVolumeChanged(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.HandleMasterVolumeChanged");
		
		USurvivalGameInstance_HandleMasterVolumeChanged_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.HandleEffectsVolumeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::HandleEffectsVolumeChanged(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.HandleEffectsVolumeChanged");
		
		USurvivalGameInstance_HandleEffectsVolumeChanged_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.HandleChatTextToSpeechChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::HandleChatTextToSpeechChanged(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.HandleChatTextToSpeechChanged");
		
		USurvivalGameInstance_HandleChatTextToSpeechChanged_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.HandleChatSpeechToTextChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::HandleChatSpeechToTextChanged(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.HandleChatSpeechToTextChanged");
		
		USurvivalGameInstance_HandleChatSpeechToTextChanged_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.HandleAmbienceVolumeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::HandleAmbienceVolumeChanged(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.HandleAmbienceVolumeChanged");
		
		USurvivalGameInstance_HandleAmbienceVolumeChanged_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetUseBuildingIntegrity
	 * 		Flags  -> ()
	 */
	bool USurvivalGameInstance::GetUseBuildingIntegrity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetUseBuildingIntegrity");
		
		USurvivalGameInstance_GetUseBuildingIntegrity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetUnlockedUIThemes
	 * 		Flags  -> ()
	 */
	TArray<class UClass*> USurvivalGameInstance::GetUnlockedUIThemes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetUnlockedUIThemes");
		
		USurvivalGameInstance_GetUnlockedUIThemes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetUITheme
	 * 		Flags  -> ()
	 */
	class UClass* USurvivalGameInstance::GetUITheme()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetUITheme");
		
		USurvivalGameInstance_GetUITheme_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetSubmergedVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 Mesh                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Transform                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              ZPlane                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     CenterOfMass                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float USurvivalGameInstance::GetSubmergedVolume(class UStaticMesh* Mesh, const struct FTransform& Transform, float ZPlane, struct FVector* CenterOfMass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetSubmergedVolume");
		
		USurvivalGameInstance_GetSubmergedVolume_Params params {};
		params.Mesh = Mesh;
		params.Transform = Transform;
		params.ZPlane = ZPlane;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (CenterOfMass != nullptr)
			*CenterOfMass = params.CenterOfMass;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetSubmergedCollisionVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 Mesh                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Transform                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              ZPlane                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     CenterOfMass                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float USurvivalGameInstance::GetSubmergedCollisionVolume(class UStaticMesh* Mesh, const struct FTransform& Transform, float ZPlane, struct FVector* CenterOfMass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetSubmergedCollisionVolume");
		
		USurvivalGameInstance_GetSubmergedCollisionVolume_Params params {};
		params.Mesh = Mesh;
		params.Transform = Transform;
		params.ZPlane = ZPlane;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (CenterOfMass != nullptr)
			*CenterOfMass = params.CenterOfMass;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetStencilStandInActorWithKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 FoliageKey                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridBuildingId                     BuildingKey                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AStencilStandInActor* USurvivalGameInstance::GetStencilStandInActorWithKey(const struct FFoliageKey& FoliageKey, const struct FBuildingGridBuildingId& BuildingKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetStencilStandInActorWithKey");
		
		USurvivalGameInstance_GetStencilStandInActorWithKey_Params params {};
		params.FoliageKey = FoliageKey;
		params.BuildingKey = BuildingKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetStencilStandInActor
	 * 		Flags  -> ()
	 */
	class AStencilStandInActor* USurvivalGameInstance::GetStencilStandInActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetStencilStandInActor");
		
		USurvivalGameInstance_GetStencilStandInActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetStaticMeshVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 Mesh                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float USurvivalGameInstance::GetStaticMeshVolume(class UStaticMesh* Mesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetStaticMeshVolume");
		
		USurvivalGameInstance_GetStaticMeshVolume_Params params {};
		params.Mesh = Mesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetSelectedGameModeClass
	 * 		Flags  -> ()
	 */
	class UClass* USurvivalGameInstance::GetSelectedGameModeClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetSelectedGameModeClass");
		
		USurvivalGameInstance_GetSelectedGameModeClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetPowerTypeData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                Tag                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPowerTypeData                              Data                                                       (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameInstance::GetPowerTypeData(const struct FGameplayTag& Tag, struct FPowerTypeData* Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetPowerTypeData");
		
		USurvivalGameInstance_GetPowerTypeData_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Data != nullptr)
			*Data = params.Data;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetNightUITheme
	 * 		Flags  -> ()
	 */
	class UClass* USurvivalGameInstance::GetNightUITheme()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetNightUITheme");
		
		USurvivalGameInstance_GetNightUITheme_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetInstancedBlueprintFromHitResult
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class UClass* USurvivalGameInstance::GetInstancedBlueprintFromHitResult(const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetInstancedBlueprintFromHitResult");
		
		USurvivalGameInstance_GetInstancedBlueprintFromHitResult_Params params {};
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetGameVersionStringWithTags
	 * 		Flags  -> ()
	 */
	class FText USurvivalGameInstance::GetGameVersionStringWithTags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetGameVersionStringWithTags");
		
		USurvivalGameInstance_GetGameVersionStringWithTags_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetGameVersionString
	 * 		Flags  -> ()
	 */
	class FString USurvivalGameInstance::GetGameVersionString()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetGameVersionString");
		
		USurvivalGameInstance_GetGameVersionString_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetFoliageMeshesFromItemHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	TArray<class UStaticMesh*> USurvivalGameInstance::GetFoliageMeshesFromItemHandle(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetFoliageMeshesFromItemHandle");
		
		USurvivalGameInstance_GetFoliageMeshesFromItemHandle_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetFoliageIsClimbable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 StaticMesh                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ClimberTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameInstance::GetFoliageIsClimbable(class UStaticMesh* StaticMesh, const struct FGameplayTag& ClimberTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetFoliageIsClimbable");
		
		USurvivalGameInstance_GetFoliageIsClimbable_Params params {};
		params.StaticMesh = StaticMesh;
		params.ClimberTag = ClimberTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetFoliageHasClimbRole
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 StaticMesh                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                RoleTag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameInstance::GetFoliageHasClimbRole(class UStaticMesh* StaticMesh, const struct FGameplayTag& RoleTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetFoliageHasClimbRole");
		
		USurvivalGameInstance_GetFoliageHasClimbRole_Params params {};
		params.StaticMesh = StaticMesh;
		params.RoleTag = RoleTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetFoliageClimbableSplines
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 StaticMesh                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UActorComponent*> USurvivalGameInstance::GetFoliageClimbableSplines(class UStaticMesh* StaticMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetFoliageClimbableSplines");
		
		USurvivalGameInstance_GetFoliageClimbableSplines_Params params {};
		params.StaticMesh = StaticMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetFoliageBlueprintFromStaticMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 StaticMesh                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* USurvivalGameInstance::GetFoliageBlueprintFromStaticMesh(class UStaticMesh* StaticMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetFoliageBlueprintFromStaticMesh");
		
		USurvivalGameInstance_GetFoliageBlueprintFromStaticMesh_Params params {};
		params.StaticMesh = StaticMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetFoliageBlueprintFromKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFoliageKey                                 Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* USurvivalGameInstance::GetFoliageBlueprintFromKey(const struct FFoliageKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetFoliageBlueprintFromKey");
		
		USurvivalGameInstance_GetFoliageBlueprintFromKey_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetFoliageBlueprintFromFoliageType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFoliageType*                                FoliageType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* USurvivalGameInstance::GetFoliageBlueprintFromFoliageType(class UFoliageType* FoliageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetFoliageBlueprintFromFoliageType");
		
		USurvivalGameInstance_GetFoliageBlueprintFromFoliageType_Params params {};
		params.FoliageType = FoliageType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetCustomGameSettings
	 * 		Flags  -> ()
	 */
	struct FCustomGameModeSettings USurvivalGameInstance::GetCustomGameSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetCustomGameSettings");
		
		USurvivalGameInstance_GetCustomGameSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetCurrentGameInputType
	 * 		Flags  -> ()
	 */
	EGameInputType USurvivalGameInstance::GetCurrentGameInputType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetCurrentGameInputType");
		
		USurvivalGameInstance_GetCurrentGameInputType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetCDOAttractionData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 StaticMesh                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TMap<class UAttractionComponent*, struct FAttractionCDOData> USurvivalGameInstance::GetCDOAttractionData(class UStaticMesh* StaticMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetCDOAttractionData");
		
		USurvivalGameInstance_GetCDOAttractionData_Params params {};
		params.StaticMesh = StaticMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.GetActorClimbableSplines
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UActorComponent*> USurvivalGameInstance::GetActorClimbableSplines(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.GetActorClimbableSplines");
		
		USurvivalGameInstance_GetActorClimbableSplines_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.ExitOnlineSession
	 * 		Flags  -> ()
	 */
	bool USurvivalGameInstance::ExitOnlineSession()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.ExitOnlineSession");
		
		USurvivalGameInstance_ExitOnlineSession_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.EndLoadingScreen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      InLoadedWorld                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::EndLoadingScreen(class UWorld* InLoadedWorld)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.EndLoadingScreen");
		
		USurvivalGameInstance_EndLoadingScreen_Params params {};
		params.InLoadedWorld = InLoadedWorld;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.DismissInvite
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBlueprintSessionResult                     DismissedInvite                                            (ConstParm, Parm, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::DismissInvite(const struct FBlueprintSessionResult& DismissedInvite)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.DismissInvite");
		
		USurvivalGameInstance_DismissInvite_Params params {};
		params.DismissedInvite = DismissedInvite;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.DisableOtherStencilStandInActors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AStencilStandInActor*                        ActiveStandIn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::DisableOtherStencilStandInActors(class AStencilStandInActor* ActiveStandIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.DisableOtherStencilStandInActors");
		
		USurvivalGameInstance_DisableOtherStencilStandInActors_Params params {};
		params.ActiveStandIn = ActiveStandIn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.ConsumeProfileLoggedOutDuringPlay
	 * 		Flags  -> ()
	 */
	bool USurvivalGameInstance::ConsumeProfileLoggedOutDuringPlay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.ConsumeProfileLoggedOutDuringPlay");
		
		USurvivalGameInstance_ConsumeProfileLoggedOutDuringPlay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.ConsumeLocalPlayerKicked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        OutKickReason                                              (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameInstance::ConsumeLocalPlayerKicked(class FText* OutKickReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.ConsumeLocalPlayerKicked");
		
		USurvivalGameInstance_ConsumeLocalPlayerKicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutKickReason != nullptr)
			*OutKickReason = params.OutKickReason;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.ConsumeConnectionLostDuringPlay
	 * 		Flags  -> ()
	 */
	bool USurvivalGameInstance::ConsumeConnectionLostDuringPlay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.ConsumeConnectionLostDuringPlay");
		
		USurvivalGameInstance_ConsumeConnectionLostDuringPlay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.CheckForCloudSavePrivilegeAndFetch
	 * 		Flags  -> ()
	 */
	void USurvivalGameInstance::CheckForCloudSavePrivilegeAndFetch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.CheckForCloudSavePrivilegeAndFetch");
		
		USurvivalGameInstance_CheckForCloudSavePrivilegeAndFetch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.CanSwapFoliageWithAttacks
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 StaticMesh                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameInstance::CanSwapFoliageWithAttacks(class UStaticMesh* StaticMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.CanSwapFoliageWithAttacks");
		
		USurvivalGameInstance_CanSwapFoliageWithAttacks_Params params {};
		params.StaticMesh = StaticMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.CanSwapFoliageWithAttack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 StaticMesh                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageData                                 DamageData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Tier                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameInstance::CanSwapFoliageWithAttack(class UStaticMesh* StaticMesh, const struct FDamageData& DamageData, int32_t Tier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.CanSwapFoliageWithAttack");
		
		USurvivalGameInstance_CanSwapFoliageWithAttack_Params params {};
		params.StaticMesh = StaticMesh;
		params.DamageData = DamageData;
		params.Tier = Tier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.CanDisplaceFoliage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 StaticMesh                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFoliageSwapLevel                                  DisplaceLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameInstance::CanDisplaceFoliage(class UStaticMesh* StaticMesh, EFoliageSwapLevel DisplaceLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.CanDisplaceFoliage");
		
		USurvivalGameInstance_CanDisplaceFoliage_Params params {};
		params.StaticMesh = StaticMesh;
		params.DisplaceLevel = DisplaceLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.BeginLoadingScreen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InMapName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::BeginLoadingScreen(const class FString& InMapName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.BeginLoadingScreen");
		
		USurvivalGameInstance_BeginLoadingScreen_Params params {};
		params.InMapName = InMapName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameInstance.AcceptInvite
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBlueprintSessionResult                     AcceptedInvite                                             (ConstParm, Parm, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameInstance::AcceptInvite(const struct FBlueprintSessionResult& AcceptedInvite)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameInstance.AcceptInvite");
		
		USurvivalGameInstance_AcceptInvite_Params params {};
		params.AcceptedInvite = AcceptedInvite;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalGameInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalGameInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalGameInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASurvivalGameManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASurvivalGameManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalGameManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameMode.RestartGame
	 * 		Flags  -> ()
	 */
	void ASurvivalGameMode::RestartGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameMode.RestartGame");
		
		ASurvivalGameMode_RestartGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASurvivalGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASurvivalGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameModeSettings.CreateCustomSettings
	 * 		Flags  -> ()
	 */
	struct FCustomGameModeSettings USurvivalGameModeSettings::CreateCustomSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameModeSettings.CreateCustomSettings");
		
		USurvivalGameModeSettings_CreateCustomSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalGameModeSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalGameModeSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalGameModeSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.UnregisterStencilMaskRenderer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            StencilMaskValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::UnregisterStencilMaskRenderer(class AActor* Actor, int32_t StencilMaskValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.UnregisterStencilMaskRenderer");
		
		USurvivalGameplayStatics_UnregisterStencilMaskRenderer_Params params {};
		params.Actor = Actor;
		params.StencilMaskValue = StencilMaskValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.TestChatter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::TestChatter(class ASurvivalCharacter* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.TestChatter");
		
		USurvivalGameplayStatics_TestChatter_Params params {};
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.StartFieldConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGuid                                       ConversationID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NodeId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EConversationPlayPriority                          Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::StartFieldConversation(class UObject* WorldContextObject, class AActor* OwnerActor, const struct FGuid& ConversationID, int32_t NodeId, EConversationPlayPriority Priority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.StartFieldConversation");
		
		USurvivalGameplayStatics_StartFieldConversation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.OwnerActor = OwnerActor;
		params.ConversationID = ConversationID;
		params.NodeId = NodeId;
		params.Priority = Priority;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.StartConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGuid                                       ConversationID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NodeId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EConversationPlayPriority                          Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::StartConversation(class UObject* WorldContextObject, class AActor* OwnerActor, const struct FGuid& ConversationID, int32_t NodeId, EConversationPlayPriority Priority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.StartConversation");
		
		USurvivalGameplayStatics_StartConversation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.OwnerActor = OwnerActor;
		params.ConversationID = ConversationID;
		params.NodeId = NodeId;
		params.Priority = Priority;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.SpawnAI
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ActorClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  SpawnTransform                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InteractionObject                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AActor* USurvivalGameplayStatics::SpawnAI(class UObject* WorldContextObject, class UClass* ActorClass, const struct FTransform& SpawnTransform, class AActor* InteractionObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.SpawnAI");
		
		USurvivalGameplayStatics_SpawnAI_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.ActorClass = ActorClass;
		params.SpawnTransform = SpawnTransform;
		params.InteractionObject = InteractionObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.SetNearClipPlane
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ClipPlane                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::SetNearClipPlane(float ClipPlane)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.SetNearClipPlane");
		
		USurvivalGameplayStatics_SetNearClipPlane_Params params {};
		params.ClipPlane = ClipPlane;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.SetLightChannel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         PrimitiveComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            LightChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ChannelActive                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::SetLightChannel(class UPrimitiveComponent* PrimitiveComponent, int32_t LightChannel, bool ChannelActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.SetLightChannel");
		
		USurvivalGameplayStatics_SetLightChannel_Params params {};
		params.PrimitiveComponent = PrimitiveComponent;
		params.LightChannel = LightChannel;
		params.ChannelActive = ChannelActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.SetInteractHighlight
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::SetInteractHighlight(class AActor* Actor, bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.SetInteractHighlight");
		
		USurvivalGameplayStatics_SetInteractHighlight_Params params {};
		params.Actor = Actor;
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.SetFragilityHighlight
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Level                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::SetFragilityHighlight(class AActor* Actor, int32_t Level)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.SetFragilityHighlight");
		
		USurvivalGameplayStatics_SetFragilityHighlight_Params params {};
		params.Actor = Actor;
		params.Level = Level;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.SetFoliageOverrideViewDistanceScale
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ViewDistanceScale                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::SetFoliageOverrideViewDistanceScale(float ViewDistanceScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.SetFoliageOverrideViewDistanceScale");
		
		USurvivalGameplayStatics_SetFoliageOverrideViewDistanceScale_Params params {};
		params.ViewDistanceScale = ViewDistanceScale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.ServerTravel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      LevelName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::ServerTravel(class UObject* WorldContextObject, const class FString& LevelName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.ServerTravel");
		
		USurvivalGameplayStatics_ServerTravel_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.LevelName = LevelName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.ResetStaticMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMeshComponent*                        StaticMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStaticMesh*                                 StaticMesh                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ResetMaterials                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::ResetStaticMesh(class UStaticMeshComponent* StaticMeshComponent, class UStaticMesh* StaticMesh, bool ResetMaterials)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.ResetStaticMesh");
		
		USurvivalGameplayStatics_ResetStaticMesh_Params params {};
		params.StaticMeshComponent = StaticMeshComponent;
		params.StaticMesh = StaticMesh;
		params.ResetMaterials = ResetMaterials;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.ResetCreatureLocations
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::ResetCreatureLocations(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.ResetCreatureLocations");
		
		USurvivalGameplayStatics_ResetCreatureLocations_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.RerunConstructionScript
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::RerunConstructionScript(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.RerunConstructionScript");
		
		USurvivalGameplayStatics_RerunConstructionScript_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.RegisterStencilMaskRenderer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            StencilMaskValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::RegisterStencilMaskRenderer(class AActor* Actor, int32_t StencilMaskValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.RegisterStencilMaskRenderer");
		
		USurvivalGameplayStatics_RegisterStencilMaskRenderer_Params params {};
		params.Actor = Actor;
		params.StencilMaskValue = StencilMaskValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.RecoverPlayerBackpacks
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::RecoverPlayerBackpacks(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.RecoverPlayerBackpacks");
		
		USurvivalGameplayStatics_RecoverPlayerBackpacks_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.PlayOneShotAtRandomLocationAroundPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            PlayerIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USoundBase*                                  SoundToPlay                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinSpawnDistance                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxSpawnDistance                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::PlayOneShotAtRandomLocationAroundPlayer(class UObject* WorldContextObject, int32_t PlayerIndex, class USoundBase* SoundToPlay, float MinSpawnDistance, float MaxSpawnDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.PlayOneShotAtRandomLocationAroundPlayer");
		
		USurvivalGameplayStatics_PlayOneShotAtRandomLocationAroundPlayer_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PlayerIndex = PlayerIndex;
		params.SoundToPlay = SoundToPlay;
		params.MinSpawnDistance = MinSpawnDistance;
		params.MaxSpawnDistance = MaxSpawnDistance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.PlayCharacterSoundAttached
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                SoundTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             AttachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        AttachPointName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	 * 		EAttachLocation                                    LocationType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bStopWhenAttachedToDestroyed                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USoundAttenuation*                           AttenuationSettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USoundConcurrency*                           ConcurrencySettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAutoDestroy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::PlayCharacterSoundAttached(class ASurvivalCharacter* Character, const struct FGameplayTag& SoundTag, class USceneComponent* AttachToComponent, const class FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.PlayCharacterSoundAttached");
		
		USurvivalGameplayStatics_PlayCharacterSoundAttached_Params params {};
		params.Character = Character;
		params.SoundTag = SoundTag;
		params.AttachToComponent = AttachToComponent;
		params.AttachPointName = AttachPointName;
		params.Location = Location;
		params.Rotation = Rotation;
		params.LocationType = LocationType;
		params.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.AttenuationSettings = AttenuationSettings;
		params.ConcurrencySettings = ConcurrencySettings;
		params.bAutoDestroy = bAutoDestroy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.PlayCharacterSoundAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                SoundTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	 * 		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USoundAttenuation*                           AttenuationSettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USoundConcurrency*                           ConcurrencySettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::PlayCharacterSoundAtLocation(class ASurvivalCharacter* Character, const struct FGameplayTag& SoundTag, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.PlayCharacterSoundAtLocation");
		
		USurvivalGameplayStatics_PlayCharacterSoundAtLocation_Params params {};
		params.Character = Character;
		params.SoundTag = SoundTag;
		params.Location = Location;
		params.Rotation = Rotation;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.AttenuationSettings = AttenuationSettings;
		params.ConcurrencySettings = ConcurrencySettings;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.NewAttack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         AttackRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Outer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAttack* USurvivalGameplayStatics::NewAttack(const struct FDataTableRowHandle& AttackRowHandle, class AActor* Owner, class UObject* Outer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.NewAttack");
		
		USurvivalGameplayStatics_NewAttack_Params params {};
		params.AttackRowHandle = AttackRowHandle;
		params.Owner = Owner;
		params.Outer = Outer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.MarkPrimitiveRenderStatesDirty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::MarkPrimitiveRenderStatesDirty(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.MarkPrimitiveRenderStatesDirty");
		
		USurvivalGameplayStatics_MarkPrimitiveRenderStatesDirty_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.LoadGameInProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::LoadGameInProgress(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.LoadGameInProgress");
		
		USurvivalGameplayStatics_LoadGameInProgress_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.LerpTransforms
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                                  A                                                          (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  B                                                          (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform USurvivalGameplayStatics::LerpTransforms(const struct FTransform& A, const struct FTransform& B, float Alpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.LerpTransforms");
		
		USurvivalGameplayStatics_LerpTransforms_Params params {};
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.KnowsRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::KnowsRecipe(class UObject* WorldContextObject, const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.KnowsRecipe");
		
		USurvivalGameplayStatics_KnowsRecipe_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.K2_GetMaineGameUserSettings
	 * 		Flags  -> ()
	 */
	class UMaineGameUserSettings* USurvivalGameplayStatics::K2_GetMaineGameUserSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.K2_GetMaineGameUserSettings");
		
		USurvivalGameplayStatics_K2_GetMaineGameUserSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsWinterHoliday
	 * 		Flags  -> ()
	 */
	bool USurvivalGameplayStatics::IsWinterHoliday()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsWinterHoliday");
		
		USurvivalGameplayStatics_IsWinterHoliday_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsUsingGamepadControls
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsUsingGamepadControls(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsUsingGamepadControls");
		
		USurvivalGameplayStatics_IsUsingGamepadControls_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsStaticObstacle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsStaticObstacle(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsStaticObstacle");
		
		USurvivalGameplayStatics_IsStaticObstacle_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsSinglePlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsSinglePlayer(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsSinglePlayer");
		
		USurvivalGameplayStatics_IsSinglePlayer_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsRecipeRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         DataTableRowHandle                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsRecipeRowHandle(const struct FDataTableRowHandle& DataTableRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsRecipeRowHandle");
		
		USurvivalGameplayStatics_IsRecipeRowHandle_Params params {};
		params.DataTableRowHandle = DataTableRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsPublicTestBuild
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsPublicTestBuild(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsPublicTestBuild");
		
		USurvivalGameplayStatics_IsPublicTestBuild_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsPasswordProtectedGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBlueprintSessionResult                     SessionResult                                              (Parm, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsPasswordProtectedGame(const struct FBlueprintSessionResult& SessionResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsPasswordProtectedGame");
		
		USurvivalGameplayStatics_IsPasswordProtectedGame_Params params {};
		params.SessionResult = SessionResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsOverlappingWaterVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsOverlappingWaterVolume(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsOverlappingWaterVolume");
		
		USurvivalGameplayStatics_IsOverlappingWaterVolume_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsNightTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsNightTime(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsNightTime");
		
		USurvivalGameplayStatics_IsNightTime_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsNaturalResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRow                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsNaturalResource(const struct FDataTableRowHandle& ItemRow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsNaturalResource");
		
		USurvivalGameplayStatics_IsNaturalResource_Params params {};
		params.ItemRow = ItemRow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsLODActorStaticObstacle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsLODActorStaticObstacle(class UBaseLODActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsLODActorStaticObstacle");
		
		USurvivalGameplayStatics_IsLODActorStaticObstacle_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsLocalPlayerInRange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsLocalPlayerInRange(class UObject* WorldContextObject, const struct FVector& Location, float Range)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsLocalPlayerInRange");
		
		USurvivalGameplayStatics_IsLocalPlayerInRange_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Location = Location;
		params.Range = Range;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsLoadingSave
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsLoadingSave(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsLoadingSave");
		
		USurvivalGameplayStatics_IsLoadingSave_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsInCutscene
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsInCutscene(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsInCutscene");
		
		USurvivalGameplayStatics_IsInCutscene_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsHourNightTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Hour                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsHourNightTime(class UObject* WorldContextObject, float Hour)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsHourNightTime");
		
		USurvivalGameplayStatics_IsHourNightTime_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Hour = Hour;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsHourDayTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Hour                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsHourDayTime(class UObject* WorldContextObject, float Hour)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsHourDayTime");
		
		USurvivalGameplayStatics_IsHourDayTime_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Hour = Hour;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsHaulingItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsHaulingItems(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsHaulingItems");
		
		USurvivalGameplayStatics_IsHaulingItems_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsHalloweenHoliday
	 * 		Flags  -> ()
	 */
	bool USurvivalGameplayStatics::IsHalloweenHoliday()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsHalloweenHoliday");
		
		USurvivalGameplayStatics_IsHalloweenHoliday_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsGamepadAttached
	 * 		Flags  -> ()
	 */
	bool USurvivalGameplayStatics::IsGamepadAttached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsGamepadAttached");
		
		USurvivalGameplayStatics_IsGamepadAttached_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsFlightBuild
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsFlightBuild(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsFlightBuild");
		
		USurvivalGameplayStatics_IsFlightBuild_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsDemoMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsDemoMode(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsDemoMode");
		
		USurvivalGameplayStatics_IsDemoMode_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsDayTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsDayTime(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsDayTime");
		
		USurvivalGameplayStatics_IsDayTime_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsCurrentLevelMenuLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsCurrentLevelMenuLevel(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsCurrentLevelMenuLevel");
		
		USurvivalGameplayStatics_IsCurrentLevelMenuLevel_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsCraftingRecipeFromDataTableRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         DataTableRowHandle                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsCraftingRecipeFromDataTableRowHandle(const struct FDataTableRowHandle& DataTableRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsCraftingRecipeFromDataTableRowHandle");
		
		USurvivalGameplayStatics_IsCraftingRecipeFromDataTableRowHandle_Params params {};
		params.DataTableRowHandle = DataTableRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsConversationPlaying
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsConversationPlaying(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsConversationPlaying");
		
		USurvivalGameplayStatics_IsConversationPlaying_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsControlBound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ControlName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUsingGamepad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsControlBound(const class FName& ControlName, bool bUsingGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsControlBound");
		
		USurvivalGameplayStatics_IsControlBound_Params params {};
		params.ControlName = ControlName;
		params.bUsingGamepad = bUsingGamepad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsBuildingRecipeFromDataTableRowHandle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         DataTableRowHandle                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsBuildingRecipeFromDataTableRowHandle(const struct FDataTableRowHandle& DataTableRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsBuildingRecipeFromDataTableRowHandle");
		
		USurvivalGameplayStatics_IsBuildingRecipeFromDataTableRowHandle_Params params {};
		params.DataTableRowHandle = DataTableRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsAnyPartyMemberInRange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsAnyPartyMemberInRange(class UObject* WorldContextObject, const struct FVector& Location, float Range)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsAnyPartyMemberInRange");
		
		USurvivalGameplayStatics_IsAnyPartyMemberInRange_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Location = Location;
		params.Range = Range;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.IsActorStaticObstacle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::IsActorStaticObstacle(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.IsActorStaticObstacle");
		
		USurvivalGameplayStatics_IsActorStaticObstacle_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.InvalidateLightingCache
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ULightComponent*                             LightComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::InvalidateLightingCache(class ULightComponent* LightComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.InvalidateLightingCache");
		
		USurvivalGameplayStatics_InvalidateLightingCache_Params params {};
		params.LightComponent = LightComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.InteractShouldProvidePower
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                PowerType                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* USurvivalGameplayStatics::InteractShouldProvidePower(class AActor* InstigatedBy, const struct FGameplayTag& PowerType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.InteractShouldProvidePower");
		
		USurvivalGameplayStatics_InteractShouldProvidePower_Params params {};
		params.InstigatedBy = InstigatedBy;
		params.PowerType = PowerType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.HasUnlockedTechTreeRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         TechTreeRecipeRowHandle                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::HasUnlockedTechTreeRecipe(class UObject* WorldContextObject, const struct FDataTableRowHandle& TechTreeRecipeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.HasUnlockedTechTreeRecipe");
		
		USurvivalGameplayStatics_HasUnlockedTechTreeRecipe_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TechTreeRecipeRowHandle = TechTreeRecipeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.HasKeyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      SourceActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         KeyItemRowHandle                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::HasKeyItem(class AActor* SourceActor, const struct FDataTableRowHandle& KeyItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.HasKeyItem");
		
		USurvivalGameplayStatics_HasKeyItem_Params params {};
		params.SourceActor = SourceActor;
		params.KeyItemRowHandle = KeyItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.HandleRecipeUnlockFromItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		ERecipeUnlockType                                  RecipeUnlockType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FDataTableRowHandle> USurvivalGameplayStatics::HandleRecipeUnlockFromItem(class UObject* WorldContextObject, class APlayerState* PlayerState, const struct FDataTableRowHandle& ItemRowHandle, ERecipeUnlockType RecipeUnlockType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.HandleRecipeUnlockFromItem");
		
		USurvivalGameplayStatics_HandleRecipeUnlockFromItem_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PlayerState = PlayerState;
		params.ItemRowHandle = ItemRowHandle;
		params.RecipeUnlockType = RecipeUnlockType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.HandleNewResourceNotify
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::HandleNewResourceNotify(class UObject* WorldContextObject, class APlayerState* PlayerState, const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.HandleNewResourceNotify");
		
		USurvivalGameplayStatics_HandleNewResourceNotify_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PlayerState = PlayerState;
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetZoneManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UZoneManagerComponent* USurvivalGameplayStatics::GetZoneManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetZoneManager");
		
		USurvivalGameplayStatics_GetZoneManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetWorldTraceManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UWorldTraceManagerComponent* USurvivalGameplayStatics::GetWorldTraceManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetWorldTraceManager");
		
		USurvivalGameplayStatics_GetWorldTraceManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetWidgetManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UWidgetManager* USurvivalGameplayStatics::GetWidgetManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetWidgetManager");
		
		USurvivalGameplayStatics_GetWidgetManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetWaveManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UWaveManagerComponent* USurvivalGameplayStatics::GetWaveManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetWaveManager");
		
		USurvivalGameplayStatics_GetWaveManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetWaterSurfaceZ
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float USurvivalGameplayStatics::GetWaterSurfaceZ(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetWaterSurfaceZ");
		
		USurvivalGameplayStatics_GetWaterSurfaceZ_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetWaterManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UWaterManagerComponent* USurvivalGameplayStatics::GetWaterManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetWaterManager");
		
		USurvivalGameplayStatics_GetWaterManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetTotalGameHoursPassed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float USurvivalGameplayStatics::GetTotalGameHoursPassed(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetTotalGameHoursPassed");
		
		USurvivalGameplayStatics_GetTotalGameHoursPassed_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetThirstDamageType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* USurvivalGameplayStatics::GetThirstDamageType(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetThirstDamageType");
		
		USurvivalGameplayStatics_GetThirstDamageType_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetSurvivalWorldSettingsFrom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalWorldSettings* USurvivalGameplayStatics::GetSurvivalWorldSettingsFrom(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetSurvivalWorldSettingsFrom");
		
		USurvivalGameplayStatics_GetSurvivalWorldSettingsFrom_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetSurvivalWorldSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalWorldSettings* USurvivalGameplayStatics::GetSurvivalWorldSettings(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetSurvivalWorldSettings");
		
		USurvivalGameplayStatics_GetSurvivalWorldSettings_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetSurvivalPlayerController
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalPlayerController* USurvivalGameplayStatics::GetSurvivalPlayerController(class APawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetSurvivalPlayerController");
		
		USurvivalGameplayStatics_GetSurvivalPlayerController_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetSurvivalGameStateWorldSafe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalGameState* USurvivalGameplayStatics::GetSurvivalGameStateWorldSafe(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetSurvivalGameStateWorldSafe");
		
		USurvivalGameplayStatics_GetSurvivalGameStateWorldSafe_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetSurvivalGameStateFrom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalGameState* USurvivalGameplayStatics::GetSurvivalGameStateFrom(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetSurvivalGameStateFrom");
		
		USurvivalGameplayStatics_GetSurvivalGameStateFrom_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetSurvivalGameState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalGameState* USurvivalGameplayStatics::GetSurvivalGameState(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetSurvivalGameState");
		
		USurvivalGameplayStatics_GetSurvivalGameState_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetSurvivalGameModeManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USurvivalModeManagerComponent* USurvivalGameplayStatics::GetSurvivalGameModeManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetSurvivalGameModeManager");
		
		USurvivalGameplayStatics_GetSurvivalGameModeManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetSurvivalGameInstanceFrom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USurvivalGameInstance* USurvivalGameplayStatics::GetSurvivalGameInstanceFrom(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetSurvivalGameInstanceFrom");
		
		USurvivalGameplayStatics_GetSurvivalGameInstanceFrom_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetSurvivalGameInstance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USurvivalGameInstance* USurvivalGameplayStatics::GetSurvivalGameInstance(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetSurvivalGameInstance");
		
		USurvivalGameplayStatics_GetSurvivalGameInstance_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetSurvivalController
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalAIController* USurvivalGameplayStatics::GetSurvivalController(class APawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetSurvivalController");
		
		USurvivalGameplayStatics_GetSurvivalController_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetSurfaceMaterial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Point                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EPhysicalSurface USurvivalGameplayStatics::GetSurfaceMaterial(class UObject* WorldContextObject, struct FHitResult* OutHit, const struct FVector& Point)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetSurfaceMaterial");
		
		USurvivalGameplayStatics_GetSurfaceMaterial_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Point = Point;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetStatusEffectBaseValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStatusEffectType                                  StatusEffectType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float USurvivalGameplayStatics::GetStatusEffectBaseValue(EStatusEffectType StatusEffectType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetStatusEffectBaseValue");
		
		USurvivalGameplayStatics_GetStatusEffectBaseValue_Params params {};
		params.StatusEffectType = StatusEffectType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetSaveLoadManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USaveLoadManager* USurvivalGameplayStatics::GetSaveLoadManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetSaveLoadManager");
		
		USurvivalGameplayStatics_GetSaveLoadManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetResourceSurveyComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UResourceSurveyComponent* USurvivalGameplayStatics::GetResourceSurveyComponent(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetResourceSurveyComponent");
		
		USurvivalGameplayStatics_GetResourceSurveyComponent_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetRenderTargetManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URenderTargetManagerComponent* USurvivalGameplayStatics::GetRenderTargetManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetRenderTargetManager");
		
		USurvivalGameplayStatics_GetRenderTargetManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetRandomLocationAroundPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            PlayerIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinSpawnDistance                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxSpawnDistance                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector USurvivalGameplayStatics::GetRandomLocationAroundPlayer(class UObject* WorldContextObject, int32_t PlayerIndex, float MinSpawnDistance, float MaxSpawnDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetRandomLocationAroundPlayer");
		
		USurvivalGameplayStatics_GetRandomLocationAroundPlayer_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PlayerIndex = PlayerIndex;
		params.MinSpawnDistance = MinSpawnDistance;
		params.MaxSpawnDistance = MaxSpawnDistance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetQuestManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UQuestManagerComponent* USurvivalGameplayStatics::GetQuestManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetQuestManager");
		
		USurvivalGameplayStatics_GetQuestManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetPropManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UPropManagerComponent* USurvivalGameplayStatics::GetPropManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetPropManager");
		
		USurvivalGameplayStatics_GetPropManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetProjectionMatrix
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FMinimalViewInfo                            MinimalViewInfo                                            (Parm, NativeAccessSpecifierPublic)
	 */
	struct FMatrix USurvivalGameplayStatics::GetProjectionMatrix(const struct FMinimalViewInfo& MinimalViewInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetProjectionMatrix");
		
		USurvivalGameplayStatics_GetProjectionMatrix_Params params {};
		params.MinimalViewInfo = MinimalViewInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetPowerNetwork
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UPowerNetworkManagerComponent* USurvivalGameplayStatics::GetPowerNetwork(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetPowerNetwork");
		
		USurvivalGameplayStatics_GetPowerNetwork_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetPlayerStateMatchingUniqueID
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FUniqueNetIdRepl                            UniqueId                                                   (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalPlayerState* USurvivalGameplayStatics::GetPlayerStateMatchingUniqueID(class UObject* WorldContextObject, const struct FUniqueNetIdRepl& UniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetPlayerStateMatchingUniqueID");
		
		USurvivalGameplayStatics_GetPlayerStateMatchingUniqueID_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.UniqueId = UniqueId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetPlayerStateMatchingPlayerGuid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGuid                                       PlayerGuid                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalPlayerState* USurvivalGameplayStatics::GetPlayerStateMatchingPlayerGuid(class UObject* WorldContextObject, const struct FGuid& PlayerGuid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetPlayerStateMatchingPlayerGuid");
		
		USurvivalGameplayStatics_GetPlayerStateMatchingPlayerGuid_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PlayerGuid = PlayerGuid;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetPlayerStateMatchingCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACharacter*                                  Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalPlayerState* USurvivalGameplayStatics::GetPlayerStateMatchingCharacter(class ACharacter* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetPlayerStateMatchingCharacter");
		
		USurvivalGameplayStatics_GetPlayerStateMatchingCharacter_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetPlayerControllerMatchingPlayerState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalPlayerController* USurvivalGameplayStatics::GetPlayerControllerMatchingPlayerState(class UObject* WorldContextObject, class APlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetPlayerControllerMatchingPlayerState");
		
		USurvivalGameplayStatics_GetPlayerControllerMatchingPlayerState_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetPhysicalMaterialFromHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class UPhysicalMaterial* USurvivalGameplayStatics::GetPhysicalMaterialFromHit(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetPhysicalMaterialFromHit");
		
		USurvivalGameplayStatics_GetPhysicalMaterialFromHit_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetPartyComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UPartyComponent* USurvivalGameplayStatics::GetPartyComponent(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetPartyComponent");
		
		USurvivalGameplayStatics_GetPartyComponent_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetNearClipPlane
	 * 		Flags  -> ()
	 */
	float USurvivalGameplayStatics::GetNearClipPlane()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetNearClipPlane");
		
		USurvivalGameplayStatics_GetNearClipPlane_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetMusicManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UMusicManager* USurvivalGameplayStatics::GetMusicManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetMusicManager");
		
		USurvivalGameplayStatics_GetMusicManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetMetaBuildingsFeatureEnabled
	 * 		Flags  -> ()
	 */
	bool USurvivalGameplayStatics::GetMetaBuildingsFeatureEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetMetaBuildingsFeatureEnabled");
		
		USurvivalGameplayStatics_GetMetaBuildingsFeatureEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetMapComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UMapComponent* USurvivalGameplayStatics::GetMapComponent(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetMapComponent");
		
		USurvivalGameplayStatics_GetMapComponent_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetLODActorManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ULODActorManagerComponent* USurvivalGameplayStatics::GetLODActorManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetLODActorManager");
		
		USurvivalGameplayStatics_GetLODActorManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetLocalSurvivalPlayerTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform USurvivalGameplayStatics::GetLocalSurvivalPlayerTransform(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetLocalSurvivalPlayerTransform");
		
		USurvivalGameplayStatics_GetLocalSurvivalPlayerTransform_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetLocalSurvivalPlayerState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalPlayerState* USurvivalGameplayStatics::GetLocalSurvivalPlayerState(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetLocalSurvivalPlayerState");
		
		USurvivalGameplayStatics_GetLocalSurvivalPlayerState_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetLocalSurvivalPlayerController
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalPlayerController* USurvivalGameplayStatics::GetLocalSurvivalPlayerController(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetLocalSurvivalPlayerController");
		
		USurvivalGameplayStatics_GetLocalSurvivalPlayerController_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetLocalSurvivalPlayerCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASurvivalPlayerCharacter* USurvivalGameplayStatics::GetLocalSurvivalPlayerCharacter(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetLocalSurvivalPlayerCharacter");
		
		USurvivalGameplayStatics_GetLocalSurvivalPlayerCharacter_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetLocalSurvivalPlayerCapsule
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UCapsuleComponent* USurvivalGameplayStatics::GetLocalSurvivalPlayerCapsule(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetLocalSurvivalPlayerCapsule");
		
		USurvivalGameplayStatics_GetLocalSurvivalPlayerCapsule_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetItemSpawnManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemSpawnManager* USurvivalGameplayStatics::GetItemSpawnManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetItemSpawnManager");
		
		USurvivalGameplayStatics_GetItemSpawnManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetInterfaceNarrationManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UInterfaceNarrationManager* USurvivalGameplayStatics::GetInterfaceNarrationManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetInterfaceNarrationManager");
		
		USurvivalGameplayStatics_GetInterfaceNarrationManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetInterestManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UInterestManagerComponent* USurvivalGameplayStatics::GetInterestManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetInterestManager");
		
		USurvivalGameplayStatics_GetInterestManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         DataRow                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UObject* USurvivalGameplayStatics::GetIcon(const struct FDataTableRowHandle& DataRow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetIcon");
		
		USurvivalGameplayStatics_GetIcon_Params params {};
		params.DataRow = DataRow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetHungerDamageType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* USurvivalGameplayStatics::GetHungerDamageType(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetHungerDamageType");
		
		USurvivalGameplayStatics_GetHungerDamageType_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetHUDMarkerManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UHUDMarkerManagerComponent* USurvivalGameplayStatics::GetHUDMarkerManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetHUDMarkerManager");
		
		USurvivalGameplayStatics_GetHUDMarkerManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetGlobalUIData
	 * 		Flags  -> ()
	 */
	class UGlobalUIData* USurvivalGameplayStatics::GetGlobalUIData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetGlobalUIData");
		
		USurvivalGameplayStatics_GetGlobalUIData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetGlobalTamingData
	 * 		Flags  -> ()
	 */
	class UGlobalTamingData* USurvivalGameplayStatics::GetGlobalTamingData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetGlobalTamingData");
		
		USurvivalGameplayStatics_GetGlobalTamingData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetGlobalTableData
	 * 		Flags  -> ()
	 */
	class UGlobalTableData* USurvivalGameplayStatics::GetGlobalTableData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetGlobalTableData");
		
		USurvivalGameplayStatics_GetGlobalTableData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetGlobalItemData
	 * 		Flags  -> ()
	 */
	class UGlobalItemData* USurvivalGameplayStatics::GetGlobalItemData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetGlobalItemData");
		
		USurvivalGameplayStatics_GetGlobalItemData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetGlobalControlsData
	 * 		Flags  -> ()
	 */
	class UGlobalControlsData* USurvivalGameplayStatics::GetGlobalControlsData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetGlobalControlsData");
		
		USurvivalGameplayStatics_GetGlobalControlsData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetGlobalCombatData
	 * 		Flags  -> ()
	 */
	class UGlobalCombatData* USurvivalGameplayStatics::GetGlobalCombatData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetGlobalCombatData");
		
		USurvivalGameplayStatics_GetGlobalCombatData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetGlobalBuildingData
	 * 		Flags  -> ()
	 */
	class UGlobalBuildingData* USurvivalGameplayStatics::GetGlobalBuildingData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetGlobalBuildingData");
		
		USurvivalGameplayStatics_GetGlobalBuildingData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetGlobalAIData
	 * 		Flags  -> ()
	 */
	class UGlobalAIData* USurvivalGameplayStatics::GetGlobalAIData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetGlobalAIData");
		
		USurvivalGameplayStatics_GetGlobalAIData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetGenericDamageType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* USurvivalGameplayStatics::GetGenericDamageType(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetGenericDamageType");
		
		USurvivalGameplayStatics_GetGenericDamageType_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetGamePlatform
	 * 		Flags  -> ()
	 */
	EGamePlatform USurvivalGameplayStatics::GetGamePlatform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetGamePlatform");
		
		USurvivalGameplayStatics_GetGamePlatform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetGamePackageType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EGamePackageType USurvivalGameplayStatics::GetGamePackageType(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetGamePackageType");
		
		USurvivalGameplayStatics_GetGamePackageType_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetGameContentType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EGameContentType USurvivalGameplayStatics::GetGameContentType(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetGameContentType");
		
		USurvivalGameplayStatics_GetGameContentType_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetFoliageManagerComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UFoliageManagerComponent* USurvivalGameplayStatics::GetFoliageManagerComponent(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetFoliageManagerComponent");
		
		USurvivalGameplayStatics_GetFoliageManagerComponent_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetEquipmentMeshComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UMeshComponent* USurvivalGameplayStatics::GetEquipmentMeshComponent(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetEquipmentMeshComponent");
		
		USurvivalGameplayStatics_GetEquipmentMeshComponent_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetEnvironmentalDamageType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* USurvivalGameplayStatics::GetEnvironmentalDamageType(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetEnvironmentalDamageType");
		
		USurvivalGameplayStatics_GetEnvironmentalDamageType_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetDefaultObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ObjectClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UObject* USurvivalGameplayStatics::GetDefaultObject(class UClass* ObjectClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetDefaultObject");
		
		USurvivalGameplayStatics_GetDefaultObject_Params params {};
		params.ObjectClass = ObjectClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetDefaultComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UActorComponent*                             Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UActorComponent* USurvivalGameplayStatics::GetDefaultComponent(class UActorComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetDefaultComponent");
		
		USurvivalGameplayStatics_GetDefaultComponent_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetCutsceneComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UCutsceneComponent* USurvivalGameplayStatics::GetCutsceneComponent(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetCutsceneComponent");
		
		USurvivalGameplayStatics_GetCutsceneComponent_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetCurrentGameInputType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EGameInputType USurvivalGameplayStatics::GetCurrentGameInputType(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetCurrentGameInputType");
		
		USurvivalGameplayStatics_GetCurrentGameInputType_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetCraftingResultFromCraftingRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         CraftingRecipe                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle USurvivalGameplayStatics::GetCraftingResultFromCraftingRecipe(const struct FDataTableRowHandle& CraftingRecipe)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetCraftingResultFromCraftingRecipe");
		
		USurvivalGameplayStatics_GetCraftingResultFromCraftingRecipe_Params params {};
		params.CraftingRecipe = CraftingRecipe;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetCraftingResultFromBuildingRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         BuildingRecipe                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle USurvivalGameplayStatics::GetCraftingResultFromBuildingRecipe(const struct FDataTableRowHandle& BuildingRecipe)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetCraftingResultFromBuildingRecipe");
		
		USurvivalGameplayStatics_GetCraftingResultFromBuildingRecipe_Params params {};
		params.BuildingRecipe = BuildingRecipe;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetCraftingRecipeForItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle USurvivalGameplayStatics::GetCraftingRecipeForItem(class UObject* WorldContextObject, const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetCraftingRecipeForItem");
		
		USurvivalGameplayStatics_GetCraftingRecipeForItem_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetColorblindSetting
	 * 		Flags  -> ()
	 */
	EColorBlindModeSettings USurvivalGameplayStatics::GetColorblindSetting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetColorblindSetting");
		
		USurvivalGameplayStatics_GetColorblindSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetColonyManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UColonyManagerComponent* USurvivalGameplayStatics::GetColonyManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetColonyManager");
		
		USurvivalGameplayStatics_GetColonyManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetClosestPartyMemberDistanceSquared
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float USurvivalGameplayStatics::GetClosestPartyMemberDistanceSquared(class UObject* WorldContextObject, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetClosestPartyMemberDistanceSquared");
		
		USurvivalGameplayStatics_GetClosestPartyMemberDistanceSquared_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetCharacterTypeNameByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                TypeTag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLocString USurvivalGameplayStatics::GetCharacterTypeNameByTag(const struct FGameplayTag& TypeTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetCharacterTypeNameByTag");
		
		USurvivalGameplayStatics_GetCharacterTypeNameByTag_Params params {};
		params.TypeTag = TypeTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetCancelNearbyBlueprintsCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t USurvivalGameplayStatics::GetCancelNearbyBlueprintsCount(class AActor* Instigator, float Range)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetCancelNearbyBlueprintsCount");
		
		USurvivalGameplayStatics_GetCancelNearbyBlueprintsCount_Params params {};
		params.Instigator = Instigator;
		params.Range = Range;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetCalendarComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UCalendarComponent* USurvivalGameplayStatics::GetCalendarComponent(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetCalendarComponent");
		
		USurvivalGameplayStatics_GetCalendarComponent_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetBurgleQuestManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBurgleQuestManagerComponent* USurvivalGameplayStatics::GetBurgleQuestManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetBurgleQuestManager");
		
		USurvivalGameplayStatics_GetBurgleQuestManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetBuildingShoppingList
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FRecipeRequirements>                 Results                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::GetBuildingShoppingList(class UObject* WorldContextObject, TArray<struct FRecipeRequirements>* Results)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetBuildingShoppingList");
		
		USurvivalGameplayStatics_GetBuildingShoppingList_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Results != nullptr)
			*Results = params.Results;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetBuildingManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBuildingManagerComponent* USurvivalGameplayStatics::GetBuildingManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetBuildingManager");
		
		USurvivalGameplayStatics_GetBuildingManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetBuildConfigationType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EBuildConfigationType USurvivalGameplayStatics::GetBuildConfigationType(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetBuildConfigationType");
		
		USurvivalGameplayStatics_GetBuildConfigationType_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetBroadphaseBounds
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FBox USurvivalGameplayStatics::GetBroadphaseBounds(class UWorld* World)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetBroadphaseBounds");
		
		USurvivalGameplayStatics_GetBroadphaseBounds_Params params {};
		params.World = World;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetBigHeadsState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::GetBigHeadsState(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetBigHeadsState");
		
		USurvivalGameplayStatics_GetBigHeadsState_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetBestiaryComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBestiaryComponent* USurvivalGameplayStatics::GetBestiaryComponent(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetBestiaryComponent");
		
		USurvivalGameplayStatics_GetBestiaryComponent_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetBaseManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseManagerComponent* USurvivalGameplayStatics::GetBaseManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetBaseManager");
		
		USurvivalGameplayStatics_GetBaseManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetBadFoodDamageType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* USurvivalGameplayStatics::GetBadFoodDamageType(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetBadFoodDamageType");
		
		USurvivalGameplayStatics_GetBadFoodDamageType_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetArmorMeshComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEquipmentSlot                                     ArmorSlot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USkeletalMeshComponent* USurvivalGameplayStatics::GetArmorMeshComponent(class AActor* Actor, EEquipmentSlot ArmorSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetArmorMeshComponent");
		
		USurvivalGameplayStatics_GetArmorMeshComponent_Params params {};
		params.Actor = Actor;
		params.ArmorSlot = ArmorSlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetArachnophobiaSafeSetting
	 * 		Flags  -> ()
	 */
	int32_t USurvivalGameplayStatics::GetArachnophobiaSafeSetting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetArachnophobiaSafeSetting");
		
		USurvivalGameplayStatics_GetArachnophobiaSafeSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GetAnalyticsManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UMaineAnalyticsManager* USurvivalGameplayStatics::GetAnalyticsManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GetAnalyticsManager");
		
		USurvivalGameplayStatics_GetAnalyticsManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GenerateRandomPhysicsVolumeLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APhysicsVolume*                              PhysicsVolume                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::GenerateRandomPhysicsVolumeLocation(class UObject* WorldContextObject, class APhysicsVolume* PhysicsVolume, const struct FVector& Origin, float Range, struct FVector* Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GenerateRandomPhysicsVolumeLocation");
		
		USurvivalGameplayStatics_GenerateRandomPhysicsVolumeLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PhysicsVolume = PhysicsVolume;
		params.Origin = Origin;
		params.Range = Range;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Result != nullptr)
			*Result = params.Result;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.GenerateRandomNavLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FNavAgentProperties                         NavAgentProperties                                         (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::GenerateRandomNavLocation(class UObject* WorldContextObject, const struct FVector& Origin, float Range, const struct FNavAgentProperties& NavAgentProperties, struct FVector* Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.GenerateRandomNavLocation");
		
		USurvivalGameplayStatics_GenerateRandomNavLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Origin = Origin;
		params.Range = Range;
		params.NavAgentProperties = NavAgentProperties;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Result != nullptr)
			*Result = params.Result;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.FlushPrestreamTextures
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::FlushPrestreamTextures(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.FlushPrestreamTextures");
		
		USurvivalGameplayStatics_FlushPrestreamTextures_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.FloatPositiveInfinity
	 * 		Flags  -> ()
	 */
	float USurvivalGameplayStatics::FloatPositiveInfinity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.FloatPositiveInfinity");
		
		USurvivalGameplayStatics_FloatPositiveInfinity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.FloatNegativeInfinity
	 * 		Flags  -> ()
	 */
	float USurvivalGameplayStatics::FloatNegativeInfinity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.FloatNegativeInfinity");
		
		USurvivalGameplayStatics_FloatNegativeInfinity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.FindLODActorForObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* USurvivalGameplayStatics::FindLODActorForObject(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.FindLODActorForObject");
		
		USurvivalGameplayStatics_FindLODActorForObject_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.FindLODActorForComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UActorComponent*                             Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* USurvivalGameplayStatics::FindLODActorForComponent(class UActorComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.FindLODActorForComponent");
		
		USurvivalGameplayStatics_FindLODActorForComponent_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.FindLODActorForAny
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* USurvivalGameplayStatics::FindLODActorForAny(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.FindLODActorForAny");
		
		USurvivalGameplayStatics_FindLODActorForAny_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.FindLODActorForActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseLODActor* USurvivalGameplayStatics::FindLODActorForActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.FindLODActorForActor");
		
		USurvivalGameplayStatics_FindLODActorForActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.FindDefaultComponentsByClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ComponentClass                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UActorComponent*> USurvivalGameplayStatics::FindDefaultComponentsByClass(class AActor* Actor, class UClass* ComponentClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.FindDefaultComponentsByClass");
		
		USurvivalGameplayStatics_FindDefaultComponentsByClass_Params params {};
		params.Actor = Actor;
		params.ComponentClass = ComponentClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.FindDefaultComponentByName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ComponentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UActorComponent* USurvivalGameplayStatics::FindDefaultComponentByName(class AActor* Actor, const class FName& ComponentName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.FindDefaultComponentByName");
		
		USurvivalGameplayStatics_FindDefaultComponentByName_Params params {};
		params.Actor = Actor;
		params.ComponentName = ComponentName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.FindDefaultComponentByClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ComponentClass                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UActorComponent* USurvivalGameplayStatics::FindDefaultComponentByClass(class AActor* Actor, class UClass* ComponentClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.FindDefaultComponentByClass");
		
		USurvivalGameplayStatics_FindDefaultComponentByClass_Params params {};
		params.Actor = Actor;
		params.ComponentClass = ComponentClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.FastForwardPhysics
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         Primitive                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector USurvivalGameplayStatics::FastForwardPhysics(class UPrimitiveComponent* Primitive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.FastForwardPhysics");
		
		USurvivalGameplayStatics_FastForwardPhysics_Params params {};
		params.Primitive = Primitive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.EnableForegroundDOF
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              MaxRadius                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::EnableForegroundDOF(float MaxRadius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.EnableForegroundDOF");
		
		USurvivalGameplayStatics_EnableForegroundDOF_Params params {};
		params.MaxRadius = MaxRadius;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.DisableForegroundDOF
	 * 		Flags  -> ()
	 */
	void USurvivalGameplayStatics::DisableForegroundDOF()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.DisableForegroundDOF");
		
		USurvivalGameplayStatics_DisableForegroundDOF_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.DefragItemList
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UItem*>                               ItemList                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		bool                                               SingleItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::DefragItemList(TArray<class UItem*> ItemList, bool SingleItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.DefragItemList");
		
		USurvivalGameplayStatics_DefragItemList_Params params {};
		params.ItemList = ItemList;
		params.SingleItem = SingleItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.DealDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageData                                 DamageData                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::DealDamage(class AActor* TargetActor, const struct FDamageData& DamageData, class AController* InstigatedBy, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.DealDamage");
		
		USurvivalGameplayStatics_DealDamage_Params params {};
		params.TargetActor = TargetActor;
		params.DamageData = DamageData;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.CreateItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ItemType                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UItem* USurvivalGameplayStatics::CreateItem(class UObject* WorldContextObject, const struct FDataTableRowHandle& ItemType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.CreateItem");
		
		USurvivalGameplayStatics_CreateItem_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.ItemType = ItemType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.ConsumableHasPositiveSurvivalStat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ConsumableDataHandle                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EStatusEffectType                                  Stat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::ConsumableHasPositiveSurvivalStat(const struct FDataTableRowHandle& ConsumableDataHandle, EStatusEffectType Stat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.ConsumableHasPositiveSurvivalStat");
		
		USurvivalGameplayStatics_ConsumableHasPositiveSurvivalStat_Params params {};
		params.ConsumableDataHandle = ConsumableDataHandle;
		params.Stat = Stat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.ConsumableHasNegativeEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ConsumableDataHandle                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::ConsumableHasNegativeEffect(const struct FDataTableRowHandle& ConsumableDataHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.ConsumableHasNegativeEffect");
		
		USurvivalGameplayStatics_ConsumableHasNegativeEffect_Params params {};
		params.ConsumableDataHandle = ConsumableDataHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.CanItemBeAnalyzed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::CanItemBeAnalyzed(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.CanItemBeAnalyzed");
		
		USurvivalGameplayStatics_CanItemBeAnalyzed_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.CanDefragItemList
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UItem*>                               ItemList                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::CanDefragItemList(TArray<class UItem*> ItemList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.CanDefragItemList");
		
		USurvivalGameplayStatics_CanDefragItemList_Params params {};
		params.ItemList = ItemList;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.CanCraftIngredientViaRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         IngredientRowHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::CanCraftIngredientViaRecipe(const struct FDataTableRowHandle& IngredientRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.CanCraftIngredientViaRecipe");
		
		USurvivalGameplayStatics_CanCraftIngredientViaRecipe_Params params {};
		params.IngredientRowHandle = IngredientRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.CancelNearbyBlueprints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::CancelNearbyBlueprints(class AActor* Instigator, float Range)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.CancelNearbyBlueprints");
		
		USurvivalGameplayStatics_CancelNearbyBlueprints_Params params {};
		params.Instigator = Instigator;
		params.Range = Range;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.ApplyConsumableEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDataTableRowHandle>                 ConsumableData                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		bool                                               PlayChatter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::ApplyConsumableEffects(class AActor* InstigatedBy, TArray<struct FDataTableRowHandle> ConsumableData, bool PlayChatter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.ApplyConsumableEffects");
		
		USurvivalGameplayStatics_ApplyConsumableEffects_Params params {};
		params.InstigatedBy = InstigatedBy;
		params.ConsumableData = ConsumableData;
		params.PlayChatter = PlayChatter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.ApplyConsumableEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ConsumableDataHandle                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               PlayChatter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::ApplyConsumableEffect(class AActor* InstigatedBy, const struct FDataTableRowHandle& ConsumableDataHandle, bool PlayChatter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.ApplyConsumableEffect");
		
		USurvivalGameplayStatics_ApplyConsumableEffect_Params params {};
		params.InstigatedBy = InstigatedBy;
		params.ConsumableDataHandle = ConsumableDataHandle;
		params.PlayChatter = PlayChatter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.ApplyBuoyantForceWithSurface
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMeshComponent*                        Mesh                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SurfaceWorldZ                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::ApplyBuoyantForceWithSurface(class UStaticMeshComponent* Mesh, float SurfaceWorldZ)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.ApplyBuoyantForceWithSurface");
		
		USurvivalGameplayStatics_ApplyBuoyantForceWithSurface_Params params {};
		params.Mesh = Mesh;
		params.SurfaceWorldZ = SurfaceWorldZ;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.ApplyBuoyantForceToMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMeshComponent*                        Mesh                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::ApplyBuoyantForceToMesh(class UStaticMeshComponent* Mesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.ApplyBuoyantForceToMesh");
		
		USurvivalGameplayStatics_ApplyBuoyantForceToMesh_Params params {};
		params.Mesh = Mesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.ApplyBuoyantForce
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMeshComponent*                        Mesh                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      WaterVolume                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::ApplyBuoyantForce(class UStaticMeshComponent* Mesh, class AActor* WaterVolume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.ApplyBuoyantForce");
		
		USurvivalGameplayStatics_ApplyBuoyantForce_Params params {};
		params.Mesh = Mesh;
		params.WaterVolume = WaterVolume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.AnyConsumableHasPositiveSurvivalStat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 ConsumableData                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		EStatusEffectType                                  Stat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::AnyConsumableHasPositiveSurvivalStat(TArray<struct FDataTableRowHandle> ConsumableData, EStatusEffectType Stat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.AnyConsumableHasPositiveSurvivalStat");
		
		USurvivalGameplayStatics_AnyConsumableHasPositiveSurvivalStat_Params params {};
		params.ConsumableData = ConsumableData;
		params.Stat = Stat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.AnyConsumableHasNegativeEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDataTableRowHandle>                 ConsumableData                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::AnyConsumableHasNegativeEffect(TArray<struct FDataTableRowHandle> ConsumableData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.AnyConsumableHasNegativeEffect");
		
		USurvivalGameplayStatics_AnyConsumableHasNegativeEffect_Params params {};
		params.ConsumableData = ConsumableData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.AddObjectiveToItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::AddObjectiveToItem(class UObject* WorldContextObject, const struct FDataTableRowHandle& ItemRowHandle, const struct FVector& Location, float Radius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.AddObjectiveToItem");
		
		USurvivalGameplayStatics_AddObjectiveToItem_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.ItemRowHandle = ItemRowHandle;
		params.Location = Location;
		params.Radius = Radius;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.ActorHasGameplayTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagContainer                       Tags                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool USurvivalGameplayStatics::ActorHasGameplayTag(class AActor* Actor, const struct FGameplayTagContainer& Tags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.ActorHasGameplayTag");
		
		USurvivalGameplayStatics_ActorHasGameplayTag_Params params {};
		params.Actor = Actor;
		params.Tags = Tags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameplayStatics.AbortAllConversations
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalGameplayStatics::AbortAllConversations(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameplayStatics.AbortAllConversations");
		
		USurvivalGameplayStatics_AbortAllConversations_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalGameplayStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalGameplayStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalGameplayStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASurvivalGameSession.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASurvivalGameSession::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalGameSession");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.UnRegisterGlobalVariableChangedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       GlobalVariableID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              Event                                                      (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::UnRegisterGlobalVariableChangedEvent(const struct FGuid& GlobalVariableID, const class FScriptDelegate& Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.UnRegisterGlobalVariableChangedEvent");
		
		ASurvivalGameState_UnRegisterGlobalVariableChangedEvent_Params params {};
		params.GlobalVariableID = GlobalVariableID;
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.TriggerGameStartViaLobby
	 * 		Flags  -> ()
	 */
	void ASurvivalGameState::TriggerGameStartViaLobby()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.TriggerGameStartViaLobby");
		
		ASurvivalGameState_TriggerGameStartViaLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.SetInCutscene
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               InCutscene                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::SetInCutscene(bool InCutscene)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.SetInCutscene");
		
		ASurvivalGameState_SetInCutscene_Params params {};
		params.InCutscene = InCutscene;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.ServerSetBigHeads
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::ServerSetBigHeads(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.ServerSetBigHeads");
		
		ASurvivalGameState_ServerSetBigHeads_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.RegisterGlobalVariableChangedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       GlobalVariableID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              Event                                                      (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::RegisterGlobalVariableChangedEvent(const struct FGuid& GlobalVariableID, const class FScriptDelegate& Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.RegisterGlobalVariableChangedEvent");
		
		ASurvivalGameState_RegisterGlobalVariableChangedEvent_Params params {};
		params.GlobalVariableID = GlobalVariableID;
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.OnRep_LobbyGameStarted
	 * 		Flags  -> ()
	 */
	void ASurvivalGameState::OnRep_LobbyGameStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.OnRep_LobbyGameStarted");
		
		ASurvivalGameState_OnRep_LobbyGameStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.MulticastPlayVFXLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UVisualEffect*                               Effect                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::MulticastPlayVFXLocation(class UVisualEffect* Effect, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.MulticastPlayVFXLocation");
		
		ASurvivalGameState_MulticastPlayVFXLocation_Params params {};
		params.Effect = Effect;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.MulticastPlayItemConsumeAudioAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::MulticastPlayItemConsumeAudioAtLocation(const struct FDataTableRowHandle& ItemRowHandle, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.MulticastPlayItemConsumeAudioAtLocation");
		
		ASurvivalGameState_MulticastPlayItemConsumeAudioAtLocation_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.MulticastPlayAudioAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USoundCue*                                   Cue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::MulticastPlayAudioAtLocation(class USoundCue* Cue, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.MulticastPlayAudioAtLocation");
		
		ASurvivalGameState_MulticastPlayAudioAtLocation_Params params {};
		params.Cue = Cue;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.MulticastNotifyPlayerLeave
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPlayerDisconnectReason                            Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::MulticastNotifyPlayerLeave(class APlayerState* PlayerState, EPlayerDisconnectReason Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.MulticastNotifyPlayerLeave");
		
		ASurvivalGameState_MulticastNotifyPlayerLeave_Params params {};
		params.PlayerState = PlayerState;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.MulticastNotifyPlayerJoin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::MulticastNotifyPlayerJoin(class APlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.MulticastNotifyPlayerJoin");
		
		ASurvivalGameState_MulticastNotifyPlayerJoin_Params params {};
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.MulticastNotifyPlayerDown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDeathInfo                                  DeathInfo                                                  (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::MulticastNotifyPlayerDown(class APlayerState* PlayerState, const struct FDeathInfo& DeathInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.MulticastNotifyPlayerDown");
		
		ASurvivalGameState_MulticastNotifyPlayerDown_Params params {};
		params.PlayerState = PlayerState;
		params.DeathInfo = DeathInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.MulticastNotifyPetDeparted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalPlayerCharacter*                    ToPlayer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      PetName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::MulticastNotifyPetDeparted(class ASurvivalPlayerCharacter* ToPlayer, const class FString& PetName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.MulticastNotifyPetDeparted");
		
		ASurvivalGameState_MulticastNotifyPetDeparted_Params params {};
		params.ToPlayer = ToPlayer;
		params.PetName = PetName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.MulticastNotifyEndOfEarlyAccessContent
	 * 		Flags  -> ()
	 */
	void ASurvivalGameState::MulticastNotifyEndOfEarlyAccessContent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.MulticastNotifyEndOfEarlyAccessContent");
		
		ASurvivalGameState_MulticastNotifyEndOfEarlyAccessContent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.HandlePatchSaveGameRepair
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameVersion                                LoadedVersion                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EGamePackageType                                   GamePackageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::HandlePatchSaveGameRepair(const struct FGameVersion& LoadedVersion, EGamePackageType GamePackageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.HandlePatchSaveGameRepair");
		
		ASurvivalGameState_HandlePatchSaveGameRepair_Params params {};
		params.LoadedVersion = LoadedVersion;
		params.GamePackageType = GamePackageType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.HandleEndEarlyAccessConent
	 * 		Flags  -> ()
	 */
	void ASurvivalGameState::HandleEndEarlyAccessConent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.HandleEndEarlyAccessConent");
		
		ASurvivalGameState_HandleEndEarlyAccessConent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.GetItemSpawnManager
	 * 		Flags  -> ()
	 */
	class AItemSpawnManager* ASurvivalGameState::GetItemSpawnManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.GetItemSpawnManager");
		
		ASurvivalGameState_GetItemSpawnManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.GetInCutscene
	 * 		Flags  -> ()
	 */
	bool ASurvivalGameState::GetInCutscene()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.GetInCutscene");
		
		ASurvivalGameState_GetInCutscene_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.GetHUDMarkerManagerComponent
	 * 		Flags  -> ()
	 */
	class UHUDMarkerManagerComponent* ASurvivalGameState::GetHUDMarkerManagerComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.GetHUDMarkerManagerComponent");
		
		ASurvivalGameState_GetHUDMarkerManagerComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.GetFoliageManagerComponent
	 * 		Flags  -> ()
	 */
	class UFoliageManagerComponent* ASurvivalGameState::GetFoliageManagerComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.GetFoliageManagerComponent");
		
		ASurvivalGameState_GetFoliageManagerComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.GetBigHeadsState
	 * 		Flags  -> ()
	 */
	bool ASurvivalGameState::GetBigHeadsState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.GetBigHeadsState");
		
		ASurvivalGameState_GetBigHeadsState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.GetAmbienceManager
	 * 		Flags  -> ()
	 */
	class UAmbienceManager* ASurvivalGameState::GetAmbienceManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.GetAmbienceManager");
		
		ASurvivalGameState_GetAmbienceManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.ClientSendFileContents
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filename                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<unsigned char>                              Buffer                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::ClientSendFileContents(const class FString& Filename, TArray<unsigned char> Buffer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.ClientSendFileContents");
		
		ASurvivalGameState_ClientSendFileContents_Params params {};
		params.Filename = Filename;
		params.Buffer = Buffer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.ClientEndStreamFile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filename                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Hash                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::ClientEndStreamFile(const class FString& Filename, const class FString& Hash)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.ClientEndStreamFile");
		
		ASurvivalGameState_ClientEndStreamFile_Params params {};
		params.Filename = Filename;
		params.Hash = Hash;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.ClientBeginStreamFile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SaveName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Filename                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int64_t                                            FileSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalGameState::ClientBeginStreamFile(const class FString& SaveName, const class FString& Filename, int64_t FileSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.ClientBeginStreamFile");
		
		ASurvivalGameState_ClientBeginStreamFile_Params params {};
		params.SaveName = SaveName;
		params.Filename = Filename;
		params.FileSize = FileSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalGameState.BigHeads
	 * 		Flags  -> ()
	 */
	void ASurvivalGameState::BigHeads()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalGameState.BigHeads");
		
		ASurvivalGameState_BigHeads_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASurvivalGameState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASurvivalGameState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalGameState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalMemoryReport.SetLevelVisibility
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      LevelName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Visibility                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalMemoryReport::SetLevelVisibility(const class FString& LevelName, int32_t Visibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalMemoryReport.SetLevelVisibility");
		
		USurvivalMemoryReport_SetLevelVisibility_Params params {};
		params.LevelName = LevelName;
		params.Visibility = Visibility;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalMemoryReport.GenerateUnusedCollisionReport
	 * 		Flags  -> ()
	 */
	void USurvivalMemoryReport::GenerateUnusedCollisionReport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalMemoryReport.GenerateUnusedCollisionReport");
		
		USurvivalMemoryReport_GenerateUnusedCollisionReport_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalMemoryReport.GenerateStreamingTextureReport
	 * 		Flags  -> ()
	 */
	void USurvivalMemoryReport::GenerateStreamingTextureReport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalMemoryReport.GenerateStreamingTextureReport");
		
		USurvivalMemoryReport_GenerateStreamingTextureReport_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalMemoryReport.GenerateNonStreamingTextureReport
	 * 		Flags  -> ()
	 */
	void USurvivalMemoryReport::GenerateNonStreamingTextureReport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalMemoryReport.GenerateNonStreamingTextureReport");
		
		USurvivalMemoryReport_GenerateNonStreamingTextureReport_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalMemoryReport.GenerateMemoryReport
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            FullReport                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalMemoryReport::GenerateMemoryReport(int32_t FullReport)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalMemoryReport.GenerateMemoryReport");
		
		USurvivalMemoryReport_GenerateMemoryReport_Params params {};
		params.FullReport = FullReport;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalMemoryReport.GenerateIncompressibleTexturesReport
	 * 		Flags  -> ()
	 */
	void USurvivalMemoryReport::GenerateIncompressibleTexturesReport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalMemoryReport.GenerateIncompressibleTexturesReport");
		
		USurvivalMemoryReport_GenerateIncompressibleTexturesReport_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalMemoryReport.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalMemoryReport::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalMemoryReport");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalMemoryReportSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalMemoryReportSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalMemoryReportSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalModeManagerComponent.SetGameMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGameMode                                          SelectedGameMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurvivalModeManagerComponent::SetGameMode(EGameMode SelectedGameMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalModeManagerComponent.SetGameMode");
		
		USurvivalModeManagerComponent_SetGameMode_Params params {};
		params.SelectedGameMode = SelectedGameMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalModeManagerComponent.OnRep_CurrentGameMode
	 * 		Flags  -> ()
	 */
	void USurvivalModeManagerComponent::OnRep_CurrentGameMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalModeManagerComponent.OnRep_CurrentGameMode");
		
		USurvivalModeManagerComponent_OnRep_CurrentGameMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalModeManagerComponent.GetGameModeSettings
	 * 		Flags  -> ()
	 */
	class USurvivalGameModeSettings* USurvivalModeManagerComponent::GetGameModeSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalModeManagerComponent.GetGameModeSettings");
		
		USurvivalModeManagerComponent_GetGameModeSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalModeManagerComponent.GetGameMode
	 * 		Flags  -> ()
	 */
	EGameMode USurvivalModeManagerComponent::GetGameMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalModeManagerComponent.GetGameMode");
		
		USurvivalModeManagerComponent_GetGameMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalModeManagerComponent.DoRecipesRequireIngredients
	 * 		Flags  -> ()
	 */
	bool USurvivalModeManagerComponent::DoRecipesRequireIngredients()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalModeManagerComponent.DoRecipesRequireIngredients");
		
		USurvivalModeManagerComponent_DoRecipesRequireIngredients_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalModeManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalModeManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalModeManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.UpdateAppearance
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::UpdateAppearance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.UpdateAppearance");
		
		ASurvivalPlayerCharacter_UpdateAppearance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.TryPickupItemRow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRow                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bEquip                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerCharacter::TryPickupItemRow(const struct FDataTableRowHandle& ItemRow, bool bEquip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.TryPickupItemRow");
		
		ASurvivalPlayerCharacter_TryPickupItemRow_Params params {};
		params.ItemRow = ItemRow;
		params.bEquip = bEquip;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.TryPickupItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEquip                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerCharacter::TryPickupItem(class UItem* Item, bool bEquip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.TryPickupItem");
		
		ASurvivalPlayerCharacter_TryPickupItem_Params params {};
		params.Item = Item;
		params.bEquip = bEquip;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.TestCurrentAttack
	 * 		Flags  -> ()
	 */
	EAttackResolutionType ASurvivalPlayerCharacter::TestCurrentAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.TestCurrentAttack");
		
		ASurvivalPlayerCharacter_TestCurrentAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ShouldShowTargetInteractionInterface
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerCharacter::ShouldShowTargetInteractionInterface(EInteractionChannel Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ShouldShowTargetInteractionInterface");
		
		ASurvivalPlayerCharacter_ShouldShowTargetInteractionInterface_Params params {};
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.SetSpyGlassOverlay
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::SetSpyGlassOverlay(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.SetSpyGlassOverlay");
		
		ASurvivalPlayerCharacter_SetSpyGlassOverlay_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerThrowItem
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerThrowItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerThrowItem");
		
		ASurvivalPlayerCharacter_ServerThrowItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerTeleportPartyNear
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerTeleportPartyNear()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerTeleportPartyNear");
		
		ASurvivalPlayerCharacter_ServerTeleportPartyNear_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerStoreOrSwapPet
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APetHomeBuilding*                            WithBuilding                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerStoreOrSwapPet(class APetHomeBuilding* WithBuilding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerStoreOrSwapPet");
		
		ASurvivalPlayerCharacter_ServerStoreOrSwapPet_Params params {};
		params.WithBuilding = WithBuilding;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerStopRequestInventories
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerStopRequestInventories(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerStopRequestInventories");
		
		ASurvivalPlayerCharacter_ServerStopRequestInventories_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerStartThrow
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerStartThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerStartThrow");
		
		ASurvivalPlayerCharacter_ServerStartThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerStartRequestInventories
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerStartRequestInventories(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerStartRequestInventories");
		
		ASurvivalPlayerCharacter_ServerStartRequestInventories_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerStandup
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerStandup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerStandup");
		
		ASurvivalPlayerCharacter_ServerStandup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerShowPlayerIsBusyInMenu
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               PlayerBusyInMenu                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerShowPlayerIsBusyInMenu(bool PlayerBusyInMenu)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerShowPlayerIsBusyInMenu");
		
		ASurvivalPlayerCharacter_ServerShowPlayerIsBusyInMenu_Params params {};
		params.PlayerBusyInMenu = PlayerBusyInMenu;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerSetRespawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      RestActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerSetRespawn(class AActor* RestActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerSetRespawn");
		
		ASurvivalPlayerCharacter_ServerSetRespawn_Params params {};
		params.RestActor = RestActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerSelectAmmoType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       AmmoItem                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerSelectAmmoType(class UItem* AmmoItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerSelectAmmoType");
		
		ASurvivalPlayerCharacter_ServerSelectAmmoType_Params params {};
		params.AmmoItem = AmmoItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerRevive
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerRevive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerRevive");
		
		ASurvivalPlayerCharacter_ServerRevive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerRequestTechTreeRecipePurchase
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TechTreeRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerRequestTechTreeRecipePurchase(const struct FDataTableRowHandle& TechTreeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerRequestTechTreeRecipePurchase");
		
		ASurvivalPlayerCharacter_ServerRequestTechTreeRecipePurchase_Params params {};
		params.TechTreeRowHandle = TechTreeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerRequestRest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      aRestActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerRequestRest(class AActor* aRestActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerRequestRest");
		
		ASurvivalPlayerCharacter_ServerRequestRest_Params params {};
		params.aRestActor = aRestActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerRequestProcessItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AItemProcessingBuilding*                     ProcessingBuilding                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       ItemToProcess                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerRequestProcessItem(class AItemProcessingBuilding* ProcessingBuilding, class UItem* ItemToProcess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerRequestProcessItem");
		
		ASurvivalPlayerCharacter_ServerRequestProcessItem_Params params {};
		params.ProcessingBuilding = ProcessingBuilding;
		params.ItemToProcess = ItemToProcess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerRequestHUDMarkerUpdate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABuilding*                                   Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            IconVariant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ColorVariant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerRequestHUDMarkerUpdate(class ABuilding* Building, int32_t IconVariant, int32_t ColorVariant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerRequestHUDMarkerUpdate");
		
		ASurvivalPlayerCharacter_ServerRequestHUDMarkerUpdate_Params params {};
		params.Building = Building;
		params.IconVariant = IconVariant;
		params.ColorVariant = ColorVariant;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerRequestCancelProcessItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AItemProcessingBuilding*                     ProcessingBuilding                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       ItemToCancel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerRequestCancelProcessItem(class AItemProcessingBuilding* ProcessingBuilding, class UItem* ItemToCancel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerRequestCancelProcessItem");
		
		ASurvivalPlayerCharacter_ServerRequestCancelProcessItem_Params params {};
		params.ProcessingBuilding = ProcessingBuilding;
		params.ItemToCancel = ItemToCancel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerRepairItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerRepairItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerRepairItem");
		
		ASurvivalPlayerCharacter_ServerRepairItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerRenamePet
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCreature*                           Creature                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        NewName                                                    (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerRenamePet(class ASurvivalCreature* Creature, const class FText& NewName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerRenamePet");
		
		ASurvivalPlayerCharacter_ServerRenamePet_Params params {};
		params.Creature = Creature;
		params.NewName = NewName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerRemoveWaypoint
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerRemoveWaypoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerRemoveWaypoint");
		
		ASurvivalPlayerCharacter_ServerRemoveWaypoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerRemoveResourceWaypoint
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerRemoveResourceWaypoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerRemoveResourceWaypoint");
		
		ASurvivalPlayerCharacter_ServerRemoveResourceWaypoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerReleaseThrow
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerReleaseThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerReleaseThrow");
		
		ASurvivalPlayerCharacter_ServerReleaseThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerReleaseAttack
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerReleaseAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerReleaseAttack");
		
		ASurvivalPlayerCharacter_ServerReleaseAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerPowerSwitchPressed
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerPowerSwitchPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerPowerSwitchPressed");
		
		ASurvivalPlayerCharacter_ServerPowerSwitchPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerPlaceResourceWaypoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     WorldLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerPlaceResourceWaypoint(const struct FVector& WorldLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerPlaceResourceWaypoint");
		
		ASurvivalPlayerCharacter_ServerPlaceResourceWaypoint_Params params {};
		params.WorldLocation = WorldLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerKill
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerKill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerKill");
		
		ASurvivalPlayerCharacter_ServerKill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerInteractWirePlacement
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerInteractWirePlacement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerInteractWirePlacement");
		
		ASurvivalPlayerCharacter_ServerInteractWirePlacement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerInteractRelocate
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerInteractRelocate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerInteractRelocate");
		
		ASurvivalPlayerCharacter_ServerInteractRelocate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerInputPlaceMapMarkerPressed
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerInputPlaceMapMarkerPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerInputPlaceMapMarkerPressed");
		
		ASurvivalPlayerCharacter_ServerInputPlaceMapMarkerPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerHotDrop
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerHotDrop(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerHotDrop");
		
		ASurvivalPlayerCharacter_ServerHotDrop_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerHoldAttack
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerHoldAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerHoldAttack");
		
		ASurvivalPlayerCharacter_ServerHoldAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerHandleInteractCancel
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerHandleInteractCancel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerHandleInteractCancel");
		
		ASurvivalPlayerCharacter_ServerHandleInteractCancel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerHandleInteract
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerHandleInteract()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerHandleInteract");
		
		ASurvivalPlayerCharacter_ServerHandleInteract_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerHandleHoldInteractFoliage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     InteractableObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FFoliageKey                                 MatchingFoliageKey                                         (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerHandleHoldInteractFoliage(class UObject* InteractableObject, const struct FFoliageKey& MatchingFoliageKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerHandleHoldInteractFoliage");
		
		ASurvivalPlayerCharacter_ServerHandleHoldInteractFoliage_Params params {};
		params.InteractableObject = InteractableObject;
		params.MatchingFoliageKey = MatchingFoliageKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerHandleHoldInteractCancelFoliage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     InteractableObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FFoliageKey                                 MatchingFoliageKey                                         (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerHandleHoldInteractCancelFoliage(class UObject* InteractableObject, const struct FFoliageKey& MatchingFoliageKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerHandleHoldInteractCancelFoliage");
		
		ASurvivalPlayerCharacter_ServerHandleHoldInteractCancelFoliage_Params params {};
		params.InteractableObject = InteractableObject;
		params.MatchingFoliageKey = MatchingFoliageKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerHandleHoldInteractCancelBuilding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     InteractableObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridBuildingId                     MatchingBuildingKey                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerHandleHoldInteractCancelBuilding(class UObject* InteractableObject, const struct FBuildingGridBuildingId& MatchingBuildingKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerHandleHoldInteractCancelBuilding");
		
		ASurvivalPlayerCharacter_ServerHandleHoldInteractCancelBuilding_Params params {};
		params.InteractableObject = InteractableObject;
		params.MatchingBuildingKey = MatchingBuildingKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerHandleHoldInteractCancelActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     InteractableObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerHandleHoldInteractCancelActor(class UObject* InteractableObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerHandleHoldInteractCancelActor");
		
		ASurvivalPlayerCharacter_ServerHandleHoldInteractCancelActor_Params params {};
		params.InteractableObject = InteractableObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerHandleHoldInteractBuilding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     InteractableObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridBuildingId                     MatchingBuildingKey                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerHandleHoldInteractBuilding(class UObject* InteractableObject, const struct FBuildingGridBuildingId& MatchingBuildingKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerHandleHoldInteractBuilding");
		
		ASurvivalPlayerCharacter_ServerHandleHoldInteractBuilding_Params params {};
		params.InteractableObject = InteractableObject;
		params.MatchingBuildingKey = MatchingBuildingKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerHandleHoldInteractActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     InteractableObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerHandleHoldInteractActor(class UObject* InteractableObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerHandleHoldInteractActor");
		
		ASurvivalPlayerCharacter_ServerHandleHoldInteractActor_Params params {};
		params.InteractableObject = InteractableObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerHandleFireInteract
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerHandleFireInteract()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerHandleFireInteract");
		
		ASurvivalPlayerCharacter_ServerHandleFireInteract_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerHandleDrop
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     InteractableObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerHandleDrop(class UObject* InteractableObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerHandleDrop");
		
		ASurvivalPlayerCharacter_ServerHandleDrop_Params params {};
		params.InteractableObject = InteractableObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerFullRestore
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerFullRestore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerFullRestore");
		
		ASurvivalPlayerCharacter_ServerFullRestore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerExitSpyGlassMode
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerExitSpyGlassMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerExitSpyGlassMode");
		
		ASurvivalPlayerCharacter_ServerExitSpyGlassMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerExitSplineClimbing
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerExitSplineClimbing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerExitSplineClimbing");
		
		ASurvivalPlayerCharacter_ServerExitSplineClimbing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerExitMotionEater
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerExitMotionEater()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerExitMotionEater");
		
		ASurvivalPlayerCharacter_ServerExitMotionEater_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerEnterSpyGlassMode
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ServerEnterSpyGlassMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerEnterSpyGlassMode");
		
		ASurvivalPlayerCharacter_ServerEnterSpyGlassMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerEndHoldInteractFoliage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     InteractableObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FFoliageKey                                 MatchingFoliageKey                                         (Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInteractHoldHandleType                            HoldInteractType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerEndHoldInteractFoliage(class UObject* InteractableObject, const struct FFoliageKey& MatchingFoliageKey, EInteractHoldHandleType HoldInteractType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerEndHoldInteractFoliage");
		
		ASurvivalPlayerCharacter_ServerEndHoldInteractFoliage_Params params {};
		params.InteractableObject = InteractableObject;
		params.MatchingFoliageKey = MatchingFoliageKey;
		params.HoldInteractType = HoldInteractType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerEndHoldInteractBuilding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     InteractableObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBuildingGridBuildingId                     MatchingBuildingKey                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInteractHoldHandleType                            HoldInteractType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerEndHoldInteractBuilding(class UObject* InteractableObject, const struct FBuildingGridBuildingId& MatchingBuildingKey, EInteractHoldHandleType HoldInteractType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerEndHoldInteractBuilding");
		
		ASurvivalPlayerCharacter_ServerEndHoldInteractBuilding_Params params {};
		params.InteractableObject = InteractableObject;
		params.MatchingBuildingKey = MatchingBuildingKey;
		params.HoldInteractType = HoldInteractType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerEndHoldInteractActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     InteractableObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInteractHoldHandleType                            HoldInteractType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerEndHoldInteractActor(class UObject* InteractableObject, EInteractHoldHandleType HoldInteractType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerEndHoldInteractActor");
		
		ASurvivalPlayerCharacter_ServerEndHoldInteractActor_Params params {};
		params.InteractableObject = InteractableObject;
		params.HoldInteractType = HoldInteractType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerBeginHoldInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     InteractableObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerBeginHoldInteract(class UObject* InteractableObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerBeginHoldInteract");
		
		ASurvivalPlayerCharacter_ServerBeginHoldInteract_Params params {};
		params.InteractableObject = InteractableObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ServerAddWaypoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ServerAddWaypoint(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ServerAddWaypoint");
		
		ASurvivalPlayerCharacter_ServerAddWaypoint_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.RequestedRest
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerCharacter::RequestedRest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.RequestedRest");
		
		ASurvivalPlayerCharacter_RequestedRest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.OnWidgetStackChanged
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::OnWidgetStackChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.OnWidgetStackChanged");
		
		ASurvivalPlayerCharacter_OnWidgetStackChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.OnViewControlBlendCompleteEvent
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::OnViewControlBlendCompleteEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.OnViewControlBlendCompleteEvent");
		
		ASurvivalPlayerCharacter_OnViewControlBlendCompleteEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.OnRep_PlayerGuid
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::OnRep_PlayerGuid()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.OnRep_PlayerGuid");
		
		ASurvivalPlayerCharacter_OnRep_PlayerGuid_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.OnRep_PlayerColor
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::OnRep_PlayerColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.OnRep_PlayerColor");
		
		ASurvivalPlayerCharacter_OnRep_PlayerColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.OnRep_PlayerBusyInMenu
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::OnRep_PlayerBusyInMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.OnRep_PlayerBusyInMenu");
		
		ASurvivalPlayerCharacter_OnRep_PlayerBusyInMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.OnRep_Interior
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::OnRep_Interior()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.OnRep_Interior");
		
		ASurvivalPlayerCharacter_OnRep_Interior_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.OnRep_CurrentPetFull
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::OnRep_CurrentPetFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.OnRep_CurrentPetFull");
		
		ASurvivalPlayerCharacter_OnRep_CurrentPetFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.OnGliderMovementModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsGliding                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::OnGliderMovementModeChanged(bool IsGliding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.OnGliderMovementModeChanged");
		
		ASurvivalPlayerCharacter_OnGliderMovementModeChanged_Params params {};
		params.IsGliding = IsGliding;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.OnControllerDisconnected
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::OnControllerDisconnected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.OnControllerDisconnected");
		
		ASurvivalPlayerCharacter_OnControllerDisconnected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.NotifyInteractError
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        WarningText                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::NotifyInteractError(class UObject* Interactable, const class FText& WarningText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.NotifyInteractError");
		
		ASurvivalPlayerCharacter_NotifyInteractError_Params params {};
		params.Interactable = Interactable;
		params.WarningText = WarningText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.MulticastStopWeaponMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::MulticastStopWeaponMontage(class UAnimMontage* AnimMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.MulticastStopWeaponMontage");
		
		ASurvivalPlayerCharacter_MulticastStopWeaponMontage_Params params {};
		params.AnimMontage = AnimMontage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.MulticastSetWeaponMontageNextSection
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SectionToSet                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        NextSection                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               JumpIfNotInSection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::MulticastSetWeaponMontageNextSection(class UAnimMontage* AnimMontage, const class FName& SectionToSet, const class FName& NextSection, bool JumpIfNotInSection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.MulticastSetWeaponMontageNextSection");
		
		ASurvivalPlayerCharacter_MulticastSetWeaponMontageNextSection_Params params {};
		params.AnimMontage = AnimMontage;
		params.SectionToSet = SectionToSet;
		params.NextSection = NextSection;
		params.JumpIfNotInSection = JumpIfNotInSection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.MulticastPlayWeaponMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::MulticastPlayWeaponMontage(class UAnimMontage* AnimMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.MulticastPlayWeaponMontage");
		
		ASurvivalPlayerCharacter_MulticastPlayWeaponMontage_Params params {};
		params.AnimMontage = AnimMontage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.MulticastFixupPoseableClone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APawn*                                       OriginalPawn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::MulticastFixupPoseableClone(class APawn* OriginalPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.MulticastFixupPoseableClone");
		
		ASurvivalPlayerCharacter_MulticastFixupPoseableClone_Params params {};
		params.OriginalPawn = OriginalPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.KillMe
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::KillMe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.KillMe");
		
		ASurvivalPlayerCharacter_KillMe_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.IsThrowing
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerCharacter::IsThrowing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.IsThrowing");
		
		ASurvivalPlayerCharacter_IsThrowing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.IsTargetInteractionEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractionChannel                                Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerCharacter::IsTargetInteractionEnabled(EInteractionChannel Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.IsTargetInteractionEnabled");
		
		ASurvivalPlayerCharacter_IsTargetInteractionEnabled_Params params {};
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.IsRequestedInventory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInventoryComponent*                         Inventory                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerCharacter::IsRequestedInventory(class UInventoryComponent* Inventory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.IsRequestedInventory");
		
		ASurvivalPlayerCharacter_IsRequestedInventory_Params params {};
		params.Inventory = Inventory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.IsInCinematicMode
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerCharacter::IsInCinematicMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.IsInCinematicMode");
		
		ASurvivalPlayerCharacter_IsInCinematicMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.IsChargingThrow
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerCharacter::IsChargingThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.IsChargingThrow");
		
		ASurvivalPlayerCharacter_IsChargingThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.IsChargingAttack
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerCharacter::IsChargingAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.IsChargingAttack");
		
		ASurvivalPlayerCharacter_IsChargingAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.HasWeapon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bCheckVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerCharacter::HasWeapon(bool bCheckVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.HasWeapon");
		
		ASurvivalPlayerCharacter_HasWeapon_Params params {};
		params.bCheckVisible = bCheckVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.HasOffhand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bCheckVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerCharacter::HasOffhand(bool bCheckVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.HasOffhand");
		
		ASurvivalPlayerCharacter_HasOffhand_Params params {};
		params.bCheckVisible = bCheckVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.HasLitFire
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerCharacter::HasLitFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.HasLitFire");
		
		ASurvivalPlayerCharacter_HasLitFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.HandleSizzleStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESizzleState                                       PreviousState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESizzleState                                       CurrentState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::HandleSizzleStateChanged(ESizzleState PreviousState, ESizzleState CurrentState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.HandleSizzleStateChanged");
		
		ASurvivalPlayerCharacter_HandleSizzleStateChanged_Params params {};
		params.PreviousState = PreviousState;
		params.CurrentState = CurrentState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.HandleEquipmentChanged
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::HandleEquipmentChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.HandleEquipmentChanged");
		
		ASurvivalPlayerCharacter_HandleEquipmentChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.HandleCurrentPetLODActorConvertedToProxyActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               LODActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::HandleCurrentPetLODActorConvertedToProxyActor(class UBaseLODActor* LODActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.HandleCurrentPetLODActorConvertedToProxyActor");
		
		ASurvivalPlayerCharacter_HandleCurrentPetLODActorConvertedToProxyActor_Params params {};
		params.LODActor = LODActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.HandleCurrentPetLODActorConvertedToFullActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               LODActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::HandleCurrentPetLODActorConvertedToFullActor(class UBaseLODActor* LODActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.HandleCurrentPetLODActorConvertedToFullActor");
		
		ASurvivalPlayerCharacter_HandleCurrentPetLODActorConvertedToFullActor_Params params {};
		params.LODActor = LODActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.HandleCozinessLevelChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCozinessEvaluatorComponent*                 Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldLevel                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::HandleCozinessLevelChanged(class UCozinessEvaluatorComponent* Sender, int32_t OldLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.HandleCozinessLevelChanged");
		
		ASurvivalPlayerCharacter_HandleCozinessLevelChanged_Params params {};
		params.Sender = Sender;
		params.OldLevel = OldLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetPendingBuilding
	 * 		Flags  -> ()
	 */
	class ABuilding* ASurvivalPlayerCharacter::GetPendingBuilding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetPendingBuilding");
		
		ASurvivalPlayerCharacter_GetPendingBuilding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetIsPlacingBuilding
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerCharacter::GetIsPlacingBuilding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetIsPlacingBuilding");
		
		ASurvivalPlayerCharacter_GetIsPlacingBuilding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetIsInteracting
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerCharacter::GetIsInteracting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetIsInteracting");
		
		ASurvivalPlayerCharacter_GetIsInteracting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetIsCancellingInteract
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerCharacter::GetIsCancellingInteract()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetIsCancellingInteract");
		
		ASurvivalPlayerCharacter_GetIsCancellingInteract_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetInteractTimerMax
	 * 		Flags  -> ()
	 */
	float ASurvivalPlayerCharacter::GetInteractTimerMax()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetInteractTimerMax");
		
		ASurvivalPlayerCharacter_GetInteractTimerMax_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetInteractTimer
	 * 		Flags  -> ()
	 */
	float ASurvivalPlayerCharacter::GetInteractTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetInteractTimer");
		
		ASurvivalPlayerCharacter_GetInteractTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetHeadMesh
	 * 		Flags  -> ()
	 */
	class USkeletalMeshComponent* ASurvivalPlayerCharacter::GetHeadMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetHeadMesh");
		
		ASurvivalPlayerCharacter_GetHeadMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetDropItemTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform ASurvivalPlayerCharacter::GetDropItemTransform(class UItem* Item, const struct FVector& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetDropItemTransform");
		
		ASurvivalPlayerCharacter_GetDropItemTransform_Params params {};
		params.Item = Item;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetDropItemDirection
	 * 		Flags  -> ()
	 */
	struct FVector ASurvivalPlayerCharacter::GetDropItemDirection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetDropItemDirection");
		
		ASurvivalPlayerCharacter_GetDropItemDirection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetCurrentPetFull
	 * 		Flags  -> ()
	 */
	class ASurvivalCreature* ASurvivalPlayerCharacter::GetCurrentPetFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetCurrentPetFull");
		
		ASurvivalPlayerCharacter_GetCurrentPetFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetCurrentPet
	 * 		Flags  -> ()
	 */
	class UCreatureLODActor* ASurvivalPlayerCharacter::GetCurrentPet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetCurrentPet");
		
		ASurvivalPlayerCharacter_GetCurrentPet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetCharacterIdentity
	 * 		Flags  -> ()
	 */
	EPlayerCharacterIdentity ASurvivalPlayerCharacter::GetCharacterIdentity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetCharacterIdentity");
		
		ASurvivalPlayerCharacter_GetCharacterIdentity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetCancelInteractTimerMax
	 * 		Flags  -> ()
	 */
	float ASurvivalPlayerCharacter::GetCancelInteractTimerMax()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetCancelInteractTimerMax");
		
		ASurvivalPlayerCharacter_GetCancelInteractTimerMax_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetCancelInteractTimer
	 * 		Flags  -> ()
	 */
	float ASurvivalPlayerCharacter::GetCancelInteractTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetCancelInteractTimer");
		
		ASurvivalPlayerCharacter_GetCancelInteractTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.GetAimPitch
	 * 		Flags  -> ()
	 */
	float ASurvivalPlayerCharacter::GetAimPitch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.GetAimPitch");
		
		ASurvivalPlayerCharacter_GetAimPitch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ExitSpyGlassMode
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ExitSpyGlassMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ExitSpyGlassMode");
		
		ASurvivalPlayerCharacter_ExitSpyGlassMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ExitPlaceBuildingMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ExitPlaceBuildingMode(bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ExitPlaceBuildingMode");
		
		ASurvivalPlayerCharacter_ExitPlaceBuildingMode_Params params {};
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.EnterSpyGlassMode
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::EnterSpyGlassMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.EnterSpyGlassMode");
		
		ASurvivalPlayerCharacter_EnterSpyGlassMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.EnterPlaceBuildingMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         BuildingData                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bAutoAddIngredients                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDeployable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::EnterPlaceBuildingMode(const struct FDataTableRowHandle& BuildingData, bool bAutoAddIngredients, bool bDeployable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.EnterPlaceBuildingMode");
		
		ASurvivalPlayerCharacter_EnterPlaceBuildingMode_Params params {};
		params.BuildingData = BuildingData;
		params.bAutoAddIngredients = bAutoAddIngredients;
		params.bDeployable = bDeployable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.DamagedServerOnlyCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsKillingBlow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::DamagedServerOnlyCallback(float Damage, const struct FDamageInfo& DamageInfo, class AController* InstigatedBy, class UBaseLODActor* DamageCauser, bool IsKillingBlow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.DamagedServerOnlyCallback");
		
		ASurvivalPlayerCharacter_DamagedServerOnlyCallback_Params params {};
		params.Damage = Damage;
		params.DamageInfo = DamageInfo;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		params.IsKillingBlow = IsKillingBlow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ClientSetEnemy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Enemy                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ClientSetEnemy(class ASurvivalCharacter* Enemy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ClientSetEnemy");
		
		ASurvivalPlayerCharacter_ClientSetEnemy_Params params {};
		params.Enemy = Enemy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ClientNotifyStorageFull
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ClientNotifyStorageFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ClientNotifyStorageFull");
		
		ASurvivalPlayerCharacter_ClientNotifyStorageFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ClientNotifyInventoryFull
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ClientNotifyInventoryFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ClientNotifyInventoryFull");
		
		ASurvivalPlayerCharacter_ClientNotifyInventoryFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ClientNotifyHaulingFull
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ClientNotifyHaulingFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ClientNotifyHaulingFull");
		
		ASurvivalPlayerCharacter_ClientNotifyHaulingFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ClientNotifyDropStorageFull
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ClientNotifyDropStorageFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ClientNotifyDropStorageFull");
		
		ASurvivalPlayerCharacter_ClientNotifyDropStorageFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ClientExitSpyGlassMode
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ClientExitSpyGlassMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ClientExitSpyGlassMode");
		
		ASurvivalPlayerCharacter_ClientExitSpyGlassMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ClientEnterSpyGlassMode
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerCharacter::ClientEnterSpyGlassMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ClientEnterSpyGlassMode");
		
		ASurvivalPlayerCharacter_ClientEnterSpyGlassMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ClientEndHoldInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInteractHoldHandleType                            HoldInteractType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ClientEndHoldInteraction(EInteractHoldHandleType HoldInteractType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ClientEndHoldInteraction");
		
		ASurvivalPlayerCharacter_ClientEndHoldInteraction_Params params {};
		params.HoldInteractType = HoldInteractType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.ClientBeginHoldInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     InteractableObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::ClientBeginHoldInteract(class UObject* InteractableObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.ClientBeginHoldInteract");
		
		ASurvivalPlayerCharacter_ClientBeginHoldInteract_Params params {};
		params.InteractableObject = InteractableObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.CanThrowItem
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerCharacter::CanThrowItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.CanThrowItem");
		
		ASurvivalPlayerCharacter_CanThrowItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.CanLightFire
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerCharacter::CanLightFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.CanLightFire");
		
		ASurvivalPlayerCharacter_CanLightFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.CanInteractWith
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInteractionChannel                                InteractionChannel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerCharacter::CanInteractWith(class UObject* Interactable, EInteractionChannel InteractionChannel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.CanInteractWith");
		
		ASurvivalPlayerCharacter_CanInteractWith_Params params {};
		params.Interactable = Interactable;
		params.InteractionChannel = InteractionChannel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.CanInteract
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerCharacter::CanInteract()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.CanInteract");
		
		ASurvivalPlayerCharacter_CanInteract_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.CanDropItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerCharacter::CanDropItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.CanDropItem");
		
		ASurvivalPlayerCharacter_CanDropItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.AdjustCameraForInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     InteractableActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsEnteringInteraction                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::AdjustCameraForInteraction(class UObject* InteractableActor, bool IsEnteringInteraction, float BlendTime, float BlendExp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.AdjustCameraForInteraction");
		
		ASurvivalPlayerCharacter_AdjustCameraForInteraction_Params params {};
		params.InteractableActor = InteractableActor;
		params.IsEnteringInteraction = IsEnteringInteraction;
		params.BlendTime = BlendTime;
		params.BlendExp = BlendExp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerCharacter.AchievementDebug
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShow                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerCharacter::AchievementDebug(bool bShow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerCharacter.AchievementDebug");
		
		ASurvivalPlayerCharacter_AchievementDebug_Params params {};
		params.bShow = bShow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASurvivalPlayerCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASurvivalPlayerCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalPlayerCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.TryUseItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     From                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerController::TryUseItem(class UObject* From, class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.TryUseItem");
		
		ASurvivalPlayerController_TryUseItem_Params params {};
		params.From = From;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ToggleSpectatorMode
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::ToggleSpectatorMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ToggleSpectatorMode");
		
		ASurvivalPlayerController_ToggleSpectatorMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.TogglePhotoPawnType
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::TogglePhotoPawnType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.TogglePhotoPawnType");
		
		ASurvivalPlayerController_TogglePhotoPawnType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.TogglePhotoModeUI
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::TogglePhotoModeUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.TogglePhotoModeUI");
		
		ASurvivalPlayerController_TogglePhotoModeUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.TogglePhotoModeSettings
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::TogglePhotoModeSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.TogglePhotoModeSettings");
		
		ASurvivalPlayerController_TogglePhotoModeSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ShowPhotoModeUI
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::ShowPhotoModeUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ShowPhotoModeUI");
		
		ASurvivalPlayerController_ShowPhotoModeUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetYAxisInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsInverted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetYAxisInverted(bool bIsInverted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetYAxisInverted");
		
		ASurvivalPlayerController_SetYAxisInverted_Params params {};
		params.bIsInverted = bIsInverted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetXAxisInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsInverted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetXAxisInverted(bool bIsInverted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetXAxisInverted");
		
		ASurvivalPlayerController_SetXAxisInverted_Params params {};
		params.bIsInverted = bIsInverted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetupPhotoPawnInputs
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APhotoPawn*                                  PhotoPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInputComponent*                             PhotoPawnInputComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetupPhotoPawnInputs(class APhotoPawn* PhotoPawn, class UInputComponent* PhotoPawnInputComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetupPhotoPawnInputs");
		
		ASurvivalPlayerController_SetupPhotoPawnInputs_Params params {};
		params.PhotoPawn = PhotoPawn;
		params.PhotoPawnInputComponent = PhotoPawnInputComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetRumbleEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsEnabled                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetRumbleEnabled(bool bIsEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetRumbleEnabled");
		
		ASurvivalPlayerController_SetRumbleEnabled_Params params {};
		params.bIsEnabled = bIsEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetRightStickOuterDeadZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetRightStickOuterDeadZone(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetRightStickOuterDeadZone");
		
		ASurvivalPlayerController_SetRightStickOuterDeadZone_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetRightStickInnerDeadZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetRightStickInnerDeadZone(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetRightStickInnerDeadZone");
		
		ASurvivalPlayerController_SetRightStickInnerDeadZone_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetMouseSensitivityY
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetMouseSensitivityY(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetMouseSensitivityY");
		
		ASurvivalPlayerController_SetMouseSensitivityY_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetMouseSensitivityX
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetMouseSensitivityX(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetMouseSensitivityX");
		
		ASurvivalPlayerController_SetMouseSensitivityX_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetMouseSensitivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector2D                                   Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetMouseSensitivity(const struct FVector2D& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetMouseSensitivity");
		
		ASurvivalPlayerController_SetMouseSensitivity_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetLeftStickOuterDeadZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetLeftStickOuterDeadZone(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetLeftStickOuterDeadZone");
		
		ASurvivalPlayerController_SetLeftStickOuterDeadZone_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetLeftStickInnerDeadZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetLeftStickInnerDeadZone(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetLeftStickInnerDeadZone");
		
		ASurvivalPlayerController_SetLeftStickInnerDeadZone_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetGamepadSensitivityY
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetGamepadSensitivityY(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetGamepadSensitivityY");
		
		ASurvivalPlayerController_SetGamepadSensitivityY_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetGamepadSensitivityX
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetGamepadSensitivityX(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetGamepadSensitivityX");
		
		ASurvivalPlayerController_SetGamepadSensitivityX_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetGamepadSensitivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector2D                                   Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetGamepadSensitivity(const struct FVector2D& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetGamepadSensitivity");
		
		ASurvivalPlayerController_SetGamepadSensitivity_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetFOV
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InFOV                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetFOV(float InFOV)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetFOV");
		
		ASurvivalPlayerController_SetFOV_Params params {};
		params.InFOV = InFOV;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetControllerMoveYInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsInverted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetControllerMoveYInverted(bool bIsInverted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetControllerMoveYInverted");
		
		ASurvivalPlayerController_SetControllerMoveYInverted_Params params {};
		params.bIsInverted = bIsInverted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetControllerMoveXInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsInverted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetControllerMoveXInverted(bool bIsInverted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetControllerMoveXInverted");
		
		ASurvivalPlayerController_SetControllerMoveXInverted_Params params {};
		params.bIsInverted = bIsInverted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetControllerLookYInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsInverted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetControllerLookYInverted(bool bIsInverted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetControllerLookYInverted");
		
		ASurvivalPlayerController_SetControllerLookYInverted_Params params {};
		params.bIsInverted = bIsInverted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.SetControllerLookXInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsInverted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::SetControllerLookXInverted(bool bIsInverted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.SetControllerLookXInverted");
		
		ASurvivalPlayerController_SetControllerLookXInverted_Params params {};
		params.bIsInverted = bIsInverted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerUseItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     From                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerUseItem(class UObject* From, class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerUseItem");
		
		ASurvivalPlayerController_ServerUseItem_Params params {};
		params.From = From;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerUnequipDisplayBuilding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AEquipmentDisplayBuilding*                   Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerUnequipDisplayBuilding(class AEquipmentDisplayBuilding* Building, class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerUnequipDisplayBuilding");
		
		ASurvivalPlayerController_ServerUnequipDisplayBuilding_Params params {};
		params.Building = Building;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerUnequipCreature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCreature*                           Creature                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerUnequipCreature(class ASurvivalCreature* Creature, class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerUnequipCreature");
		
		ASurvivalPlayerController_ServerUnequipCreature_Params params {};
		params.Creature = Creature;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerTryGetProductionItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AProductionBuilding*                         Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerTryGetProductionItem(class AProductionBuilding* Building, class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerTryGetProductionItem");
		
		ASurvivalPlayerController_ServerTryGetProductionItem_Params params {};
		params.Building = Building;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerSwapDisplayBuilding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AEquipmentDisplayBuilding*                   Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerSwapDisplayBuilding(class AEquipmentDisplayBuilding* Building)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerSwapDisplayBuilding");
		
		ASurvivalPlayerController_ServerSwapDisplayBuilding_Params params {};
		params.Building = Building;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerSetPheromoneBroadcasterGatherEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APheromoneBroadcasterBuilding*               Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerSetPheromoneBroadcasterGatherEnabled(class APheromoneBroadcasterBuilding* Building, bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerSetPheromoneBroadcasterGatherEnabled");
		
		ASurvivalPlayerController_ServerSetPheromoneBroadcasterGatherEnabled_Params params {};
		params.Building = Building;
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerSetPheromoneBroadcasterBuildEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APheromoneBroadcasterBuilding*               Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerSetPheromoneBroadcasterBuildEnabled(class APheromoneBroadcasterBuilding* Building, bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerSetPheromoneBroadcasterBuildEnabled");
		
		ASurvivalPlayerController_ServerSetPheromoneBroadcasterBuildEnabled_Params params {};
		params.Building = Building;
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerSelectSign
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASignBuilding*                               SignBuilding                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         SignDataHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerSelectSign(class ASignBuilding* SignBuilding, const struct FDataTableRowHandle& SignDataHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerSelectSign");
		
		ASurvivalPlayerController_ServerSelectSign_Params params {};
		params.SignBuilding = SignBuilding;
		params.SignDataHandle = SignDataHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerSelectPlayerDrivenConversationResponse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ResponseIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerSelectPlayerDrivenConversationResponse(int32_t ResponseIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerSelectPlayerDrivenConversationResponse");
		
		ASurvivalPlayerController_ServerSelectPlayerDrivenConversationResponse_Params params {};
		params.ResponseIndex = ResponseIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerRespawn
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::ServerRespawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerRespawn");
		
		ASurvivalPlayerController_ServerRespawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerRequestUnlockItemStackUpgradeTier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                ItemStackTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerRequestUnlockItemStackUpgradeTier(const struct FGameplayTag& ItemStackTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerRequestUnlockItemStackUpgradeTier");
		
		ASurvivalPlayerController_ServerRequestUnlockItemStackUpgradeTier_Params params {};
		params.ItemStackTag = ItemStackTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerRequestTechTreeRecipePointSpend
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TechTreeRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            PointsToSpend                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerRequestTechTreeRecipePointSpend(const struct FDataTableRowHandle& TechTreeRowHandle, int32_t PointsToSpend)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerRequestTechTreeRecipePointSpend");
		
		ASurvivalPlayerController_ServerRequestTechTreeRecipePointSpend_Params params {};
		params.TechTreeRowHandle = TechTreeRowHandle;
		params.PointsToSpend = PointsToSpend;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerRequestSetPlayerIdentity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerCharacterIdentity                           PlayerIdentity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerRequestSetPlayerIdentity(EPlayerCharacterIdentity PlayerIdentity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerRequestSetPlayerIdentity");
		
		ASurvivalPlayerController_ServerRequestSetPlayerIdentity_Params params {};
		params.PlayerIdentity = PlayerIdentity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerRemoveItemFromGarden
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AGardenBuilding*                             Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerRemoveItemFromGarden(class AGardenBuilding* Building, class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerRemoveItemFromGarden");
		
		ASurvivalPlayerController_ServerRemoveItemFromGarden_Params params {};
		params.Building = Building;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerRemoveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     From                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerRemoveItem(class UObject* From, class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerRemoveItem");
		
		ASurvivalPlayerController_ServerRemoveItem_Params params {};
		params.From = From;
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerRejectBurgleQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        QuestInstance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerRejectBurgleQuest(class UBurgleQuestInstance* QuestInstance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerRejectBurgleQuest");
		
		ASurvivalPlayerController_ServerRejectBurgleQuest_Params params {};
		params.QuestInstance = QuestInstance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerRefillBurgleQuests
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::ServerRefillBurgleQuests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerRefillBurgleQuests");
		
		ASurvivalPlayerController_ServerRefillBurgleQuests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerProgressPlayerDrivenConversation
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::ServerProgressPlayerDrivenConversation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerProgressPlayerDrivenConversation");
		
		ASurvivalPlayerController_ServerProgressPlayerDrivenConversation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerEquipDisplayBuilding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AEquipmentDisplayBuilding*                   Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerEquipDisplayBuilding(class AEquipmentDisplayBuilding* Building, class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerEquipDisplayBuilding");
		
		ASurvivalPlayerController_ServerEquipDisplayBuilding_Params params {};
		params.Building = Building;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerEquipCreature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCreature*                           Creature                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerEquipCreature(class ASurvivalCreature* Creature, class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerEquipCreature");
		
		ASurvivalPlayerController_ServerEquipCreature_Params params {};
		params.Creature = Creature;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerEnhanceItemBonus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                BonusEnhancementType                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerEnhanceItemBonus(class UItem* Item, const struct FGameplayTag& BonusEnhancementType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerEnhanceItemBonus");
		
		ASurvivalPlayerController_ServerEnhanceItemBonus_Params params {};
		params.Item = Item;
		params.BonusEnhancementType = BonusEnhancementType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerEnhanceItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerEnhanceItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerEnhanceItem");
		
		ASurvivalPlayerController_ServerEnhanceItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerEndPlayerDrivenConversation
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::ServerEndPlayerDrivenConversation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerEndPlayerDrivenConversation");
		
		ASurvivalPlayerController_ServerEndPlayerDrivenConversation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerDumpItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerDumpItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerDumpItem");
		
		ASurvivalPlayerController_ServerDumpItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerDropItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     From                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerDropItem(class UObject* From, class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerDropItem");
		
		ASurvivalPlayerController_ServerDropItem_Params params {};
		params.From = From;
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerDepositToPheromoneBroadcaster
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APheromoneBroadcasterBuilding*               Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerDepositToPheromoneBroadcaster(class APheromoneBroadcasterBuilding* Building, class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerDepositToPheromoneBroadcaster");
		
		ASurvivalPlayerController_ServerDepositToPheromoneBroadcaster_Params params {};
		params.Building = Building;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerCraftRecipeDataAtBuilding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AProductionBuilding*                         Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         RecipeModRowHandle                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerCraftRecipeDataAtBuilding(class AProductionBuilding* Building, const struct FDataTableRowHandle& RecipeRowHandle, const struct FDataTableRowHandle& RecipeModRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerCraftRecipeDataAtBuilding");
		
		ASurvivalPlayerController_ServerCraftRecipeDataAtBuilding_Params params {};
		params.Building = Building;
		params.RecipeRowHandle = RecipeRowHandle;
		params.RecipeModRowHandle = RecipeModRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerCraftRecipeAtBuilding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AProductionBuilding*                         Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         RecipeModRowHandle                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerCraftRecipeAtBuilding(class AProductionBuilding* Building, const struct FDataTableRowHandle& RecipeModRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerCraftRecipeAtBuilding");
		
		ASurvivalPlayerController_ServerCraftRecipeAtBuilding_Params params {};
		params.Building = Building;
		params.RecipeModRowHandle = RecipeModRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerCommitGardenItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AGardenBuilding*                             Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerCommitGardenItems(class AGardenBuilding* Building)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerCommitGardenItems");
		
		ASurvivalPlayerController_ServerCommitGardenItems_Params params {};
		params.Building = Building;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerCloseInteractionWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerCloseInteractionWidget(class AActor* Interactable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerCloseInteractionWidget");
		
		ASurvivalPlayerController_ServerCloseInteractionWidget_Params params {};
		params.Interactable = Interactable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerCancelProductionItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AProductionBuilding*                         Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerCancelProductionItem(class AProductionBuilding* Building, class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerCancelProductionItem");
		
		ASurvivalPlayerController_ServerCancelProductionItem_Params params {};
		params.Building = Building;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerCancelGardenProduction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AGardenBuilding*                             Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerCancelGardenProduction(class AGardenBuilding* Building)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerCancelGardenProduction");
		
		ASurvivalPlayerController_ServerCancelGardenProduction_Params params {};
		params.Building = Building;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerAddItemToGarden
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AGardenBuilding*                             Building                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerAddItemToGarden(class AGardenBuilding* Building, class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerAddItemToGarden");
		
		ASurvivalPlayerController_ServerAddItemToGarden_Params params {};
		params.Building = Building;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerAcceptBurgleQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        QuestInstance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerAcceptBurgleQuest(class UBurgleQuestInstance* QuestInstance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerAcceptBurgleQuest");
		
		ASurvivalPlayerController_ServerAcceptBurgleQuest_Params params {};
		params.QuestInstance = QuestInstance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ServerAbandonBurgleQuest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBurgleQuestInstance*                        QuestInstance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ServerAbandonBurgleQuest(class UBurgleQuestInstance* QuestInstance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ServerAbandonBurgleQuest");
		
		ASurvivalPlayerController_ServerAbandonBurgleQuest_Params params {};
		params.QuestInstance = QuestInstance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.RestoreDefaultPhotoSettings
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::RestoreDefaultPhotoSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.RestoreDefaultPhotoSettings");
		
		ASurvivalPlayerController_RestoreDefaultPhotoSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.RespawnCharacter
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::RespawnCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.RespawnCharacter");
		
		ASurvivalPlayerController_RespawnCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.RequestTechTreeRecipePointSpend
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TechTreeRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            PointsToSpend                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::RequestTechTreeRecipePointSpend(const struct FDataTableRowHandle& TechTreeRowHandle, int32_t PointsToSpend)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.RequestTechTreeRecipePointSpend");
		
		ASurvivalPlayerController_RequestTechTreeRecipePointSpend_Params params {};
		params.TechTreeRowHandle = TechTreeRowHandle;
		params.PointsToSpend = PointsToSpend;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.PhotoCamSpeedAdjust
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::PhotoCamSpeedAdjust(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.PhotoCamSpeedAdjust");
		
		ASurvivalPlayerController_PhotoCamSpeedAdjust_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.PhotoCamFlightSpeedUp
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::PhotoCamFlightSpeedUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.PhotoCamFlightSpeedUp");
		
		ASurvivalPlayerController_PhotoCamFlightSpeedUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.PhotoCamFlightSpeedDown
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::PhotoCamFlightSpeedDown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.PhotoCamFlightSpeedDown");
		
		ASurvivalPlayerController_PhotoCamFlightSpeedDown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.OnVoiceChatActivationSettingChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            IntSetting                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::OnVoiceChatActivationSettingChanged(int32_t IntSetting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.OnVoiceChatActivationSettingChanged");
		
		ASurvivalPlayerController_OnVoiceChatActivationSettingChanged_Params params {};
		params.IntSetting = IntSetting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.OnPhotoModeEntryUnallowed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPhotoModeEntryAllowedResult                       PhotoModeEntryAllowedResult                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::OnPhotoModeEntryUnallowed(EPhotoModeEntryAllowedResult PhotoModeEntryAllowedResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.OnPhotoModeEntryUnallowed");
		
		ASurvivalPlayerController_OnPhotoModeEntryUnallowed_Params params {};
		params.PhotoModeEntryAllowedResult = PhotoModeEntryAllowedResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.OnPhotoModeEntered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APhotoPawn*                                  PhotoPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::OnPhotoModeEntered(class APhotoPawn* PhotoPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.OnPhotoModeEntered");
		
		ASurvivalPlayerController_OnPhotoModeEntered_Params params {};
		params.PhotoPawn = PhotoPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.OnKeyBindsReset
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::OnKeyBindsReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.OnKeyBindsReset");
		
		ASurvivalPlayerController_OnKeyBindsReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.OnExitPhotoMode
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::OnExitPhotoMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.OnExitPhotoMode");
		
		ASurvivalPlayerController_OnExitPhotoMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.OnAxisMappingRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputAxisKeyMapping                        Value                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::OnAxisMappingRemoved(const struct FInputAxisKeyMapping& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.OnAxisMappingRemoved");
		
		ASurvivalPlayerController_OnAxisMappingRemoved_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.OnAxisMappingAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputAxisKeyMapping                        Value                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::OnAxisMappingAdded(const struct FInputAxisKeyMapping& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.OnAxisMappingAdded");
		
		ASurvivalPlayerController_OnAxisMappingAdded_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.OnActionMappingRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputActionKeyMapping                      Value                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::OnActionMappingRemoved(const struct FInputActionKeyMapping& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.OnActionMappingRemoved");
		
		ASurvivalPlayerController_OnActionMappingRemoved_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.OnActionMappingAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputActionKeyMapping                      Value                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::OnActionMappingAdded(const struct FInputActionKeyMapping& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.OnActionMappingAdded");
		
		ASurvivalPlayerController_OnActionMappingAdded_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.NotifyWasKicked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Reason                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::NotifyWasKicked(const class FText& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.NotifyWasKicked");
		
		ASurvivalPlayerController_NotifyWasKicked_Params params {};
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.NotifyInteractError
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        WarningText                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::NotifyInteractError(class UObject* Interactable, const class FText& WarningText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.NotifyInteractError");
		
		ASurvivalPlayerController_NotifyInteractError_Params params {};
		params.Interactable = Interactable;
		params.WarningText = WarningText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.IsMounted
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerController::IsMounted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.IsMounted");
		
		ASurvivalPlayerController_IsMounted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.IsItemUseOnCooldown
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerController::IsItemUseOnCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.IsItemUseOnCooldown");
		
		ASurvivalPlayerController_IsItemUseOnCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.IsInteractInputAvailable
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerController::IsInteractInputAvailable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.IsInteractInputAvailable");
		
		ASurvivalPlayerController_IsInteractInputAvailable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.HidePhotoModeUI
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::HidePhotoModeUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.HidePhotoModeUI");
		
		ASurvivalPlayerController_HidePhotoModeUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.HandlePhotoModeUnallowedInMP
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::HandlePhotoModeUnallowedInMP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.HandlePhotoModeUnallowedInMP");
		
		ASurvivalPlayerController_HandlePhotoModeUnallowedInMP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.GetSurvivalPlayerState
	 * 		Flags  -> ()
	 */
	class ASurvivalPlayerState* ASurvivalPlayerController::GetSurvivalPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.GetSurvivalPlayerState");
		
		ASurvivalPlayerController_GetSurvivalPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.GetRumbleEnabled
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerController::GetRumbleEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.GetRumbleEnabled");
		
		ASurvivalPlayerController_GetRumbleEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.GetPreviousPawn
	 * 		Flags  -> ()
	 */
	class APawn* ASurvivalPlayerController::GetPreviousPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.GetPreviousPawn");
		
		ASurvivalPlayerController_GetPreviousPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.GetMouseSensitivity
	 * 		Flags  -> ()
	 */
	struct FVector2D ASurvivalPlayerController::GetMouseSensitivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.GetMouseSensitivity");
		
		ASurvivalPlayerController_GetMouseSensitivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.GetItemUseCoooldownRemaining
	 * 		Flags  -> ()
	 */
	float ASurvivalPlayerController::GetItemUseCoooldownRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.GetItemUseCoooldownRemaining");
		
		ASurvivalPlayerController_GetItemUseCoooldownRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.GetGamepadSensitivity
	 * 		Flags  -> ()
	 */
	struct FVector2D ASurvivalPlayerController::GetGamepadSensitivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.GetGamepadSensitivity");
		
		ASurvivalPlayerController_GetGamepadSensitivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.EndForceLookAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::EndForceLookAt(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.EndForceLookAt");
		
		ASurvivalPlayerController_EndForceLookAt_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.DestroyPhotoModeUI
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::DestroyPhotoModeUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.DestroyPhotoModeUI");
		
		ASurvivalPlayerController_DestroyPhotoModeUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.CloseInteractionWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::CloseInteractionWidget(class AActor* Interactable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.CloseInteractionWidget");
		
		ASurvivalPlayerController_CloseInteractionWidget_Params params {};
		params.Interactable = Interactable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ClientOnRespawn
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerController::ClientOnRespawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ClientOnRespawn");
		
		ASurvivalPlayerController_ClientOnRespawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ClientNotifyInteractError
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        WarningText                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ClientNotifyInteractError(class UObject* Interactable, const class FText& WarningText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ClientNotifyInteractError");
		
		ASurvivalPlayerController_ClientNotifyInteractError_Params params {};
		params.Interactable = Interactable;
		params.WarningText = WarningText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ClientNotifyAttackError
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECannotDamageReason                                CannotDamageReason                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           FailedDamageTypeFlags                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ClientNotifyAttackError(class AActor* Target, ECannotDamageReason CannotDamageReason, uint32_t FailedDamageTypeFlags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ClientNotifyAttackError");
		
		ASurvivalPlayerController_ClientNotifyAttackError_Params params {};
		params.Target = Target;
		params.CannotDamageReason = CannotDamageReason;
		params.FailedDamageTypeFlags = FailedDamageTypeFlags;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.ClientCreateInteractionWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::ClientCreateInteractionWidget(class AActor* Interactable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.ClientCreateInteractionWidget");
		
		ASurvivalPlayerController_ClientCreateInteractionWidget_Params params {};
		params.Interactable = Interactable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.BeginForceLookAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::BeginForceLookAt(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.BeginForceLookAt");
		
		ASurvivalPlayerController_BeginForceLookAt_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.AllowIdentitySelection
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerController::AllowIdentitySelection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.AllowIdentitySelection");
		
		ASurvivalPlayerController_AllowIdentitySelection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerController.AdjustPhotoCamFlightSpeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Multiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerController::AdjustPhotoCamFlightSpeed(float Multiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerController.AdjustPhotoCamFlightSpeed");
		
		ASurvivalPlayerController_AdjustPhotoCamFlightSpeed_Params params {};
		params.Multiplier = Multiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASurvivalPlayerController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASurvivalPlayerController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalPlayerController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ViewTutorial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TutorialRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ViewTutorial(const struct FDataTableRowHandle& TutorialRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ViewTutorial");
		
		ASurvivalPlayerState_ViewTutorial_Params params {};
		params.TutorialRowHandle = TutorialRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ToggleResourceSurveyVisible
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerState::ToggleResourceSurveyVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ToggleResourceSurveyVisible");
		
		ASurvivalPlayerState_ToggleResourceSurveyVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.SetTutorialComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TutorialRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::SetTutorialComplete(const struct FDataTableRowHandle& TutorialRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.SetTutorialComplete");
		
		ASurvivalPlayerState_SetTutorialComplete_Params params {};
		params.TutorialRowHandle = TutorialRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.SetResourceSurveyVisible
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::SetResourceSurveyVisible(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.SetResourceSurveyVisible");
		
		ASurvivalPlayerState_SetResourceSurveyVisible_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.SetPlayerTextMute
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerState*                                Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::SetPlayerTextMute(class APlayerState* Target, bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.SetPlayerTextMute");
		
		ASurvivalPlayerState_SetPlayerTextMute_Params params {};
		params.Target = Target;
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.SetPlayerColorSelection
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Selection                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::SetPlayerColorSelection(int32_t Selection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.SetPlayerColorSelection");
		
		ASurvivalPlayerState_SetPlayerColorSelection_Params params {};
		params.Selection = Selection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.SetItemInspected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::SetItemInspected(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.SetItemInspected");
		
		ASurvivalPlayerState_SetItemInspected_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.SetCraftingRecipeInspected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         CraftingRecipeRowHandle                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::SetCraftingRecipeInspected(const struct FDataTableRowHandle& CraftingRecipeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.SetCraftingRecipeInspected");
		
		ASurvivalPlayerState_SetCraftingRecipeInspected_Params params {};
		params.CraftingRecipeRowHandle = CraftingRecipeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.SetBuildingRecipeInspected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         BuildingRecipeRowHandle                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::SetBuildingRecipeInspected(const struct FDataTableRowHandle& BuildingRecipeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.SetBuildingRecipeInspected");
		
		ASurvivalPlayerState_SetBuildingRecipeInspected_Params params {};
		params.BuildingRecipeRowHandle = BuildingRecipeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerViewTutorial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TutorialRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerViewTutorial(const struct FDataTableRowHandle& TutorialRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerViewTutorial");
		
		ASurvivalPlayerState_ServerViewTutorial_Params params {};
		params.TutorialRowHandle = TutorialRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerUseTechTreeKeyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerUseTechTreeKeyItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerUseTechTreeKeyItem");
		
		ASurvivalPlayerState_ServerUseTechTreeKeyItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerUpdateRelevanceConsensus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalCharacter*                          Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ASurvivalPlayerState*                        Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERelevanceType                                     ClientRelevance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerUpdateRelevanceConsensus(class ASurvivalCharacter* Character, class ASurvivalPlayerState* Player, ERelevanceType ClientRelevance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerUpdateRelevanceConsensus");
		
		ASurvivalPlayerState_ServerUpdateRelevanceConsensus_Params params {};
		params.Character = Character;
		params.Player = Player;
		params.ClientRelevance = ClientRelevance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerUnassignQuickSlotItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerUnassignQuickSlotItem(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerUnassignQuickSlotItem");
		
		ASurvivalPlayerState_ServerUnassignQuickSlotItem_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerToggleHUDMarker
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       HUDMarkerObject                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsVisible                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerToggleHUDMarker(const struct FGuid& HUDMarkerObject, bool IsVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerToggleHUDMarker");
		
		ASurvivalPlayerState_ServerToggleHUDMarker_Params params {};
		params.HUDMarkerObject = HUDMarkerObject;
		params.IsVisible = IsVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerSetTutorialComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TutorialRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerSetTutorialComplete(const struct FDataTableRowHandle& TutorialRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerSetTutorialComplete");
		
		ASurvivalPlayerState_ServerSetTutorialComplete_Params params {};
		params.TutorialRowHandle = TutorialRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerSetSurveyedResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         Resource                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerSetSurveyedResource(const struct FDataTableRowHandle& Resource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerSetSurveyedResource");
		
		ASurvivalPlayerState_ServerSetSurveyedResource_Params params {};
		params.Resource = Resource;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerSetResourceSurveyVisible
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsVisible                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerSetResourceSurveyVisible(bool bIsVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerSetResourceSurveyVisible");
		
		ASurvivalPlayerState_ServerSetResourceSurveyVisible_Params params {};
		params.bIsVisible = bIsVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerSetQuickSlotAssignment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EHotBarQuickSlotType                               SlotType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHotBarQuickSlotItemTypeKey                 ItemKey                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerSetQuickSlotAssignment(int32_t Index, EHotBarQuickSlotType SlotType, const struct FHotBarQuickSlotItemTypeKey& ItemKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerSetQuickSlotAssignment");
		
		ASurvivalPlayerState_ServerSetQuickSlotAssignment_Params params {};
		params.Index = Index;
		params.SlotType = SlotType;
		params.ItemKey = ItemKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerSetQuestStickiedState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               IsStickied                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerSetQuestStickiedState(const struct FDataTableRowHandle& QuestRowHandle, bool IsStickied)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerSetQuestStickiedState");
		
		ASurvivalPlayerState_ServerSetQuestStickiedState_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		params.IsStickied = IsStickied;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerSetItemInspected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerSetItemInspected(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerSetItemInspected");
		
		ASurvivalPlayerState_ServerSetItemInspected_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerSetDesiredCameraMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECameraDisplayMode                                 CameraMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerSetDesiredCameraMode(ECameraDisplayMode CameraMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerSetDesiredCameraMode");
		
		ASurvivalPlayerState_ServerSetDesiredCameraMode_Params params {};
		params.CameraMode = CameraMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerSetCraftingRecipeInspected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         CraftingRecipeRowHandle                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerSetCraftingRecipeInspected(const struct FDataTableRowHandle& CraftingRecipeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerSetCraftingRecipeInspected");
		
		ASurvivalPlayerState_ServerSetCraftingRecipeInspected_Params params {};
		params.CraftingRecipeRowHandle = CraftingRecipeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerSetBurgleQuestsStickied
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsStickied                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerSetBurgleQuestsStickied(bool IsStickied)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerSetBurgleQuestsStickied");
		
		ASurvivalPlayerState_ServerSetBurgleQuestsStickied_Params params {};
		params.IsStickied = IsStickied;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerSetBuildingRecipeInspected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         BuildingRecipeRowHandle                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerSetBuildingRecipeInspected(const struct FDataTableRowHandle& BuildingRecipeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerSetBuildingRecipeInspected");
		
		ASurvivalPlayerState_ServerSetBuildingRecipeInspected_Params params {};
		params.BuildingRecipeRowHandle = BuildingRecipeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerSendChatMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerSendChatMessage(const class FString& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerSendChatMessage");
		
		ASurvivalPlayerState_ServerSendChatMessage_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerRequestResearch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AResourceAnalyzer*                           ResourceAnalyzer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerRequestResearch(const struct FDataTableRowHandle& ItemRowHandle, class AResourceAnalyzer* ResourceAnalyzer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerRequestResearch");
		
		ASurvivalPlayerState_ServerRequestResearch_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.ResourceAnalyzer = ResourceAnalyzer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerRemoveQuestStickiedState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerRemoveQuestStickiedState(const struct FDataTableRowHandle& QuestRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerRemoveQuestStickiedState");
		
		ASurvivalPlayerState_ServerRemoveQuestStickiedState_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerGameModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGameMode                                          GameMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerGameModeChanged(EGameMode GameMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerGameModeChanged");
		
		ASurvivalPlayerState_ServerGameModeChanged_Params params {};
		params.GameMode = GameMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerEndViewResourceSurvey
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerState::ServerEndViewResourceSurvey()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerEndViewResourceSurvey");
		
		ASurvivalPlayerState_ServerEndViewResourceSurvey_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerBeginViewResourceSurvey
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerState::ServerBeginViewResourceSurvey()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerBeginViewResourceSurvey");
		
		ASurvivalPlayerState_ServerBeginViewResourceSurvey_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ServerAddKeyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ServerAddKeyItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ServerAddKeyItem");
		
		ASurvivalPlayerState_ServerAddKeyItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.RemoveAchievement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        AchievementName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::RemoveAchievement(const class FName& AchievementName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.RemoveAchievement");
		
		ASurvivalPlayerState_RemoveAchievement_Params params {};
		params.AchievementName = AchievementName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.OnRep_ToggledHUDMarkers
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerState::OnRep_ToggledHUDMarkers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.OnRep_ToggledHUDMarkers");
		
		ASurvivalPlayerState_OnRep_ToggledHUDMarkers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.OnRep_RespawnPoint
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerState::OnRep_RespawnPoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.OnRep_RespawnPoint");
		
		ASurvivalPlayerState_OnRep_RespawnPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.OnRep_ResourceSurveyVisible
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerState::OnRep_ResourceSurveyVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.OnRep_ResourceSurveyVisible");
		
		ASurvivalPlayerState_OnRep_ResourceSurveyVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.OnRep_PlayerGuid
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerState::OnRep_PlayerGuid()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.OnRep_PlayerGuid");
		
		ASurvivalPlayerState_OnRep_PlayerGuid_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.OnRep_PlayerColorSelectionChanged
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerState::OnRep_PlayerColorSelectionChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.OnRep_PlayerColorSelectionChanged");
		
		ASurvivalPlayerState_OnRep_PlayerColorSelectionChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.OnRep_HotBarQuickSlots
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerState::OnRep_HotBarQuickSlots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.OnRep_HotBarQuickSlots");
		
		ASurvivalPlayerState_OnRep_HotBarQuickSlots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.OnRep_DesiredCameraMode
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerState::OnRep_DesiredCameraMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.OnRep_DesiredCameraMode");
		
		ASurvivalPlayerState_OnRep_DesiredCameraMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.OnRep_ClientQuests
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerState::OnRep_ClientQuests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.OnRep_ClientQuests");
		
		ASurvivalPlayerState_OnRep_ClientQuests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.OnRep_ActiveQuestStickiedStates
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerState::OnRep_ActiveQuestStickiedStates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.OnRep_ActiveQuestStickiedStates");
		
		ASurvivalPlayerState_OnRep_ActiveQuestStickiedStates_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.OnPlayerInventoryChanged
	 * 		Flags  -> ()
	 */
	void ASurvivalPlayerState::OnPlayerInventoryChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.OnPlayerInventoryChanged");
		
		ASurvivalPlayerState_OnPlayerInventoryChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.NavigateNextMetaBuildingVariant
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         MetaBuilding                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::NavigateNextMetaBuildingVariant(const struct FDataTableRowHandle& MetaBuilding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.NavigateNextMetaBuildingVariant");
		
		ASurvivalPlayerState_NavigateNextMetaBuildingVariant_Params params {};
		params.MetaBuilding = MetaBuilding;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.MulticastSendChatMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASurvivalPlayerState*                        PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::MulticastSendChatMessage(class ASurvivalPlayerState* PlayerState, const class FString& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.MulticastSendChatMessage");
		
		ASurvivalPlayerState_MulticastSendChatMessage_Params params {};
		params.PlayerState = PlayerState;
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.MulticastGameModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGameMode                                          GameMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::MulticastGameModeChanged(EGameMode GameMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.MulticastGameModeChanged");
		
		ASurvivalPlayerState_MulticastGameModeChanged_Params params {};
		params.GameMode = GameMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.LocallyHandlePawnUnpossess
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::LocallyHandlePawnUnpossess(class APawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.LocallyHandlePawnUnpossess");
		
		ASurvivalPlayerState_LocallyHandlePawnUnpossess_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.LocallyHandlePawnPossess
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::LocallyHandlePawnPossess(class APawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.LocallyHandlePawnPossess");
		
		ASurvivalPlayerState_LocallyHandlePawnPossess_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.IsResourceSurveyVisible
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerState::IsResourceSurveyVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.IsResourceSurveyVisible");
		
		ASurvivalPlayerState_IsResourceSurveyVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.IsBurgleQuestsStickied
	 * 		Flags  -> ()
	 */
	bool ASurvivalPlayerState::IsBurgleQuestsStickied()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.IsBurgleQuestsStickied");
		
		ASurvivalPlayerState_IsBurgleQuestsStickied_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.IsActiveQuestStickied
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         QuestRowHandle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerState::IsActiveQuestStickied(const struct FDataTableRowHandle& QuestRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.IsActiveQuestStickied");
		
		ASurvivalPlayerState_IsActiveQuestStickied_Params params {};
		params.QuestRowHandle = QuestRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.HasViewedTutorial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TutorialRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerState::HasViewedTutorial(const struct FDataTableRowHandle& TutorialRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.HasViewedTutorial");
		
		ASurvivalPlayerState_HasViewedTutorial_Params params {};
		params.TutorialRowHandle = TutorialRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.HasKeyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemHandle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerState::HasKeyItem(const struct FDataTableRowHandle& ItemHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.HasKeyItem");
		
		ASurvivalPlayerState_HasKeyItem_Params params {};
		params.ItemHandle = ItemHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.HasInspectedItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerState::HasInspectedItem(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.HasInspectedItem");
		
		ASurvivalPlayerState_HasInspectedItem_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.HasInspectedCraftingRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         CraftingRecipeRowHandle                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerState::HasInspectedCraftingRecipe(const struct FDataTableRowHandle& CraftingRecipeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.HasInspectedCraftingRecipe");
		
		ASurvivalPlayerState_HasInspectedCraftingRecipe_Params params {};
		params.CraftingRecipeRowHandle = CraftingRecipeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.HasInspectedBuildingRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         BuildingRecipeRowHandle                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerState::HasInspectedBuildingRecipe(const struct FDataTableRowHandle& BuildingRecipeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.HasInspectedBuildingRecipe");
		
		ASurvivalPlayerState_HasInspectedBuildingRecipe_Params params {};
		params.BuildingRecipeRowHandle = BuildingRecipeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.GetViewedTutorials
	 * 		Flags  -> ()
	 */
	TArray<struct FDataTableRowHandle_NetCrc> ASurvivalPlayerState::GetViewedTutorials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.GetViewedTutorials");
		
		ASurvivalPlayerState_GetViewedTutorials_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.GetTechTreeKeyItem
	 * 		Flags  -> ()
	 */
	class UItem* ASurvivalPlayerState::GetTechTreeKeyItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.GetTechTreeKeyItem");
		
		ASurvivalPlayerState_GetTechTreeKeyItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.GetRespawnPoint
	 * 		Flags  -> ()
	 */
	class AActor* ASurvivalPlayerState::GetRespawnPoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.GetRespawnPoint");
		
		ASurvivalPlayerState_GetRespawnPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.GetPlayerTextMute
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerState*                                Target                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASurvivalPlayerState::GetPlayerTextMute(class APlayerState* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.GetPlayerTextMute");
		
		ASurvivalPlayerState_GetPlayerTextMute_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.GetPlayerColorSelection
	 * 		Flags  -> ()
	 */
	int32_t ASurvivalPlayerState::GetPlayerColorSelection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.GetPlayerColorSelection");
		
		ASurvivalPlayerState_GetPlayerColorSelection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.GetPlayerColor
	 * 		Flags  -> ()
	 */
	struct FColor ASurvivalPlayerState::GetPlayerColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.GetPlayerColor");
		
		ASurvivalPlayerState_GetPlayerColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.GetPersonalKeyItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> ASurvivalPlayerState::GetPersonalKeyItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.GetPersonalKeyItems");
		
		ASurvivalPlayerState_GetPersonalKeyItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.GetLastDeathNotification
	 * 		Flags  -> ()
	 */
	struct FDeathInfo ASurvivalPlayerState::GetLastDeathNotification()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.GetLastDeathNotification");
		
		ASurvivalPlayerState_GetLastDeathNotification_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.GetActiveQuestStickiedStates
	 * 		Flags  -> ()
	 */
	TArray<struct FActiveQuestStickiedData> ASurvivalPlayerState::GetActiveQuestStickiedStates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.GetActiveQuestStickiedStates");
		
		ASurvivalPlayerState_GetActiveQuestStickiedStates_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ClientViewTutorial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TutorialRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ClientViewTutorial(const struct FDataTableRowHandle& TutorialRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ClientViewTutorial");
		
		ASurvivalPlayerState_ClientViewTutorial_Params params {};
		params.TutorialRowHandle = TutorialRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ClientSetTutorialComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         TutorialRowHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ClientSetTutorialComplete(const struct FDataTableRowHandle& TutorialRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ClientSetTutorialComplete");
		
		ASurvivalPlayerState_ClientSetTutorialComplete_Params params {};
		params.TutorialRowHandle = TutorialRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ClientSendResourceSurveyBlock
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            StartIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<unsigned char>                              Buffer                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ClientSendResourceSurveyBlock(int32_t StartIndex, TArray<unsigned char> Buffer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ClientSendResourceSurveyBlock");
		
		ASurvivalPlayerState_ClientSendResourceSurveyBlock_Params params {};
		params.StartIndex = StartIndex;
		params.Buffer = Buffer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ClientSendFrankenlineImageBlock
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       ObsidianId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<unsigned char>                              Buffer                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ClientSendFrankenlineImageBlock(const struct FGuid& ObsidianId, TArray<unsigned char> Buffer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ClientSendFrankenlineImageBlock");
		
		ASurvivalPlayerState_ClientSendFrankenlineImageBlock_Params params {};
		params.ObsidianId = ObsidianId;
		params.Buffer = Buffer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ClientOnRequestResearch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ClientOnRequestResearch(const struct FDataTableRowHandle& ItemRowHandle, bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ClientOnRequestResearch");
		
		ASurvivalPlayerState_ClientOnRequestResearch_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ClientOnKeyItemAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               IsNewItem                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ClientOnKeyItemAdded(const struct FDataTableRowHandle& ItemRowHandle, bool IsNewItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ClientOnKeyItemAdded");
		
		ASurvivalPlayerState_ClientOnKeyItemAdded_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.IsNewItem = IsNewItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ClientEndStreamFrankenlineImage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       ObsidianId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ClientEndStreamFrankenlineImage(const struct FGuid& ObsidianId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ClientEndStreamFrankenlineImage");
		
		ASurvivalPlayerState_ClientEndStreamFrankenlineImage_Params params {};
		params.ObsidianId = ObsidianId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.ClientBeginStreamFrankenlineImage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       ObsidianId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int64_t                                            BufferSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::ClientBeginStreamFrankenlineImage(const struct FGuid& ObsidianId, int64_t BufferSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.ClientBeginStreamFrankenlineImage");
		
		ASurvivalPlayerState_ClientBeginStreamFrankenlineImage_Params params {};
		params.ObsidianId = ObsidianId;
		params.BufferSize = BufferSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalPlayerState.AwardAchievement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        AchievementName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurvivalPlayerState::AwardAchievement(const class FName& AchievementName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalPlayerState.AwardAchievement");
		
		ASurvivalPlayerState_AwardAchievement_Params params {};
		params.AchievementName = AchievementName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASurvivalPlayerState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASurvivalPlayerState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalPlayerState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OverTimeEffect.GetTimeRemaining
	 * 		Flags  -> ()
	 */
	float UOverTimeEffect::GetTimeRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OverTimeEffect.GetTimeRemaining");
		
		UOverTimeEffect_GetTimeRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.OverTimeEffect.GetIsExpired
	 * 		Flags  -> ()
	 */
	bool UOverTimeEffect::GetIsExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.OverTimeEffect.GetIsExpired");
		
		UOverTimeEffect_GetIsExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOverTimeEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOverTimeEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.OverTimeEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalWorldSettings.PerformSurfaceTrace
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     WorldLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ASurvivalWorldSettings::PerformSurfaceTrace(const struct FVector& WorldLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalWorldSettings.PerformSurfaceTrace");
		
		ASurvivalWorldSettings_PerformSurfaceTrace_Params params {};
		params.WorldLocation = WorldLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SurvivalWorldSettings.GetSurfaceElevation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ASurvivalWorldSettings::GetSurfaceElevation(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SurvivalWorldSettings.GetSurfaceElevation");
		
		ASurvivalWorldSettings_GetSurfaceElevation_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASurvivalWorldSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASurvivalWorldSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SurvivalWorldSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SwappableFoliageInterface.NotifySwapped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFromDamage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USwappableFoliageInterface::NotifySwapped(bool bFromDamage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SwappableFoliageInterface.NotifySwapped");
		
		USwappableFoliageInterface_NotifySwapped_Params params {};
		params.bFromDamage = bFromDamage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SwappableFoliageInterface.CanRevertToFoliage
	 * 		Flags  -> ()
	 */
	ECanRevertToFoliageState USwappableFoliageInterface::CanRevertToFoliage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SwappableFoliageInterface.CanRevertToFoliage");
		
		USwappableFoliageInterface_CanRevertToFoliage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USwappableFoliageInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USwappableFoliageInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SwappableFoliageInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SwimmingSurvivalCharacter.GetMinWanderHeight
	 * 		Flags  -> ()
	 */
	float ASwimmingSurvivalCharacter::GetMinWanderHeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SwimmingSurvivalCharacter.GetMinWanderHeight");
		
		ASwimmingSurvivalCharacter_GetMinWanderHeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SwimmingSurvivalCharacter.GetMaxWanderHeight
	 * 		Flags  -> ()
	 */
	float ASwimmingSurvivalCharacter::GetMaxWanderHeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SwimmingSurvivalCharacter.GetMaxWanderHeight");
		
		ASwimmingSurvivalCharacter_GetMaxWanderHeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SwimmingSurvivalCharacter.GetCanUseSteeringBehaviors
	 * 		Flags  -> ()
	 */
	bool ASwimmingSurvivalCharacter::GetCanUseSteeringBehaviors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SwimmingSurvivalCharacter.GetCanUseSteeringBehaviors");
		
		ASwimmingSurvivalCharacter_GetCanUseSteeringBehaviors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.SwimmingSurvivalCharacter.EnableSteeringBehavior
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSteeringEnabled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASwimmingSurvivalCharacter::EnableSteeringBehavior(bool bSteeringEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.SwimmingSurvivalCharacter.EnableSteeringBehavior");
		
		ASwimmingSurvivalCharacter_EnableSteeringBehavior_Params params {};
		params.bSteeringEnabled = bSteeringEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASwimmingSurvivalCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASwimmingSurvivalCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SwimmingSurvivalCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TamedCreatureData.SetTameState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETamedState                                        State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTamedCreatureData::SetTameState(ETamedState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TamedCreatureData.SetTameState");
		
		UTamedCreatureData_SetTameState_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TamedCreatureData.OnRep_TameState
	 * 		Flags  -> ()
	 */
	void UTamedCreatureData::OnRep_TameState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TamedCreatureData.OnRep_TameState");
		
		UTamedCreatureData_OnRep_TameState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TamedCreatureData.OnRep_PetMaster
	 * 		Flags  -> ()
	 */
	void UTamedCreatureData::OnRep_PetMaster()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TamedCreatureData.OnRep_PetMaster");
		
		UTamedCreatureData_OnRep_PetMaster_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TamedCreatureData.HandleMasterKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UTamedCreatureData::HandleMasterKilled(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TamedCreatureData.HandleMasterKilled");
		
		UTamedCreatureData_HandleMasterKilled_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TamedCreatureData.GetTameState
	 * 		Flags  -> ()
	 */
	ETamedState UTamedCreatureData::GetTameState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TamedCreatureData.GetTameState");
		
		UTamedCreatureData_GetTameState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TamedCreatureData.GetDaysAsPet
	 * 		Flags  -> ()
	 */
	int32_t UTamedCreatureData::GetDaysAsPet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TamedCreatureData.GetDaysAsPet");
		
		UTamedCreatureData_GetDaysAsPet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTamedCreatureData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTamedCreatureData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TamedCreatureData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TeamComponent.RestoreTeam
	 * 		Flags  -> ()
	 */
	void UTeamComponent::RestoreTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TeamComponent.RestoreTeam");
		
		UTeamComponent_RestoreTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TeamComponent.OnDeath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UTeamComponent::OnDeath(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TeamComponent.OnDeath");
		
		UTeamComponent_OnDeath_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TeamComponent.HasTeam
	 * 		Flags  -> ()
	 */
	bool UTeamComponent::HasTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TeamComponent.HasTeam");
		
		UTeamComponent_HasTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TeamComponent.GetRelationshipToLODActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               Other                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ETeamAttitude UTeamComponent::GetRelationshipToLODActor(class UBaseLODActor* Other)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TeamComponent.GetRelationshipToLODActor");
		
		UTeamComponent_GetRelationshipToLODActor_Params params {};
		params.Other = Other;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TeamComponent.GetRelationship
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Other                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ETeamAttitude UTeamComponent::GetRelationship(class AActor* Other)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TeamComponent.GetRelationship");
		
		UTeamComponent_GetRelationship_Params params {};
		params.Other = Other;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TeamComponent.GetDefaultTeamRowHandle
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UTeamComponent::GetDefaultTeamRowHandle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TeamComponent.GetDefaultTeamRowHandle");
		
		UTeamComponent_GetDefaultTeamRowHandle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TeamComponent.GetCurrentTeamRowHandle
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UTeamComponent::GetCurrentTeamRowHandle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TeamComponent.GetCurrentTeamRowHandle");
		
		UTeamComponent_GetCurrentTeamRowHandle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TeamComponent.ChangeTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         NewTeamDataTable                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UTeamComponent::ChangeTeam(const struct FDataTableRowHandle& NewTeamDataTable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TeamComponent.ChangeTeam");
		
		UTeamComponent_ChangeTeam_Params params {};
		params.NewTeamDataTable = NewTeamDataTable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TeamComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyTeamComponent.GetRelationshipToLODActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               Other                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ETeamAttitude UProxyTeamComponent::GetRelationshipToLODActor(class UBaseLODActor* Other)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyTeamComponent.GetRelationshipToLODActor");
		
		UProxyTeamComponent_GetRelationshipToLODActor_Params params {};
		params.Other = Other;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyTeamComponent.GetRelationshipToActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Other                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ETeamAttitude UProxyTeamComponent::GetRelationshipToActor(class AActor* Other)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyTeamComponent.GetRelationshipToActor");
		
		UProxyTeamComponent_GetRelationshipToActor_Params params {};
		params.Other = Other;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ProxyTeamComponent.GetCurrentTeamRowHandle
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UProxyTeamComponent::GetCurrentTeamRowHandle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ProxyTeamComponent.GetCurrentTeamRowHandle");
		
		UProxyTeamComponent_GetCurrentTeamRowHandle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyTeamComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyTeamComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyTeamComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TeamLODComponent.GetRelationshipToObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Other                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ETeamAttitude UTeamLODComponent::GetRelationshipToObject(class UObject* Other)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TeamLODComponent.GetRelationshipToObject");
		
		UTeamLODComponent_GetRelationshipToObject_Params params {};
		params.Other = Other;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TeamLODComponent.GetRelationshipToLODActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseLODActor*                               Other                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ETeamAttitude UTeamLODComponent::GetRelationshipToLODActor(class UBaseLODActor* Other)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TeamLODComponent.GetRelationshipToLODActor");
		
		UTeamLODComponent_GetRelationshipToLODActor_Params params {};
		params.Other = Other;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TeamLODComponent.GetRelationshipToActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Other                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ETeamAttitude UTeamLODComponent::GetRelationshipToActor(class AActor* Other)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TeamLODComponent.GetRelationshipToActor");
		
		UTeamLODComponent_GetRelationshipToActor_Params params {};
		params.Other = Other;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TeamLODComponent.GetCurrentTeamRowHandle
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UTeamLODComponent::GetCurrentTeamRowHandle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TeamLODComponent.GetCurrentTeamRowHandle");
		
		UTeamLODComponent_GetCurrentTeamRowHandle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamLODComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamLODComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TeamLODComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTechDepositComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTechDepositComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TechDepositComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TelemetryComponent.OnPlayerMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      MapName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTelemetryComponent::OnPlayerMove(const struct FVector& Location, const class FString& MapName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TelemetryComponent.OnPlayerMove");
		
		UTelemetryComponent_OnPlayerMove_Params params {};
		params.Location = Location;
		params.MapName = MapName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTelemetryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTelemetryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TelemetryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TerminalSwitch.OnRep_CurrentWidgetState
	 * 		Flags  -> ()
	 */
	void ATerminalSwitch::OnRep_CurrentWidgetState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TerminalSwitch.OnRep_CurrentWidgetState");
		
		ATerminalSwitch_OnRep_CurrentWidgetState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TerminalSwitch.OnRep_CurrentStateIndex
	 * 		Flags  -> ()
	 */
	void ATerminalSwitch::OnRep_CurrentStateIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TerminalSwitch.OnRep_CurrentStateIndex");
		
		ATerminalSwitch_OnRep_CurrentStateIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TerminalSwitch.OnConditionalStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UConditionalToggleComponent*                 Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATerminalSwitch::OnConditionalStateChanged(class UConditionalToggleComponent* Component, bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TerminalSwitch.OnConditionalStateChanged");
		
		ATerminalSwitch_OnConditionalStateChanged_Params params {};
		params.Component = Component;
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TerminalSwitch.OnConditionalChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ConditionalStateName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATerminalSwitch::OnConditionalChanged(const class FName& ConditionalStateName, bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TerminalSwitch.OnConditionalChanged");
		
		ATerminalSwitch_OnConditionalChanged_Params params {};
		params.ConditionalStateName = ConditionalStateName;
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TerminalSwitch.CanSetGlobalVariables
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ConditionalStateName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGlobalVariableReference                    GlobalVariable                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            DesiredValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ATerminalSwitch::CanSetGlobalVariables(const class FName& ConditionalStateName, const struct FGlobalVariableReference& GlobalVariable, int32_t DesiredValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TerminalSwitch.CanSetGlobalVariables");
		
		ATerminalSwitch_CanSetGlobalVariables_Params params {};
		params.ConditionalStateName = ConditionalStateName;
		params.GlobalVariable = GlobalVariable;
		params.DesiredValue = DesiredValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATerminalSwitch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATerminalSwitch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TerminalSwitch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TerminalSwitchListener.OnTerminalStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ATerminalSwitch*                             Terminal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTerminalConditional                        ConditionalState                                           (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UTerminalSwitchListener::OnTerminalStateChanged(class ATerminalSwitch* Terminal, const struct FTerminalConditional& ConditionalState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TerminalSwitchListener.OnTerminalStateChanged");
		
		UTerminalSwitchListener_OnTerminalStateChanged_Params params {};
		params.Terminal = Terminal;
		params.ConditionalState = ConditionalState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTerminalSwitchListener.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTerminalSwitchListener::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TerminalSwitchListener");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TerminalWidget.OnStateEntered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETerminalWidgetState                               State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTerminalWidget::OnStateEntered(ETerminalWidgetState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TerminalWidget.OnStateEntered");
		
		UTerminalWidget_OnStateEntered_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TerminalWidget.OnInteractionBlockingAnimationEnded
	 * 		Flags  -> ()
	 */
	void UTerminalWidget::OnInteractionBlockingAnimationEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TerminalWidget.OnInteractionBlockingAnimationEnded");
		
		UTerminalWidget_OnInteractionBlockingAnimationEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TerminalWidget.ExitCurrentState
	 * 		Flags  -> ()
	 */
	void UTerminalWidget::ExitCurrentState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TerminalWidget.ExitCurrentState");
		
		UTerminalWidget_ExitCurrentState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TerminalWidget.EnterState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETerminalWidgetState                               State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTerminalWidget::EnterState(ETerminalWidgetState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TerminalWidget.EnterState");
		
		UTerminalWidget_EnterState_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTerminalWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTerminalWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TerminalWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATexturePacker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATexturePacker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TexturePacker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ThirstReadoutWidget.UpdateThirstAnim
	 * 		Flags  -> ()
	 */
	void UThirstReadoutWidget::UpdateThirstAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ThirstReadoutWidget.UpdateThirstAnim");
		
		UThirstReadoutWidget_UpdateThirstAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ThirstReadoutWidget.CheckWaterChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USurvivalComponent*                          Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UThirstReadoutWidget::CheckWaterChange(class USurvivalComponent* Sender, float OldValue, float NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ThirstReadoutWidget.CheckWaterChange");
		
		UThirstReadoutWidget_CheckWaterChange_Params params {};
		params.Sender = Sender;
		params.OldValue = OldValue;
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UThirstReadoutWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UThirstReadoutWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ThirstReadoutWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TimeOfDayLightingManager.UnregisterStencilMaskRenderer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ObjectID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            StencilValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATimeOfDayLightingManager::UnregisterStencilMaskRenderer(int32_t ObjectID, int32_t StencilValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TimeOfDayLightingManager.UnregisterStencilMaskRenderer");
		
		ATimeOfDayLightingManager_UnregisterStencilMaskRenderer_Params params {};
		params.ObjectID = ObjectID;
		params.StencilValue = StencilValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TimeOfDayLightingManager.SetCutsceneDOF
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DOFBlurRadius                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATimeOfDayLightingManager::SetCutsceneDOF(float DOFBlurRadius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TimeOfDayLightingManager.SetCutsceneDOF");
		
		ATimeOfDayLightingManager_SetCutsceneDOF_Params params {};
		params.DOFBlurRadius = DOFBlurRadius;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TimeOfDayLightingManager.RegisterStencilMaskRenderer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ObjectID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            StencilValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATimeOfDayLightingManager::RegisterStencilMaskRenderer(int32_t ObjectID, int32_t StencilValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TimeOfDayLightingManager.RegisterStencilMaskRenderer");
		
		ATimeOfDayLightingManager_RegisterStencilMaskRenderer_Params params {};
		params.ObjectID = ObjectID;
		params.StencilValue = StencilValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TimeOfDayLightingManager.OnActiveBlendablesChanged
	 * 		Flags  -> ()
	 */
	void ATimeOfDayLightingManager::OnActiveBlendablesChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TimeOfDayLightingManager.OnActiveBlendablesChanged");
		
		ATimeOfDayLightingManager_OnActiveBlendablesChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TimeOfDayLightingManager.NativeGetNormalizedTime
	 * 		Flags  -> ()
	 */
	float ATimeOfDayLightingManager::NativeGetNormalizedTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TimeOfDayLightingManager.NativeGetNormalizedTime");
		
		ATimeOfDayLightingManager_NativeGetNormalizedTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TimeOfDayLightingManager.GetSunLight
	 * 		Flags  -> ()
	 */
	class UDirectionalLightComponent* ATimeOfDayLightingManager::GetSunLight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TimeOfDayLightingManager.GetSunLight");
		
		ATimeOfDayLightingManager_GetSunLight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TimeOfDayLightingManager.GetPostProcessMain
	 * 		Flags  -> ()
	 */
	class UPostProcessComponent* ATimeOfDayLightingManager::GetPostProcessMain()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TimeOfDayLightingManager.GetPostProcessMain");
		
		ATimeOfDayLightingManager_GetPostProcessMain_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TimeOfDayLightingManager.GetPhotoModeHour
	 * 		Flags  -> ()
	 */
	int32_t ATimeOfDayLightingManager::GetPhotoModeHour()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TimeOfDayLightingManager.GetPhotoModeHour");
		
		ATimeOfDayLightingManager_GetPhotoModeHour_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TimeOfDayLightingManager.GetNormalizedPhotoModeTime
	 * 		Flags  -> ()
	 */
	float ATimeOfDayLightingManager::GetNormalizedPhotoModeTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TimeOfDayLightingManager.GetNormalizedPhotoModeTime");
		
		ATimeOfDayLightingManager_GetNormalizedPhotoModeTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATimeOfDayLightingManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATimeOfDayLightingManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TimeOfDayLightingManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TorchIndicatorWidget.OnTorchPercentChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              TorchPercent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTorchIndicatorWidget::OnTorchPercentChanged(float TorchPercent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TorchIndicatorWidget.OnTorchPercentChanged");
		
		UTorchIndicatorWidget_OnTorchPercentChanged_Params params {};
		params.TorchPercent = TorchPercent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TorchIndicatorWidget.OnItemPowerStateChangedImpl
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsPowerOn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTorchIndicatorWidget::OnItemPowerStateChangedImpl(bool bIsPowerOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TorchIndicatorWidget.OnItemPowerStateChangedImpl");
		
		UTorchIndicatorWidget_OnItemPowerStateChangedImpl_Params params {};
		params.bIsPowerOn = bIsPowerOn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TorchIndicatorWidget.OnItemPowerStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsPowerOn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTorchIndicatorWidget::OnItemPowerStateChanged(bool bIsPowerOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TorchIndicatorWidget.OnItemPowerStateChanged");
		
		UTorchIndicatorWidget_OnItemPowerStateChanged_Params params {};
		params.bIsPowerOn = bIsPowerOn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTorchIndicatorWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTorchIndicatorWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TorchIndicatorWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TrackedItemSpawnGroup.OnRest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              RestDuration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTrackedItemSpawnGroup::OnRest(float RestDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TrackedItemSpawnGroup.OnRest");
		
		UTrackedItemSpawnGroup_OnRest_Params params {};
		params.RestDuration = RestDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TrackedItemSpawnGroup.OnGlobalVariableChangedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGuid                                       GlobalVariableID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            VariableValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTrackedItemSpawnGroup::OnGlobalVariableChangedEvent(const struct FGuid& GlobalVariableID, int32_t VariableValue, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TrackedItemSpawnGroup.OnGlobalVariableChangedEvent");
		
		UTrackedItemSpawnGroup_OnGlobalVariableChangedEvent_Params params {};
		params.GlobalVariableID = GlobalVariableID;
		params.VariableValue = VariableValue;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TrackedItemSpawnGroup.GetSpawnPointsToAffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemSpawnGroupEvent                        Event                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	TArray<struct FItemSpawnPointData> UTrackedItemSpawnGroup::GetSpawnPointsToAffect(const struct FItemSpawnGroupEvent& Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TrackedItemSpawnGroup.GetSpawnPointsToAffect");
		
		UTrackedItemSpawnGroup_GetSpawnPointsToAffect_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TrackedItemSpawnGroup.GetAllSpawnPoints
	 * 		Flags  -> ()
	 */
	TArray<struct FItemSpawnPointData> UTrackedItemSpawnGroup::GetAllSpawnPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TrackedItemSpawnGroup.GetAllSpawnPoints");
		
		UTrackedItemSpawnGroup_GetAllSpawnPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTrackedItemSpawnGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTrackedItemSpawnGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TrackedItemSpawnGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTrackingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTrackingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TrackingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TransmissionReceiverComponent.GetClosestTransmitterStrength
	 * 		Flags  -> ()
	 */
	float UTransmissionReceiverComponent::GetClosestTransmitterStrength()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TransmissionReceiverComponent.GetClosestTransmitterStrength");
		
		UTransmissionReceiverComponent_GetClosestTransmitterStrength_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTransmissionReceiverComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTransmissionReceiverComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TransmissionReceiverComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TransmitterComponent.SetTransmissionEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTransmitterComponent::SetTransmissionEnabled(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TransmitterComponent.SetTransmissionEnabled");
		
		UTransmitterComponent_SetTransmissionEnabled_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TransmitterComponent.IsTransmissionEnabled
	 * 		Flags  -> ()
	 */
	bool UTransmitterComponent::IsTransmissionEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TransmitterComponent.IsTransmissionEnabled");
		
		UTransmitterComponent_IsTransmissionEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TransmitterComponent.GetTransmittorType
	 * 		Flags  -> ()
	 */
	struct FGameplayTag UTransmitterComponent::GetTransmittorType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TransmitterComponent.GetTransmittorType");
		
		UTransmitterComponent_GetTransmittorType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTransmitterComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTransmitterComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TransmitterComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Trap.SpawnHazard
	 * 		Flags  -> ()
	 */
	void ATrap::SpawnHazard()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Trap.SpawnHazard");
		
		ATrap_SpawnHazard_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Trap.SetTrapArmed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrap::SetTrapArmed(bool bActive, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Trap.SetTrapArmed");
		
		ATrap_SetTrapArmed_Params params {};
		params.bActive = bActive;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Trap.OnTriggerEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrap::OnTriggerEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Trap.OnTriggerEndOverlap");
		
		ATrap_OnTriggerEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Trap.OnTriggerBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ATrap::OnTriggerBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Trap.OnTriggerBeginOverlap");
		
		ATrap_OnTriggerBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Trap.OnSpawnHazard
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AHazard*                                     SpawnedHazard                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrap::OnSpawnHazard(class AHazard* SpawnedHazard)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Trap.OnSpawnHazard");
		
		ATrap_OnSpawnHazard_Params params {};
		params.SpawnedHazard = SpawnedHazard;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Trap.OnRep_TrapTriggerState
	 * 		Flags  -> ()
	 */
	void ATrap::OnRep_TrapTriggerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Trap.OnRep_TrapTriggerState");
		
		ATrap_OnRep_TrapTriggerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Trap.OnRep_TrapArmed
	 * 		Flags  -> ()
	 */
	void ATrap::OnRep_TrapArmed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Trap.OnRep_TrapArmed");
		
		ATrap_OnRep_TrapArmed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Trap.OnRep_ItemsAdded
	 * 		Flags  -> ()
	 */
	void ATrap::OnRep_ItemsAdded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Trap.OnRep_ItemsAdded");
		
		ATrap_OnRep_ItemsAdded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Trap.OnHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsKillingBlow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrap::OnHit(float Damage, const struct FDamageInfo& DamageInfo, class AController* InstigatedBy, class UBaseLODActor* DamageCauser, bool IsKillingBlow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Trap.OnHit");
		
		ATrap_OnHit_Params params {};
		params.Damage = Damage;
		params.DamageInfo = DamageInfo;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		params.IsKillingBlow = IsKillingBlow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Trap.IsTrapArmed
	 * 		Flags  -> ()
	 */
	bool ATrap::IsTrapArmed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Trap.IsTrapArmed");
		
		ATrap_IsTrapArmed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Trap.IsFull
	 * 		Flags  -> ()
	 */
	bool ATrap::IsFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Trap.IsFull");
		
		ATrap_IsFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Trap.GetTriggerDelay
	 * 		Flags  -> ()
	 */
	float ATrap::GetTriggerDelay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Trap.GetTriggerDelay");
		
		ATrap_GetTriggerDelay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Trap.GetRemainingTriggerDelay
	 * 		Flags  -> ()
	 */
	float ATrap::GetRemainingTriggerDelay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Trap.GetRemainingTriggerDelay");
		
		ATrap_GetRemainingTriggerDelay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Trap.GetNumItems
	 * 		Flags  -> ()
	 */
	int32_t ATrap::GetNumItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Trap.GetNumItems");
		
		ATrap_GetNumItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATrap.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATrap::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Trap");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TypeRestrictedStorageBuilding.OnRep_StoredItems
	 * 		Flags  -> ()
	 */
	void ATypeRestrictedStorageBuilding::OnRep_StoredItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TypeRestrictedStorageBuilding.OnRep_StoredItems");
		
		ATypeRestrictedStorageBuilding_OnRep_StoredItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TypeRestrictedStorageBuilding.MulticastPlaceItem
	 * 		Flags  -> ()
	 */
	void ATypeRestrictedStorageBuilding::MulticastPlaceItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TypeRestrictedStorageBuilding.MulticastPlaceItem");
		
		ATypeRestrictedStorageBuilding_MulticastPlaceItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.TypeRestrictedStorageBuilding.HasPlaceableItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InstigatedBy                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ATypeRestrictedStorageBuilding::HasPlaceableItem(class AActor* InstigatedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.TypeRestrictedStorageBuilding.HasPlaceableItem");
		
		ATypeRestrictedStorageBuilding_HasPlaceableItem_Params params {};
		params.InstigatedBy = InstigatedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATypeRestrictedStorageBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATypeRestrictedStorageBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.TypeRestrictedStorageBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUINotificationBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUINotificationBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.UINotificationBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UpgradeCollectible.OnOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AUpgradeCollectible::OnOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UpgradeCollectible.OnOverlap");
		
		AUpgradeCollectible_OnOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AUpgradeCollectible.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AUpgradeCollectible::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.UpgradeCollectible");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProxyUpgradeCollectibleActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProxyUpgradeCollectibleActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ProxyUpgradeCollectibleActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUpgradeCollectibleLODActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUpgradeCollectibleLODActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.UpgradeCollectibleLODActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.ScrollInViewForFocus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScrollBox*                                  ScrollBox                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidget*                                     Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               AnimateScroll                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Padding                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUserInterfaceStatics::ScrollInViewForFocus(class UScrollBox* ScrollBox, class UWidget* Widget, bool AnimateScroll, float Padding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.ScrollInViewForFocus");
		
		UUserInterfaceStatics_ScrollInViewForFocus_Params params {};
		params.ScrollBox = ScrollBox;
		params.Widget = Widget;
		params.AnimateScroll = AnimateScroll;
		params.Padding = Padding;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.RemoveItemsForCraftingRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<class UItem*>                               HaveItems                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UUserInterfaceStatics::RemoveItemsForCraftingRecipe(const struct FDataTableRowHandle& RecipeRowHandle, TArray<class UItem*>* HaveItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.RemoveItemsForCraftingRecipe");
		
		UUserInterfaceStatics_RemoveItemsForCraftingRecipe_Params params {};
		params.RecipeRowHandle = RecipeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (HaveItems != nullptr)
			*HaveItems = params.HaveItems;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.MakeTextDirectional
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Text                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class FText UUserInterfaceStatics::MakeTextDirectional(const class FText& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.MakeTextDirectional");
		
		UUserInterfaceStatics_MakeTextDirectional_Params params {};
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.MakeHotBarQuickSlotItemTypeKeyFromItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FHotBarQuickSlotItemTypeKey UUserInterfaceStatics::MakeHotBarQuickSlotItemTypeKeyFromItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.MakeHotBarQuickSlotItemTypeKeyFromItem");
		
		UUserInterfaceStatics_MakeHotBarQuickSlotItemTypeKeyFromItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.LogUIMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUserInterfaceStatics::LogUIMessage(const class FString& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.LogUIMessage");
		
		UUserInterfaceStatics_LogUIMessage_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.IsValidLocalizedString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLocString                                  LocString                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UUserInterfaceStatics::IsValidLocalizedString(const struct FLocString& LocString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.IsValidLocalizedString");
		
		UUserInterfaceStatics_IsValidLocalizedString_Params params {};
		params.LocString = LocString;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.IsKeyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UUserInterfaceStatics::IsKeyItem(const struct FDataTableRowHandle& ItemRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.IsKeyItem");
		
		UUserInterfaceStatics_IsKeyItem_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.HasRequirements
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FRecipeRequirements>                 Requirements                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class UItem*>                               HaveItems                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UUserInterfaceStatics::HasRequirements(class UObject* WorldContextObject, TArray<struct FRecipeRequirements> Requirements, TArray<class UItem*> HaveItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.HasRequirements");
		
		UUserInterfaceStatics_HasRequirements_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Requirements = Requirements;
		params.HaveItems = HaveItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.GetWidgetManagerOwnerProxy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UWidgetPlayerProxy* UUserInterfaceStatics::GetWidgetManagerOwnerProxy(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.GetWidgetManagerOwnerProxy");
		
		UUserInterfaceStatics_GetWidgetManagerOwnerProxy_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.GetWidgetManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UWidgetManager* UUserInterfaceStatics::GetWidgetManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.GetWidgetManager");
		
		UUserInterfaceStatics_GetWidgetManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.GetParentScrollBox
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UScrollBox* UUserInterfaceStatics::GetParentScrollBox(class UWidget* Widget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.GetParentScrollBox");
		
		UUserInterfaceStatics_GetParentScrollBox_Params params {};
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.GetMaxCraftable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<class UItem*>                               HaveItems                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	int32_t UUserInterfaceStatics::GetMaxCraftable(class UObject* WorldContextObject, const struct FDataTableRowHandle& RecipeRowHandle, TArray<class UItem*> HaveItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.GetMaxCraftable");
		
		UUserInterfaceStatics_GetMaxCraftable_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.RecipeRowHandle = RecipeRowHandle;
		params.HaveItems = HaveItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.GetLocalizedString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLocString                                  LocString                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UUserInterfaceStatics::GetLocalizedString(const struct FLocString& LocString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.GetLocalizedString");
		
		UUserInterfaceStatics_GetLocalizedString_Params params {};
		params.LocString = LocString;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.GetItemCountForHotBarKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHotBarQuickSlotItemTypeKey                 ItemKey                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<class UItem*>                               HaveItems                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               IncludeBrokenItems                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UUserInterfaceStatics::GetItemCountForHotBarKey(const struct FHotBarQuickSlotItemTypeKey& ItemKey, TArray<class UItem*> HaveItems, bool IncludeBrokenItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.GetItemCountForHotBarKey");
		
		UUserInterfaceStatics_GetItemCountForHotBarKey_Params params {};
		params.ItemKey = ItemKey;
		params.HaveItems = HaveItems;
		params.IncludeBrokenItems = IncludeBrokenItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.GetItemCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         ItemRowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<class UItem*>                               HaveItems                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               IncludeBrokenItems                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UUserInterfaceStatics::GetItemCount(const struct FDataTableRowHandle& ItemRowHandle, TArray<class UItem*> HaveItems, bool IncludeBrokenItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.GetItemCount");
		
		UUserInterfaceStatics_GetItemCount_Params params {};
		params.ItemRowHandle = ItemRowHandle;
		params.HaveItems = HaveItems;
		params.IncludeBrokenItems = IncludeBrokenItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.GetHeatMapColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLinearColor UUserInterfaceStatics::GetHeatMapColor(class UObject* WorldContextObject, float Alpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.GetHeatMapColor");
		
		UUserInterfaceStatics_GetHeatMapColor_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Alpha = Alpha;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.GetGlobalColorLinear
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        EnumName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLinearColor UUserInterfaceStatics::GetGlobalColorLinear(class UObject* WorldContextObject, const class FName& EnumName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.GetGlobalColorLinear");
		
		UUserInterfaceStatics_GetGlobalColorLinear_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.EnumName = EnumName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.GetGameUI
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AGameUI* UUserInterfaceStatics::GetGameUI(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.GetGameUI");
		
		UUserInterfaceStatics_GetGameUI_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.GetFilterMatches
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      FilterText                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FString>                              Keywords                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UUserInterfaceStatics::GetFilterMatches(const class FString& FilterText, TArray<class FString> Keywords)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.GetFilterMatches");
		
		UUserInterfaceStatics_GetFilterMatches_Params params {};
		params.FilterText = FilterText;
		params.Keywords = Keywords;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.GetCultureFlowIsRTL
	 * 		Flags  -> ()
	 */
	bool UUserInterfaceStatics::GetCultureFlowIsRTL()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.GetCultureFlowIsRTL");
		
		UUserInterfaceStatics_GetCultureFlowIsRTL_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.GetAttackSpeedText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                AttackSpeedTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UUserInterfaceStatics::GetAttackSpeedText(const struct FGameplayTag& AttackSpeedTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.GetAttackSpeedText");
		
		UUserInterfaceStatics_GetAttackSpeedText_Params params {};
		params.AttackSpeedTag = AttackSpeedTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.FindScreenEdgeLocationForWorldLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     InLocation                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              EdgePercent                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   OutScreenPosition                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutRotationAngleDegrees                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsOnScreen                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFacingBackward                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUserInterfaceStatics::FindScreenEdgeLocationForWorldLocation(class UObject* WorldContextObject, const struct FVector& InLocation, float EdgePercent, struct FVector2D* OutScreenPosition, float* OutRotationAngleDegrees, bool* bIsOnScreen, bool* bFacingBackward)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.FindScreenEdgeLocationForWorldLocation");
		
		UUserInterfaceStatics_FindScreenEdgeLocationForWorldLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InLocation = InLocation;
		params.EdgePercent = EdgePercent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutScreenPosition != nullptr)
			*OutScreenPosition = params.OutScreenPosition;
		if (OutRotationAngleDegrees != nullptr)
			*OutRotationAngleDegrees = params.OutRotationAngleDegrees;
		if (bIsOnScreen != nullptr)
			*bIsOnScreen = params.bIsOnScreen;
		if (bFacingBackward != nullptr)
			*bFacingBackward = params.bFacingBackward;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.DoesKeyMatchActionMapping
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ActionMappingName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UUserInterfaceStatics::DoesKeyMatchActionMapping(const struct FKey& Key, const class FName& ActionMappingName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.DoesKeyMatchActionMapping");
		
		UUserInterfaceStatics_DoesKeyMatchActionMapping_Params params {};
		params.Key = Key;
		params.ActionMappingName = ActionMappingName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.DoesChordMatchActionMapping
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputChord                                 Chord                                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ActionMappingName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UUserInterfaceStatics::DoesChordMatchActionMapping(const struct FInputChord& Chord, const class FName& ActionMappingName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.DoesChordMatchActionMapping");
		
		UUserInterfaceStatics_DoesChordMatchActionMapping_Params params {};
		params.Chord = Chord;
		params.ActionMappingName = ActionMappingName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.CanCraftRecipeData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRecipeData                                 RecipeData                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		TArray<class UItem*>                               HaveItems                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UUserInterfaceStatics::CanCraftRecipeData(class UObject* WorldContextObject, struct FRecipeData* RecipeData, TArray<class UItem*> HaveItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.CanCraftRecipeData");
		
		UUserInterfaceStatics_CanCraftRecipeData_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.HaveItems = HaveItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (RecipeData != nullptr)
			*RecipeData = params.RecipeData;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.UserInterfaceStatics.CanCraftRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<class UItem*>                               HaveItems                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UUserInterfaceStatics::CanCraftRecipe(class UObject* WorldContextObject, const struct FDataTableRowHandle& RecipeRowHandle, TArray<class UItem*> HaveItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.UserInterfaceStatics.CanCraftRecipe");
		
		UUserInterfaceStatics_CanCraftRecipe_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.RecipeRowHandle = RecipeRowHandle;
		params.HaveItems = HaveItems;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUserInterfaceStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUserInterfaceStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.UserInterfaceStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVFXActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVFXActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VFXActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ViewControl.UpdateCamera
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UViewControl::UpdateCamera(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ViewControl.UpdateCamera");
		
		UViewControl_UpdateCamera_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ViewControl.SetCameraView
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     ViewProvider                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EViewTargetBlendFunction                           BlendFunc                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLockOutgoing                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUsePawnLook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UViewControl::SetCameraView(class UObject* ViewProvider, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing, bool bUsePawnLook)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ViewControl.SetCameraView");
		
		UViewControl_SetCameraView_Params params {};
		params.ViewProvider = ViewProvider;
		params.BlendTime = BlendTime;
		params.BlendFunc = BlendFunc;
		params.BlendExp = BlendExp;
		params.bLockOutgoing = bLockOutgoing;
		params.bUsePawnLook = bUsePawnLook;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ViewControl.SetCamera
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCameraComponent*                            InCamera                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UViewControl::SetCamera(class UCameraComponent* InCamera)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ViewControl.SetCamera");
		
		UViewControl_SetCamera_Params params {};
		params.InCamera = InCamera;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ViewControl.IsViewControlledBySelf
	 * 		Flags  -> ()
	 */
	bool UViewControl::IsViewControlledBySelf()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ViewControl.IsViewControlledBySelf");
		
		UViewControl_IsViewControlledBySelf_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ViewControl.IsBlendInProgress
	 * 		Flags  -> ()
	 */
	bool UViewControl::IsBlendInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ViewControl.IsBlendInProgress");
		
		UViewControl_IsBlendInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UViewControl.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UViewControl::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ViewControl");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVisualEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVisualEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VisualEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VisualStateComponent.SetActiveMeshTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                NewActiveTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVisualStateComponent::SetActiveMeshTag(const struct FGameplayTag& NewActiveTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VisualStateComponent.SetActiveMeshTag");
		
		UVisualStateComponent_SetActiveMeshTag_Params params {};
		params.NewActiveTag = NewActiveTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VisualStateComponent.ResetActiveMeshTag
	 * 		Flags  -> ()
	 */
	void UVisualStateComponent::ResetActiveMeshTag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VisualStateComponent.ResetActiveMeshTag");
		
		UVisualStateComponent_ResetActiveMeshTag_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VisualStateComponent.OnRep_HitLocations
	 * 		Flags  -> ()
	 */
	void UVisualStateComponent::OnRep_HitLocations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VisualStateComponent.OnRep_HitLocations");
		
		UVisualStateComponent_OnRep_HitLocations_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VisualStateComponent.OnRep_HealthState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHealthVisualState                                 OldHealthState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVisualStateComponent::OnRep_HealthState(EHealthVisualState OldHealthState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VisualStateComponent.OnRep_HealthState");
		
		UVisualStateComponent_OnRep_HealthState_Params params {};
		params.OldHealthState = OldHealthState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VisualStateComponent.OnHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseLODActor*                               DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsKillingBlow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVisualStateComponent::OnHit(float Damage, const struct FDamageInfo& DamageInfo, class AController* InstigatedBy, class UBaseLODActor* DamageCauser, bool IsKillingBlow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VisualStateComponent.OnHit");
		
		UVisualStateComponent_OnHit_Params params {};
		params.Damage = Damage;
		params.DamageInfo = DamageInfo;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		params.IsKillingBlow = IsKillingBlow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VisualStateComponent.OnHealthChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHealthComponent*                            SourceHealthComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CurrentHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OldHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVisualStateComponent::OnHealthChange(class UHealthComponent* SourceHealthComponent, float CurrentHealth, float OldHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VisualStateComponent.OnHealthChange");
		
		UVisualStateComponent_OnHealthChange_Params params {};
		params.SourceHealthComponent = SourceHealthComponent;
		params.CurrentHealth = CurrentHealth;
		params.OldHealth = OldHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VisualStateComponent.HasMeshTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                Tag                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UVisualStateComponent::HasMeshTag(const struct FGameplayTag& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VisualStateComponent.HasMeshTag");
		
		UVisualStateComponent_HasMeshTag_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VisualStateComponent.GetMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHealthVisualState                                 HealthState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                MeshTag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UStaticMesh* UVisualStateComponent::GetMesh(EHealthVisualState HealthState, const struct FGameplayTag& MeshTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VisualStateComponent.GetMesh");
		
		UVisualStateComponent_GetMesh_Params params {};
		params.HealthState = HealthState;
		params.MeshTag = MeshTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVisualStateComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVisualStateComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VisualStateComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VitalStat.GetDecayRate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInterestCore*                               Core                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaHours                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UVitalStat::GetDecayRate(class UInterestCore* Core, float DeltaHours)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VitalStat.GetDecayRate");
		
		UVitalStat_GetDecayRate_Params params {};
		params.Core = Core;
		params.DeltaHours = DeltaHours;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VitalStat.GetDamageResponse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	float UVitalStat::GetDamageResponse(float Damage, const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VitalStat.GetDamageResponse");
		
		UVitalStat_GetDamageResponse_Params params {};
		params.Damage = Damage;
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VitalStat.GenerateStartingValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInterestCore*                               Core                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UVitalStat::GenerateStartingValue(class UInterestCore* Core)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VitalStat.GenerateStartingValue");
		
		UVitalStat_GenerateStartingValue_Params params {};
		params.Core = Core;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVitalStat.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVitalStat::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VitalStat");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVitalStatConstant.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVitalStatConstant::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VitalStatConstant");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVitalStatDamageDriven.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVitalStatDamageDriven::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VitalStatDamageDriven");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVitalStatFlyingTiredness.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVitalStatFlyingTiredness::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VitalStatFlyingTiredness");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVitalStatHourDriven.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVitalStatHourDriven::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VitalStatHourDriven");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVitalStatPetHappiness.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVitalStatPetHappiness::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VitalStatPetHappiness");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVitalStatSleepiness.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVitalStatSleepiness::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VitalStatSleepiness");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVitalStatSwimmingTiredness.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVitalStatSwimmingTiredness::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VitalStatSwimmingTiredness");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVitalStatTotalHoursDriven.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVitalStatTotalHoursDriven::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VitalStatTotalHoursDriven");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VitalVisualsComponent.OnRep_VitalValue
	 * 		Flags  -> ()
	 */
	void UVitalVisualsComponent::OnRep_VitalValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VitalVisualsComponent.OnRep_VitalValue");
		
		UVitalVisualsComponent_OnRep_VitalValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VitalVisualsComponent.HasVitalTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                Tag                                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UVitalVisualsComponent::HasVitalTag(const struct FGameplayTag& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VitalVisualsComponent.HasVitalTag");
		
		UVitalVisualsComponent_HasVitalTag_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VitalVisualsComponent.GetVitalValue
	 * 		Flags  -> ()
	 */
	float UVitalVisualsComponent::GetVitalValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VitalVisualsComponent.GetVitalValue");
		
		UVitalVisualsComponent_GetVitalValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVitalVisualsComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVitalVisualsComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VitalVisualsComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVolumetricAudioController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVolumetricAudioController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VolumetricAudioController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.VolumetricAudioEmitter.GetAudioComponent
	 * 		Flags  -> ()
	 */
	class UAudioComponent* AVolumetricAudioEmitter::GetAudioComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.VolumetricAudioEmitter.GetAudioComponent");
		
		AVolumetricAudioEmitter_GetAudioComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVolumetricAudioEmitter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVolumetricAudioEmitter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.VolumetricAudioEmitter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWalkableBoxComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWalkableBoxComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WalkableBoxComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WaterBody.UpdateMeshVisibility
	 * 		Flags  -> ()
	 */
	void AWaterBody::UpdateMeshVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WaterBody.UpdateMeshVisibility");
		
		AWaterBody_UpdateMeshVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WaterBody.SetMaterialParameters
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            MaterialIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMaterialInstanceDynamic*                    Mid                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AWaterBody::SetMaterialParameters(int32_t MaterialIndex, class UMaterialInstanceDynamic* Mid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WaterBody.SetMaterialParameters");
		
		AWaterBody_SetMaterialParameters_Params params {};
		params.MaterialIndex = MaterialIndex;
		params.Mid = Mid;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WaterBody.IsPlayerAboveWater
	 * 		Flags  -> ()
	 */
	bool AWaterBody::IsPlayerAboveWater()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WaterBody.IsPlayerAboveWater");
		
		AWaterBody_IsPlayerAboveWater_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WaterBody.GetWaterSurfaceWorldHeight
	 * 		Flags  -> ()
	 */
	float AWaterBody::GetWaterSurfaceWorldHeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WaterBody.GetWaterSurfaceWorldHeight");
		
		AWaterBody_GetWaterSurfaceWorldHeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WaterBody.GetLocalPlayerDistanceToWater
	 * 		Flags  -> ()
	 */
	float AWaterBody::GetLocalPlayerDistanceToWater()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WaterBody.GetLocalPlayerDistanceToWater");
		
		AWaterBody_GetLocalPlayerDistanceToWater_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWaterBody.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWaterBody::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WaterBody");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWaterManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWaterManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WaterManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWaveCreatureComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWaveCreatureComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WaveCreatureComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpawnedWave.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpawnedWave::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.SpawnedWave");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WaveManagerComponent.OnSpawnKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UWaveManagerComponent::OnSpawnKilled(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WaveManagerComponent.OnSpawnKilled");
		
		UWaveManagerComponent_OnSpawnKilled_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WaveManagerComponent.OnRep_WaveActive
	 * 		Flags  -> ()
	 */
	void UWaveManagerComponent::OnRep_WaveActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WaveManagerComponent.OnRep_WaveActive");
		
		UWaveManagerComponent_OnRep_WaveActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WaveManagerComponent.OnRep_AttackState
	 * 		Flags  -> ()
	 */
	void UWaveManagerComponent::OnRep_AttackState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WaveManagerComponent.OnRep_AttackState");
		
		UWaveManagerComponent_OnRep_AttackState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WaveManagerComponent.IsWaveActive
	 * 		Flags  -> ()
	 */
	bool UWaveManagerComponent::IsWaveActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WaveManagerComponent.IsWaveActive");
		
		UWaveManagerComponent_IsWaveActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WaveManagerComponent.GetWaveProgress
	 * 		Flags  -> ()
	 */
	float UWaveManagerComponent::GetWaveProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WaveManagerComponent.GetWaveProgress");
		
		UWaveManagerComponent_GetWaveProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WaveManagerComponent.GetNumWaveCreatures
	 * 		Flags  -> ()
	 */
	int32_t UWaveManagerComponent::GetNumWaveCreatures()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WaveManagerComponent.GetNumWaveCreatures");
		
		UWaveManagerComponent_GetNumWaveCreatures_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WaveManagerComponent.GetInitialWaveCreatureCount
	 * 		Flags  -> ()
	 */
	int32_t UWaveManagerComponent::GetInitialWaveCreatureCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WaveManagerComponent.GetInitialWaveCreatureCount");
		
		UWaveManagerComponent_GetInitialWaveCreatureCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WaveManagerComponent.GenerateWaveSpawns
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Heat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FWaveSpawn>                          WaveSpawnData                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UWaveManagerComponent::GenerateWaveSpawns(int32_t Heat, TArray<struct FWaveSpawn>* WaveSpawnData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WaveManagerComponent.GenerateWaveSpawns");
		
		UWaveManagerComponent_GenerateWaveSpawns_Params params {};
		params.Heat = Heat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (WaveSpawnData != nullptr)
			*WaveSpawnData = params.WaveSpawnData;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WaveManagerComponent.GenerateFactionWaveSpawns
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayTag                                FactionTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Heat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWaveManagerComponent::GenerateFactionWaveSpawns(const struct FGameplayTag& FactionTag, int32_t Heat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WaveManagerComponent.GenerateFactionWaveSpawns");
		
		UWaveManagerComponent_GenerateFactionWaveSpawns_Params params {};
		params.FactionTag = FactionTag;
		params.Heat = Heat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWaveManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWaveManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WaveManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWaveSpawnTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWaveSpawnTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WaveSpawnTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.Waypoint.SetNextWaypoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AWaypoint*                                   InWaypoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AWaypoint::SetNextWaypoint(class AWaypoint* InWaypoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.Waypoint.SetNextWaypoint");
		
		AWaypoint_SetNextWaypoint_Params params {};
		params.InWaypoint = InWaypoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWaypoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWaypoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.Waypoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WeaponAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WebLoginWidget.OnLoginUrlChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Text                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UWebLoginWidget::OnLoginUrlChanged(const class FText& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WebLoginWidget.OnLoginUrlChanged");
		
		UWebLoginWidget_OnLoginUrlChanged_Params params {};
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WebLoginWidget.OnLoginShow
	 * 		Flags  -> ()
	 */
	void UWebLoginWidget::OnLoginShow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WebLoginWidget.OnLoginShow");
		
		UWebLoginWidget_OnLoginShow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WebLoginWidget.OnLoginHide
	 * 		Flags  -> ()
	 */
	void UWebLoginWidget::OnLoginHide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WebLoginWidget.OnLoginHide");
		
		UWebLoginWidget_OnLoginHide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WebLoginWidget.CancelWebLogin
	 * 		Flags  -> ()
	 */
	void UWebLoginWidget::CancelWebLogin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WebLoginWidget.CancelWebLogin");
		
		UWebLoginWidget_CancelWebLogin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWebLoginWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWebLoginWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WebLoginWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetPlayerProxy.GetInventoryAndEquippedItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UWidgetPlayerProxy::GetInventoryAndEquippedItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetPlayerProxy.GetInventoryAndEquippedItems");
		
		UWidgetPlayerProxy_GetInventoryAndEquippedItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetPlayerProxy.GetInventoryAndEquippedAndHauledItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UWidgetPlayerProxy::GetInventoryAndEquippedAndHauledItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetPlayerProxy.GetInventoryAndEquippedAndHauledItems");
		
		UWidgetPlayerProxy_GetInventoryAndEquippedAndHauledItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetPlayerProxy.GetAllItemsAndNearbyItems
	 * 		Flags  -> ()
	 */
	TArray<class UItem*> UWidgetPlayerProxy::GetAllItemsAndNearbyItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetPlayerProxy.GetAllItemsAndNearbyItems");
		
		UWidgetPlayerProxy_GetAllItemsAndNearbyItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWidgetPlayerProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWidgetPlayerProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WidgetPlayerProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.TryCloseInteractableWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InteractableActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidgetManager::TryCloseInteractableWidget(class AActor* InteractableActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.TryCloseInteractableWidget");
		
		UWidgetManager_TryCloseInteractableWidget_Params params {};
		params.InteractableActor = InteractableActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.TogglePauseMenu
	 * 		Flags  -> ()
	 */
	void UWidgetManager::TogglePauseMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.TogglePauseMenu");
		
		UWidgetManager_TogglePauseMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.SwapItemSlots
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item1                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UItem*                                       Item2                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidgetManager::SwapItemSlots(class UItem* Item1, int32_t Index1, class UItem* Item2, int32_t Index2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.SwapItemSlots");
		
		UWidgetManager_SwapItemSlots_Params params {};
		params.Item1 = Item1;
		params.Index1 = Index1;
		params.Item2 = Item2;
		params.Index2 = Index2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.ShowPauseMenu
	 * 		Flags  -> ()
	 */
	void UWidgetManager::ShowPauseMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.ShowPauseMenu");
		
		UWidgetManager_ShowPauseMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.SetPauseMenuActive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidgetManager::SetPauseMenuActive(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.SetPauseMenuActive");
		
		UWidgetManager_SetPauseMenuActive_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.RemoveProxyItemsForRecipe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RecipeRowHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UWidgetManager::RemoveProxyItemsForRecipe(const struct FDataTableRowHandle& RecipeRowHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.RemoveProxyItemsForRecipe");
		
		UWidgetManager_RemoveProxyItemsForRecipe_Params params {};
		params.RecipeRowHandle = RecipeRowHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.RemoveProxyItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidgetManager::RemoveProxyItem(class UItem* Item, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.RemoveProxyItem");
		
		UWidgetManager_RemoveProxyItem_Params params {};
		params.Item = Item;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.ProxyUnequipItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidgetManager::ProxyUnequipItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.ProxyUnequipItem");
		
		UWidgetManager_ProxyUnequipItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.ProxyEquipItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidgetManager::ProxyEquipItem(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.ProxyEquipItem");
		
		UWidgetManager_ProxyEquipItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.OnUsingGamepadChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsUsingGamepad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidgetManager::OnUsingGamepadChanged(bool IsUsingGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.OnUsingGamepadChanged");
		
		UWidgetManager_OnUsingGamepadChanged_Params params {};
		params.IsUsingGamepad = IsUsingGamepad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.OnPlayerProximityInvetoriesChanged
	 * 		Flags  -> ()
	 */
	void UWidgetManager::OnPlayerProximityInvetoriesChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.OnPlayerProximityInvetoriesChanged");
		
		UWidgetManager_OnPlayerProximityInvetoriesChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.OnPlayerInventoryChanged
	 * 		Flags  -> ()
	 */
	void UWidgetManager::OnPlayerInventoryChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.OnPlayerInventoryChanged");
		
		UWidgetManager_OnPlayerInventoryChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.OnPlayerHaulingChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHaulingComponent*                           Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidgetManager::OnPlayerHaulingChanged(class UHaulingComponent* Sender)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.OnPlayerHaulingChanged");
		
		UWidgetManager_OnPlayerHaulingChanged_Params params {};
		params.Sender = Sender;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.OnPlayerEquipmentChanged
	 * 		Flags  -> ()
	 */
	void UWidgetManager::OnPlayerEquipmentChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.OnPlayerEquipmentChanged");
		
		UWidgetManager_OnPlayerEquipmentChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.OnGameStateReset
	 * 		Flags  -> ()
	 */
	void UWidgetManager::OnGameStateReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.OnGameStateReset");
		
		UWidgetManager_OnGameStateReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.HidePauseMenu
	 * 		Flags  -> ()
	 */
	void UWidgetManager::HidePauseMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.HidePauseMenu");
		
		UWidgetManager_HidePauseMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.GetTopWindow
	 * 		Flags  -> ()
	 */
	class UWindowWidget* UWidgetManager::GetTopWindow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.GetTopWindow");
		
		UWidgetManager_GetTopWindow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.GetOwningPlayerProxy
	 * 		Flags  -> ()
	 */
	class UWidgetPlayerProxy* UWidgetManager::GetOwningPlayerProxy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.GetOwningPlayerProxy");
		
		UWidgetManager_GetOwningPlayerProxy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.GetNumWindowsOpen
	 * 		Flags  -> ()
	 */
	int32_t UWidgetManager::GetNumWindowsOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.GetNumWindowsOpen");
		
		UWidgetManager_GetNumWindowsOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.GetHideHUD
	 * 		Flags  -> ()
	 */
	bool UWidgetManager::GetHideHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.GetHideHUD");
		
		UWidgetManager_GetHideHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.GetActiveWindowOfType
	 * 		Flags  -> ()
	 */
	class UWindowWidget* UWidgetManager::GetActiveWindowOfType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.GetActiveWindowOfType");
		
		UWidgetManager_GetActiveWindowOfType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.DefragProxyInventory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               SingleItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidgetManager::DefragProxyInventory(bool SingleItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.DefragProxyInventory");
		
		UWidgetManager_DefragProxyInventory_Params params {};
		params.SingleItem = SingleItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.CreateWindowWidget
	 * 		Flags  -> ()
	 */
	class UWindowWidget* UWidgetManager::CreateWindowWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.CreateWindowWidget");
		
		UWidgetManager_CreateWindowWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.CloseWindowOfType
	 * 		Flags  -> ()
	 */
	void UWidgetManager::CloseWindowOfType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.CloseWindowOfType");
		
		UWidgetManager_CloseWindowOfType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.CloseWindow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWindowWidget*                               Window                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidgetManager::CloseWindow(class UWindowWidget* Window)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.CloseWindow");
		
		UWidgetManager_CloseWindow_Params params {};
		params.Window = Window;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.CloseAllWindowWidgets
	 * 		Flags  -> ()
	 */
	void UWidgetManager::CloseAllWindowWidgets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.CloseAllWindowWidgets");
		
		UWidgetManager_CloseAllWindowWidgets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WidgetManager.CloseActiveWindowWidget
	 * 		Flags  -> ()
	 */
	void UWidgetManager::CloseActiveWindowWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WidgetManager.CloseActiveWindowWidget");
		
		UWidgetManager_CloseActiveWindowWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWidgetManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWidgetManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WidgetManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WirePlacementComponent.ServerTryEnterWirePlacementMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWirePlacementComponent::ServerTryEnterWirePlacementMode(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WirePlacementComponent.ServerTryEnterWirePlacementMode");
		
		UWirePlacementComponent_ServerTryEnterWirePlacementMode_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WirePlacementComponent.ServerExitWirePlacementMode
	 * 		Flags  -> ()
	 */
	void UWirePlacementComponent::ServerExitWirePlacementMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WirePlacementComponent.ServerExitWirePlacementMode");
		
		UWirePlacementComponent_ServerExitWirePlacementMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WirePlacementComponent.ServerDisconnectWire
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InConnection                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWirePlacementComponent::ServerDisconnectWire(class AActor* InConnection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WirePlacementComponent.ServerDisconnectWire");
		
		UWirePlacementComponent_ServerDisconnectWire_Params params {};
		params.InConnection = InConnection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WirePlacementComponent.ServerConnectWire
	 * 		Flags  -> ()
	 */
	void UWirePlacementComponent::ServerConnectWire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WirePlacementComponent.ServerConnectWire");
		
		UWirePlacementComponent_ServerConnectWire_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WirePlacementComponent.MulticastUpdateWireLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Start                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     End                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWirePlacementComponent::MulticastUpdateWireLocation(const struct FVector& Start, const struct FVector& End)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WirePlacementComponent.MulticastUpdateWireLocation");
		
		UWirePlacementComponent_MulticastUpdateWireLocation_Params params {};
		params.Start = Start;
		params.End = End;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WirePlacementComponent.GetIsPlacingWire
	 * 		Flags  -> ()
	 */
	bool UWirePlacementComponent::GetIsPlacingWire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WirePlacementComponent.GetIsPlacingWire");
		
		UWirePlacementComponent_GetIsPlacingWire_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WirePlacementComponent.ClientOnEnterWirePlacementMode
	 * 		Flags  -> ()
	 */
	void UWirePlacementComponent::ClientOnEnterWirePlacementMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WirePlacementComponent.ClientOnEnterWirePlacementMode");
		
		UWirePlacementComponent_ClientOnEnterWirePlacementMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.WirePlacementComponent.ClientExitWirePlacementMode
	 * 		Flags  -> ()
	 */
	void UWirePlacementComponent::ClientExitWirePlacementMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.WirePlacementComponent.ClientExitWirePlacementMode");
		
		UWirePlacementComponent_ClientExitWirePlacementMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWirePlacementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWirePlacementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WirePlacementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWorldOffsetComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWorldOffsetComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WorldOffsetComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWorldTraceManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWorldTraceManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.WorldTraceManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineAnchor.GetMaxRange
	 * 		Flags  -> ()
	 */
	float UZiplineAnchor::GetMaxRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineAnchor.GetMaxRange");
		
		UZiplineAnchor_GetMaxRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UZiplineAnchor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UZiplineAnchor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ZiplineAnchor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AZiplineAnchorBuilding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AZiplineAnchorBuilding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ZiplineAnchorBuilding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.OnRep_AnchorLocation
	 * 		Flags  -> ()
	 */
	void AZiplineLine::OnRep_AnchorLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.OnRep_AnchorLocation");
		
		AZiplineLine_OnRep_AnchorLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.OnRep_Anchor2
	 * 		Flags  -> ()
	 */
	void AZiplineLine::OnRep_Anchor2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.OnRep_Anchor2");
		
		AZiplineLine_OnRep_Anchor2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.OnRep_Anchor1
	 * 		Flags  -> ()
	 */
	void AZiplineLine::OnRep_Anchor1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.OnRep_Anchor1");
		
		AZiplineLine_OnRep_Anchor1_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.HasAnchor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UZiplineAnchor*                              Anchor                                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AZiplineLine::HasAnchor(class UZiplineAnchor* Anchor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.HasAnchor");
		
		AZiplineLine_HasAnchor_Params params {};
		params.Anchor = Anchor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.GetTerminalSpeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              VerticalTerminalSpeed                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AZiplineLine::GetTerminalSpeed(float VerticalTerminalSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.GetTerminalSpeed");
		
		AZiplineLine_GetTerminalSpeed_Params params {};
		params.VerticalTerminalSpeed = VerticalTerminalSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.GetSlope
	 * 		Flags  -> ()
	 */
	float AZiplineLine::GetSlope()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.GetSlope");
		
		AZiplineLine_GetSlope_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.GetRightDirection
	 * 		Flags  -> ()
	 */
	struct FVector AZiplineLine::GetRightDirection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.GetRightDirection");
		
		AZiplineLine_GetRightDirection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.GetOtherAnchor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UZiplineAnchor*                              Anchor                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UZiplineAnchor* AZiplineLine::GetOtherAnchor(class UZiplineAnchor* Anchor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.GetOtherAnchor");
		
		AZiplineLine_GetOtherAnchor_Params params {};
		params.Anchor = Anchor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.GetLength
	 * 		Flags  -> ()
	 */
	float AZiplineLine::GetLength()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.GetLength");
		
		AZiplineLine_GetLength_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.GetDirection
	 * 		Flags  -> ()
	 */
	struct FVector AZiplineLine::GetDirection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.GetDirection");
		
		AZiplineLine_GetDirection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.GetAttachedRotation
	 * 		Flags  -> ()
	 */
	struct FRotator AZiplineLine::GetAttachedRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.GetAttachedRotation");
		
		AZiplineLine_GetAttachedRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.GetAnchorLocation2
	 * 		Flags  -> ()
	 */
	struct FVector AZiplineLine::GetAnchorLocation2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.GetAnchorLocation2");
		
		AZiplineLine_GetAnchorLocation2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.GetAnchorLocation1
	 * 		Flags  -> ()
	 */
	struct FVector AZiplineLine::GetAnchorLocation1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.GetAnchorLocation1");
		
		AZiplineLine_GetAnchorLocation1_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.GetAnchor2
	 * 		Flags  -> ()
	 */
	class UZiplineAnchor* AZiplineLine::GetAnchor2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.GetAnchor2");
		
		AZiplineLine_GetAnchor2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.GetAnchor1
	 * 		Flags  -> ()
	 */
	class UZiplineAnchor* AZiplineLine::GetAnchor1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.GetAnchor1");
		
		AZiplineLine_GetAnchor1_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.BlueprintUpdateZipline
	 * 		Flags  -> ()
	 */
	void AZiplineLine::BlueprintUpdateZipline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.BlueprintUpdateZipline");
		
		AZiplineLine_BlueprintUpdateZipline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.BlueprintInitializeZipline
	 * 		Flags  -> ()
	 */
	void AZiplineLine::BlueprintInitializeZipline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.BlueprintInitializeZipline");
		
		AZiplineLine_BlueprintInitializeZipline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineLine.AreAnchors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UZiplineAnchor*                              AnchorA                                                    (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UZiplineAnchor*                              AnchorB                                                    (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AZiplineLine::AreAnchors(class UZiplineAnchor* AnchorA, class UZiplineAnchor* AnchorB)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineLine.AreAnchors");
		
		AZiplineLine_AreAnchors_Params params {};
		params.AnchorA = AnchorA;
		params.AnchorB = AnchorB;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AZiplineLine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AZiplineLine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ZiplineLine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineSelectorPawn.ServerSetCurrentAnchor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UZiplineAnchor*                              ToOther                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AZiplineSelectorPawn::ServerSetCurrentAnchor(class UZiplineAnchor* ToOther)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineSelectorPawn.ServerSetCurrentAnchor");
		
		AZiplineSelectorPawn_ServerSetCurrentAnchor_Params params {};
		params.ToOther = ToOther;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineSelectorPawn.ServerCreateZipline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UZiplineAnchor*                              ToOther                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AZiplineSelectorPawn::ServerCreateZipline(class UZiplineAnchor* ToOther)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineSelectorPawn.ServerCreateZipline");
		
		AZiplineSelectorPawn_ServerCreateZipline_Params params {};
		params.ToOther = ToOther;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineSelectorPawn.ServerCancel
	 * 		Flags  -> ()
	 */
	void AZiplineSelectorPawn::ServerCancel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineSelectorPawn.ServerCancel");
		
		AZiplineSelectorPawn_ServerCancel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineSelectorPawn.OnRep_OriginAnchor
	 * 		Flags  -> ()
	 */
	void AZiplineSelectorPawn::OnRep_OriginAnchor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineSelectorPawn.OnRep_OriginAnchor");
		
		AZiplineSelectorPawn_OnRep_OriginAnchor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineSelectorPawn.IsValidAnchor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UZiplineAnchor*                              Anchor                                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AZiplineSelectorPawn::IsValidAnchor(class UZiplineAnchor* Anchor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineSelectorPawn.IsValidAnchor");
		
		AZiplineSelectorPawn_IsValidAnchor_Params params {};
		params.Anchor = Anchor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineSelectorPawn.IsSelectableAnchor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UZiplineAnchor*                              Anchor                                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AZiplineSelectorPawn::IsSelectableAnchor(class UZiplineAnchor* Anchor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineSelectorPawn.IsSelectableAnchor");
		
		AZiplineSelectorPawn_IsSelectableAnchor_Params params {};
		params.Anchor = Anchor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineSelectorPawn.IsConnectionBlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UZiplineAnchor*                              Anchor                                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AZiplineSelectorPawn::IsConnectionBlocked(class UZiplineAnchor* Anchor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineSelectorPawn.IsConnectionBlocked");
		
		AZiplineSelectorPawn_IsConnectionBlocked_Params params {};
		params.Anchor = Anchor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineSelectorPawn.IsAlreadyConnected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UZiplineAnchor*                              Anchor                                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AZiplineSelectorPawn::IsAlreadyConnected(class UZiplineAnchor* Anchor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineSelectorPawn.IsAlreadyConnected");
		
		AZiplineSelectorPawn_IsAlreadyConnected_Params params {};
		params.Anchor = Anchor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineSelectorPawn.HandleZiplineAttachedToOriginAnchor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UZiplineAnchor*                              Sender                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AZiplineLine*                                Line                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AZiplineSelectorPawn::HandleZiplineAttachedToOriginAnchor(class UZiplineAnchor* Sender, class AZiplineLine* Line)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineSelectorPawn.HandleZiplineAttachedToOriginAnchor");
		
		AZiplineSelectorPawn_HandleZiplineAttachedToOriginAnchor_Params params {};
		params.Sender = Sender;
		params.Line = Line;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineSelectorPawn.GetErrorString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UZiplineAnchor*                              Anchor                                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString AZiplineSelectorPawn::GetErrorString(class UZiplineAnchor* Anchor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineSelectorPawn.GetErrorString");
		
		AZiplineSelectorPawn_GetErrorString_Params params {};
		params.Anchor = Anchor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZiplineSelectorPawn.GetCurrentAnchorRequirements
	 * 		Flags  -> ()
	 */
	TArray<struct FRecipeRequirements> AZiplineSelectorPawn::GetCurrentAnchorRequirements()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZiplineSelectorPawn.GetCurrentAnchorRequirements");
		
		AZiplineSelectorPawn_GetCurrentAnchorRequirements_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AZiplineSelectorPawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AZiplineSelectorPawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ZiplineSelectorPawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZoneManagerComponent.OnRep_PlayerOverlapVolumes
	 * 		Flags  -> ()
	 */
	void UZoneManagerComponent::OnRep_PlayerOverlapVolumes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZoneManagerComponent.OnRep_PlayerOverlapVolumes");
		
		UZoneManagerComponent_OnRep_PlayerOverlapVolumes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZoneManagerComponent.OnDayNightChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsDayTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UZoneManagerComponent::OnDayNightChange(bool bIsDayTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZoneManagerComponent.OnDayNightChange");
		
		UZoneManagerComponent_OnDayNightChange_Params params {};
		params.bIsDayTime = bIsDayTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function Maine.ZoneManagerComponent.GetLocalZoneRowHandle
	 * 		Flags  -> ()
	 */
	struct FDataTableRowHandle UZoneManagerComponent::GetLocalZoneRowHandle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Maine.ZoneManagerComponent.GetLocalZoneRowHandle");
		
		UZoneManagerComponent_GetLocalZoneRowHandle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UZoneManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UZoneManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Maine.ZoneManagerComponent");
		return ptr;
	}

}


